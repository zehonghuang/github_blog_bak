{"meta":{"version":1,"warehouse":"3.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/file/ClientDemo.java","path":"file/ClientDemo.java","modified":0,"renderable":0},{"_id":"source/file/ServerDemo.java","path":"file/ServerDemo.java","modified":0,"renderable":0},{"_id":"source/image/ByteBuffer.png","path":"image/ByteBuffer.png","modified":0,"renderable":0},{"_id":"source/image/ByteBufAllocator体系.png","path":"image/ByteBufAllocator体系.png","modified":0,"renderable":0},{"_id":"source/image/bytebuffer指针.png","path":"image/bytebuffer指针.png","modified":0,"renderable":0},{"_id":"source/image/jvm虚拟内存地址.png","path":"image/jvm虚拟内存地址.png","modified":0,"renderable":0},{"_id":"source/file/kqueue.pdf","path":"file/kqueue.pdf","modified":0,"renderable":0},{"_id":"source/image/ByteBuf体系.png","path":"image/ByteBuf体系.png","modified":0,"renderable":0},{"_id":"source/image/AnnotationConfigServletWebServerApplicationContext.png","path":"image/AnnotationConfigServletWebServerApplicationContext.png","modified":0,"renderable":0},{"_id":"source/image/DefaultListableBeanFactory.png","path":"image/DefaultListableBeanFactory.png","modified":0,"renderable":0},{"_id":"source/image/Channel体系.png","path":"image/Channel体系.png","modified":0,"renderable":0},{"_id":"source/image/EventLoop家族.png","path":"image/EventLoop家族.png","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/default.css","path":"css/default.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/donate/index.html","path":"donate/index.html","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/AliPayQR.png","path":"img/AliPayQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/BTCQR.png","path":"img/BTCQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/WeChatQR.png","path":"img/WeChatQR.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/gitment.browser.js","path":"js/gitment.browser.js","modified":0,"renderable":1},{"_id":"source/image/jstack.png-50pencent","path":"image/jstack.png-50pencent","modified":0,"renderable":0},{"_id":"source/image/WX20190615-111406.png","path":"image/WX20190615-111406.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"4f2d652687ee5dd0246a029d1fddbb94aff3261a","modified":1576467136246},{"_id":"source/CNAME","hash":"3b6b1716d2150e97e4c2c3731340b43e7287d264","modified":1547656586000},{"_id":"source/apple-touch-icon.png","hash":"241d753379c445a9a231f705bb3bfdb602c7e8fd","modified":1547656586000},{"_id":"source/favicon.ico","hash":"29b26120d2c5d0b2311a0b4aea2f8dd10438b9e2","modified":1547656586000},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1576662114233},{"_id":"themes/maupassant/_config.yml","hash":"d67293dac1559afd76219b5a9c7e5a006e1f9346","modified":1576731909988},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1576662114233},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1576662114233},{"_id":"themes/maupassant/README.md","hash":"1e45ec576bcb84881717dd8e1c28d6f7c251542b","modified":1576662114233},{"_id":"themes/maupassant/package.json","hash":"1fb5aff525bcd3b018c31506a66ba124c570bb6b","modified":1576662144018},{"_id":"source/_drafts/20180311-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（二）.md","hash":"3bc4b018eddd0147d330175680eca5ed8c6e2982","modified":1547656586000},{"_id":"source/_drafts/20170129-初学Clojure—与Java相互调用.md","hash":"c87f0cf3a4ae04978cacd93fe468cbc512c78958","modified":1547656586000},{"_id":"source/_drafts/20170222-初学Clojure—宏！.md","hash":"a37da5f2946fbdf33a7fd2ede005a56d277b2015","modified":1547656586000},{"_id":"themes/maupassant/package-lock.json","hash":"a3d03dee599bd0cec041d36f3b822f86522118f1","modified":1576662232943},{"_id":"source/_drafts/20181126-【Spring源码分析】BeanFactory的生命周期.md","hash":"c93ae0e0d36d52dad66db26c88637f3ef32015e8","modified":1547656586000},{"_id":"source/_posts/20160427-关于女权.md","hash":"3997dd921a2014dea905935a0e95fda7be8b2413","modified":1547656586000},{"_id":"source/_drafts/【网络编程】Netty的线程池实现-EventLoop家族.md","hash":"7a9a9e7af1ccee72631823494ba92591ac882639","modified":1547989798000},{"_id":"source/_posts/20160429-MySQ常见命令.md","hash":"679d4e5981426e943560e5e735cf08421619aefd","modified":1547656586000},{"_id":"source/_posts/20160429-MySQL5-6安装.md","hash":"ac931f2a0616070d9882d837c62f4863376f0b6b","modified":1547656586000},{"_id":"source/_posts/20160429-MyBatis-Spring整合.md","hash":"7d98fcd3aeb4b97d316a52c17f7e3a56d3e8362a","modified":1547656586000},{"_id":"source/_posts/20160429-设计模式－模版方法.md","hash":"59c1d087d06c73654954e1e5d9c920430fa4cf5d","modified":1547656586000},{"_id":"source/_posts/20160429-小诗几首.md","hash":"8e22307e6416e0559c2a44223226b6e38388f82f","modified":1547656586000},{"_id":"source/_posts/20160505-设计模式－适配器模式.md","hash":"e0692852785e5158c0915186d160ff6378f8de13","modified":1547656586000},{"_id":"source/_posts/20160508-设计模式－适配器与装饰器.md","hash":"c88412601bf6fc8e72ce130833cdd2631ccf3417","modified":1547656586000},{"_id":"source/_posts/20160503-设计模式－桥接模式.md","hash":"0efca9fe2f17f8dc2a9d64b446115dc33eb63332","modified":1547656586000},{"_id":"source/_posts/20160509-设计模式－组合模式.md","hash":"558fad42da5df9822b7aa43129e1d2e2dc0b78c4","modified":1547656586000},{"_id":"source/_posts/20160511-SpringMVC拦截器Interceptor.md","hash":"4a8185dff6bce6f13c2671e3f03ef88a88bc104a","modified":1547656586000},{"_id":"source/_posts/20160506-设计模式－装饰者模式.md","hash":"d49f421dd653cc53d940563dbd229913d0084cee","modified":1547656586000},{"_id":"source/_posts/20160512-设计模式－观察者模式.md","hash":"bf65c58586f4db89f460b34b70cfa7ef1a0e2594","modified":1547656586000},{"_id":"source/_posts/20160515-设计模式－职责链模式.md","hash":"9fbbe9b8216d0f5f9a366b80c49510831b0dfd8d","modified":1547656586000},{"_id":"source/_posts/20160520-设计模式－状态模式.md","hash":"e976a25461b7c7f15fca84d8313c0db4642b8924","modified":1547656586000},{"_id":"source/_posts/20160519-设计模式－策略模式.md","hash":"7a1a3350cddc41a64f9c0bddda3c943808d850e9","modified":1547656586000},{"_id":"source/_posts/20160716-浅谈Java集合框架－比较HashMap与Hashtable.md","hash":"25c69985b4575d32fbfda16fe91e184cfa55614b","modified":1547656586000},{"_id":"source/_posts/20160628－浅谈Java集合框架－看看HashMap源码，了解它是咋运作的.md","hash":"182691820aa23bb0bb74a7b92b89c7565e19e027","modified":1547656586000},{"_id":"source/_posts/20160628－浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？.md","hash":"62a29d186b17bb53937485621b8ab2b688a470b1","modified":1547656586000},{"_id":"source/_posts/20160728-Linux－awk编程.md","hash":"c18e7911bb4ac6f87961029e5258f3e77d4319bb","modified":1547656586000},{"_id":"source/_posts/20161003-浅谈Java集合框架-来看看LinkHashMap是啥.md","hash":"24faec0901c17ecedb5b04bdff146bb976ff81bf","modified":1547656586000},{"_id":"source/_posts/20161202-LinkedIn的Parseq-ning-httpclient异步请求框架的使用.md","hash":"61e809a0b1fcbb6cd2403e3ad2a2a0e4e7a4a97b","modified":1547656586000},{"_id":"source/_posts/20170119-初学Clojure—循环与尾递归.md","hash":"aa30bb077a11d863d172a0e9664afac8eb03b853","modified":1547656586000},{"_id":"source/_posts/20170115-初学Clojure—基本语法.md","hash":"2f38b781d326c89939e8731b2e50b49ffa72b268","modified":1547656586000},{"_id":"source/_posts/20170117-初学Clojure—定义函数.md","hash":"56f32d47325084b248ace0251e70b23d71e88fe2","modified":1547656586000},{"_id":"source/_posts/20170121-初学Clojure—函数与高阶函数.md","hash":"ef935d69116f2c994ae778105bc81b3b4f6023f1","modified":1547656586000},{"_id":"source/_posts/20170123-初学Clojure—集合与数据结构.md","hash":"947ce6eefc9569169456c5baf4332d0c6e1e7f6f","modified":1547656586000},{"_id":"source/_posts/20170129-初学Clojure—不可变性与惰性.md","hash":"3d46cc504279d0c72e2c4dfaba32ca5277a63bf3","modified":1547656586000},{"_id":"source/_posts/20180702 -【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！.md","hash":"81789f28bf67f1f0cfbdd08a7692e20508f3133d","modified":1547656586000},{"_id":"source/_posts/20180227-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（一）.md","hash":"540f40603bc9a497ba9274ae91499966b220e16a","modified":1547656586000},{"_id":"source/_posts/20170403-asynchttpclient源码分析-基于Netty的连接池实现.md","hash":"ae50ceb7b7b78b85585ddb2efd96b3f167c3e0f1","modified":1547656586000},{"_id":"source/_posts/20180902-【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致.md","hash":"e1be1d682eb240ea2dab0813807429f4eda1b521","modified":1547656586000},{"_id":"source/_posts/20181123-【Spring源码分析】BeanFactory体系的作用.md","hash":"8bd864bcb12360637f35eb1643c7d0f1afacd5eb","modified":1547656586000},{"_id":"source/_posts/20180906-【Dubbo源码分析】四种负载均衡.md","hash":"84e528a294fdc0e43f3bd1319a3ac17b34451d9b","modified":1547656586000},{"_id":"source/about/index.md","hash":"ed5adc368cb96266298cf78145bc175359caac04","modified":1547656586000},{"_id":"source/file/ClientDemo.java","hash":"909ec92eabdaddbab4e07b5361a8c5529cbfad04","modified":1547656586000},{"_id":"source/_posts/20190109-【网络编程】NIO的深入解析.md","hash":"ac903fbb7e4f32cafbcf5e89865a2ea53fbd1552","modified":1576731951050},{"_id":"source/_posts/20191216-【并发编程】new-Thread时JVM做了什么？.md","hash":"36ecaec6cba0dd5f398cd4f7853a5bf0ef7773d7","modified":1576672959599},{"_id":"source/file/ServerDemo.java","hash":"7869dbab305418a1cd3ed69c56730f35551b2211","modified":1547656586000},{"_id":"source/image/ByteBuffer.png","hash":"aa3a3bb217266149b80d2de6fea28bdb556829cf","modified":1547656586000},{"_id":"source/image/ByteBufAllocator体系.png","hash":"d31e6d986611da2dbbd258a99af3b80849cd6c6e","modified":1549082188000},{"_id":"source/image/bytebuffer指针.png","hash":"000a8cf8cc74075d8e1d9f473e892c641a8d7bd5","modified":1547656586000},{"_id":"source/image/jvm虚拟内存地址.png","hash":"b1c91364cae12d77b3dc972126d29baedae4606e","modified":1547656586000},{"_id":"themes/maupassant/layout/archive.pug","hash":"2fe2cff144c9b7b509b7b6cb1b3acba27aa1d132","modified":1576662114238},{"_id":"themes/maupassant/layout/base.pug","hash":"a4e32bcb580b76af9ad0582d9d3f0107e34509ed","modified":1576662114238},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"16c4d1079450f801b5ac079d3cc101856d8f387c","modified":1576662114238},{"_id":"themes/maupassant/layout/page.pug","hash":"8cfd307b13cad8be34a1e75c4566f96c1722e08e","modified":1576662114238},{"_id":"themes/maupassant/layout/index.pug","hash":"0435a4e5f5c6976e05b3079d335453c246f5ba6e","modified":1576662114238},{"_id":"themes/maupassant/layout/post.pug","hash":"f4d17b1b2a590cc076e80d912591648f9e99aeaf","modified":1576662114239},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1576662114239},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"195cde32be65817fd4ed03590c71522913f1e1b8","modified":1576662114239},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1576662114239},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1576662114234},{"_id":"themes/maupassant/languages/en.yml","hash":"c3fb5c155560a00889a75882c680afe1197ebf1a","modified":1576662114234},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1576662114234},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1576662114234},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1576662114234},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"710b204e637c18b86ac7c681f7d1cf8dfeddf4bb","modified":1576662114235},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"bf3ab970f2ab3f29ddeb9f59bf98163be635e284","modified":1576662114235},{"_id":"themes/maupassant/languages/ru.yml","hash":"2476a631f4d3c668de04af85a6c2c97ba2a57e96","modified":1576662114234},{"_id":"source/file/kqueue.pdf","hash":"8a342a6d29e50a7d07db8b11e60b6df17bc51b26","modified":1547656586000},{"_id":"source/image/ByteBuf体系.png","hash":"87ccd21af561f35dfc14d43602709a0c3a546983","modified":1549082043000},{"_id":"source/image/AnnotationConfigServletWebServerApplicationContext.png","hash":"7356b024cfa640cf922fcfbaa1a384843dbf95f2","modified":1547656586000},{"_id":"source/image/DefaultListableBeanFactory.png","hash":"1dfa6281ffbe85c9801ad822a788def47537ba09","modified":1547656586000},{"_id":"source/image/Channel体系.png","hash":"91f758555e7e373e9287fb6540a1cd78f879a705","modified":1547656586000},{"_id":"source/image/EventLoop家族.png","hash":"d288ace904b19a841c797403f570ed51aad5ebc8","modified":1547656586000},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"31bf35a57634ff8a796c71dd5246eba3a3db10ee","modified":1576662114235},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"507fd8d2fde98df6216ed7c8f60ebea7cf77bfb2","modified":1576662114235},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1576662114235},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"8af6e452ea2a56b110b5079f79bf743b643f7d6c","modified":1576662114236},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1576662114236},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1576662114236},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1576662114236},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1576662114236},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1576662114237},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1576662114237},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"004c8a3edc19d428179b83a0f97eae3c1a6d3cfa","modified":1576662114237},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1576662114237},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1576662114237},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1576662114237},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1576662114238},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1576662114238},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"4102d446f13b02ff617f055c2a8f726bca12744a","modified":1576662114237},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1576662114238},{"_id":"themes/maupassant/source/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1576662114240},{"_id":"themes/maupassant/source/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1576662114240},{"_id":"themes/maupassant/source/donate/index.html","hash":"c42428765d48c8674ce28100ad95fdf4c7806a85","modified":1576662114241},{"_id":"themes/maupassant/source/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1576662114241},{"_id":"themes/maupassant/source/css/style.scss","hash":"44c876b3b2f05d2639659590cfe533a277e166d7","modified":1576662114240},{"_id":"themes/maupassant/source/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1576662114241},{"_id":"themes/maupassant/source/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1576662114242},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1576662114242},{"_id":"themes/maupassant/source/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1576662114242},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1576662114242},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1576662114243},{"_id":"themes/maupassant/source/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1576662114243},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1576662114243},{"_id":"themes/maupassant/source/js/donate.js","hash":"780beaaf44b1e6c057752bdbc085b1048937e5e7","modified":1576662114243},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1576662114243},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1576662114243},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1576662114245},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1576662114245},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1576662114245},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1576662114245},{"_id":"themes/maupassant/source/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1576662114244},{"_id":"source/image/jstack.png-50pencent","hash":"2d2f9decb2aedcf28682b87cef32068e9b0c18ac","modified":1547656586000},{"_id":"source/image/WX20190615-111406.png","hash":"c8eb825d9a1676c3daf269b408de2672c5105d17","modified":1560568450000},{"_id":"public/search.xml","hash":"140e07ffc82d8aa17fa5b009a830d93405fceb7e","modified":1576731967843},{"_id":"public/about/index.html","hash":"7bd04da77c9831afa807c61ccdaa8763cf7fa854","modified":1576731967843},{"_id":"public/2016/04/29/20160429-小诗几首/index.html","hash":"8ace2b9a8c47216a62a04ffe7b01921edf4385d1","modified":1576731967843},{"_id":"public/2016/04/29/20160429-MySQL5-6安装/index.html","hash":"d2e0b906ddfadcbed0f81429ad5f805fbf6d549c","modified":1576731967843},{"_id":"public/archives/index.html","hash":"ddc926d9c2a5e335f4777e80e2a2037d09f1c2f4","modified":1576731967843},{"_id":"public/archives/page/2/index.html","hash":"183bc16bfc62889689b6461b99a16283e318d7a4","modified":1576731967843},{"_id":"public/archives/page/3/index.html","hash":"ab7910ff271ddd84465ebb7200ba0a15fde0487f","modified":1576731967843},{"_id":"public/archives/page/4/index.html","hash":"6f184c442fc3c4da1d441610bca4969756c192e3","modified":1576731967843},{"_id":"public/archives/2016/index.html","hash":"ae5da1dad3cbb53a1e92a19393de2f399c989106","modified":1576731967843},{"_id":"public/archives/2016/page/2/index.html","hash":"e581bac569b95a7220d01085c453a45467b4d2a9","modified":1576731967843},{"_id":"public/archives/2016/page/3/index.html","hash":"470c486b219e3cf96bb137a7a09b73bc80271fff","modified":1576731967843},{"_id":"public/archives/2016/04/index.html","hash":"3642d1a49634b4716e1d13773680ecfe04b033da","modified":1576731967843},{"_id":"public/archives/2016/05/index.html","hash":"c18c51933548156fe99afc6adf102799eb8d07dd","modified":1576731967843},{"_id":"public/archives/2016/06/index.html","hash":"5065f4d546a7a192f65437f831c9863597bf1b4a","modified":1576731967843},{"_id":"public/archives/2016/07/index.html","hash":"bf61ee1a30cecc5d6d3ceb376e57f94f1f27bd22","modified":1576731967843},{"_id":"public/archives/2016/10/index.html","hash":"454a0a9d41d9086b180fe4ec7119fd322eb62a92","modified":1576731967843},{"_id":"public/archives/2016/12/index.html","hash":"f07d0b997eb7ea80943f3f642fccf3a9c0b1a985","modified":1576731967843},{"_id":"public/archives/2017/index.html","hash":"8401b419aa7312fadaa43086858735812a26e160","modified":1576731967843},{"_id":"public/archives/2017/01/index.html","hash":"6cb3dccca2218a305c1e8f8560760b9c41f7725b","modified":1576731967843},{"_id":"public/archives/2017/04/index.html","hash":"cc278fbba864f3e4297d32a86e162f67e4a7ac92","modified":1576731967843},{"_id":"public/archives/2018/index.html","hash":"7cff88377cbd8826b8ecd8e7cf0e763fb3871eb0","modified":1576731967843},{"_id":"public/archives/2018/02/index.html","hash":"77f8f0f5c2d37219c40710ec9fe286ce55596e1c","modified":1576731967843},{"_id":"public/archives/2018/07/index.html","hash":"cb119941ecbd648d5445b2bfa37958dc01021ebc","modified":1576731967843},{"_id":"public/archives/2018/09/index.html","hash":"b749d8a48ba96afe89c7ce96afbe9f5bc1298963","modified":1576731967843},{"_id":"public/archives/2018/11/index.html","hash":"ca59247ff8788f28b4f09a9648bdcfc5864500ff","modified":1576731967843},{"_id":"public/archives/2019/index.html","hash":"ee2ca489f4ec14f674e3ac12658e7f33fff56019","modified":1576731967843},{"_id":"public/archives/2019/01/index.html","hash":"0dd4cc04aaa23d3b0ae0d294a4201621a5103b9b","modified":1576731967843},{"_id":"public/archives/2019/12/index.html","hash":"09f35d01139f73f6e4de9e92946ff62ca258bd28","modified":1576731967843},{"_id":"public/categories/java并发编程/index.html","hash":"ffa48f44adde46e9e902d9e7c46754065580f32f","modified":1576731967843},{"_id":"public/categories/函数编程/index.html","hash":"82040b07ecb8780c6d62aa9b95b43dacb3e02af2","modified":1576731967843},{"_id":"public/categories/Spring源码分析/index.html","hash":"4d939bf1b0bf26ae8174a5a6c5803096ad6d287e","modified":1576731967843},{"_id":"public/categories/小文/index.html","hash":"83d72993b82619d60bdb710a5cb69aa1c4c054fa","modified":1576731967843},{"_id":"public/categories/MySQL/index.html","hash":"a564e6a0e94084a1d461fcdafe35db076e135622","modified":1576731967843},{"_id":"public/categories/Java/index.html","hash":"12bd25441174fde688817ff507c093bf7b61a1c9","modified":1576731967843},{"_id":"public/categories/设计模式/index.html","hash":"0be36a58d5420036203b2bcca5a6bdffe63323b9","modified":1576731967843},{"_id":"public/categories/小诗/index.html","hash":"4e68db0ae7b81a0237f21a1d3b07400d89c687e9","modified":1576731967843},{"_id":"public/categories/集合框架/index.html","hash":"abb8c0619cdb7925993f113dbabd41a1d8eb42d8","modified":1576731967843},{"_id":"public/categories/Linux/index.html","hash":"4cb521bdbf411d1b70857304808b65e997899425","modified":1576731967843},{"_id":"public/categories/开源框架/index.html","hash":"2f3ee46e912343fdf0db88fc659aafc58e51e5f3","modified":1576731967843},{"_id":"public/categories/Netty/index.html","hash":"5a92150851b4e77c9bf8646592a99d8bf47e5c7c","modified":1576731967843},{"_id":"public/categories/rpc框架/index.html","hash":"636056e24f5a74f0b873181ebe3543fa8f7f46aa","modified":1576731967843},{"_id":"public/categories/java网络编程/index.html","hash":"b0c8cf325499e1af3421a1f6b6b0f1ea4d5839d9","modified":1576731967843},{"_id":"public/tags/java/index.html","hash":"828ac7f1ebe215068ab9d2813930166633083a82","modified":1576731967843},{"_id":"public/tags/并发编程/index.html","hash":"4f59bd42049ed32c2bec923bfbcc9742bdaf83d2","modified":1576731967843},{"_id":"public/tags/同步/index.html","hash":"0ce7685014d7e18f209933bb0dc6d1d207e1b55a","modified":1576731967843},{"_id":"public/tags/公平锁/index.html","hash":"def588db4fc80596ccbb376d1a78fceae13b39df","modified":1576731967843},{"_id":"public/tags/非公平锁/index.html","hash":"4a6d3b2fe43063255fa44a14020ad082f0b4bc6d","modified":1576731967843},{"_id":"public/tags/可重入锁/index.html","hash":"b0183d4e9ddb8da2c50cec3694f1bde5c4c7fd3b","modified":1576731967843},{"_id":"public/tags/读写锁/index.html","hash":"389ca2a358632d21020f070c8fb62c6b7a9e4da1","modified":1576731967843},{"_id":"public/tags/clojure/index.html","hash":"d069aa449cbbb6de44328c92ce4cb59bd0632d5a","modified":1576731967843},{"_id":"public/tags/教程/index.html","hash":"ca6611ead854b8cdd6579e38a948fc63b011d017","modified":1576731967843},{"_id":"public/tags/并发编程语言/index.html","hash":"9045ac293dbf7bc1514a3d59326a7800edfd1295","modified":1576731967843},{"_id":"public/tags/Spring/index.html","hash":"27737e7c27d9429b59a882662b9c9065c83739a2","modified":1576731967843},{"_id":"public/tags/AOP/index.html","hash":"8ec9bae2b6505baadd2e9bdf66514c9e83116e80","modified":1576731967843},{"_id":"public/tags/IOC控制反转/index.html","hash":"9272c6c05bf94bcb7d13e71d3fc97f7635953307","modified":1576731967843},{"_id":"public/tags/BeanFactory/index.html","hash":"21ed715d3b4f7f9e76780ffcd3ac34ab983d8781","modified":1576731967843},{"_id":"public/tags/mysql/index.html","hash":"413cd52cb2b41d1519ab932f8c047761ed452b36","modified":1576731967843},{"_id":"public/tags/java/page/2/index.html","hash":"8b48d438b97c75db3e2d22855f48eab93485dd5d","modified":1576731967843},{"_id":"public/tags/spring/index.html","hash":"35115cb0457d9918a699c8d36b1aa6aad5f96ae2","modified":1576731967843},{"_id":"public/tags/设计模式/index.html","hash":"0be36a58d5420036203b2bcca5a6bdffe63323b9","modified":1576731967843},{"_id":"public/tags/Hashtable/index.html","hash":"ac735aca42f3998dff4a79fb99843e731ee0b1fe","modified":1576731967843},{"_id":"public/tags/HashMap/index.html","hash":"27bc669f7378a463f8e18c194ca509617d25e314","modified":1576731967843},{"_id":"public/tags/hashmap/index.html","hash":"abbb0d6ab2fa20dfc8fcafb9daa8900fd63d5e20","modified":1576731967843},{"_id":"public/tags/LinkedArray/index.html","hash":"5490bad4c4c10c75d08f3b76c29cd2b48b52e5ac","modified":1576731967843},{"_id":"public/tags/LinkedHashMap/index.html","hash":"6157aefaac99b399a8ae1ba9172e8a75d78bbf61","modified":1576731967843},{"_id":"public/tags/awk/index.html","hash":"66be9cdf6fd040a020335b6f4c0b8dfbf8ba76f2","modified":1576731967843},{"_id":"public/tags/linux/index.html","hash":"ff3daf5e85a0d5ec1af6da59f4e2db20b814b2c6","modified":1576731967843},{"_id":"public/tags/文本处理/index.html","hash":"c5a408a3fada0b5634cf1a0ef331e29191a07eb3","modified":1576731967843},{"_id":"public/tags/异步框架/index.html","hash":"595e07489547e6ae6972c9b500e1f5a9b22cd503","modified":1576731967843},{"_id":"public/tags/parseq/index.html","hash":"bd87f66e983aa3a73526c446dd7455d288c21fff","modified":1576731967843},{"_id":"public/tags/线程饥渴/index.html","hash":"b3bd17609595bd23edcbf034f36afbe866d7af32","modified":1576731967843},{"_id":"public/tags/ReentrantLock/index.html","hash":"801ffe0d1e96d39ec7093613d624ab7647aa8c88","modified":1576731967843},{"_id":"public/tags/Netty/index.html","hash":"5a92150851b4e77c9bf8646592a99d8bf47e5c7c","modified":1576731967843},{"_id":"public/tags/源码分析/index.html","hash":"a95b0b892555f448a17939a914da9eba258b6555","modified":1576731967843},{"_id":"public/tags/NIO/index.html","hash":"15bcbb39e84329fbe5e4c6476d05d4170104fc64","modified":1576731967843},{"_id":"public/tags/Dubbo/index.html","hash":"69652e5dc5940b64802461cc7f45a7251f83fbe6","modified":1576731967843},{"_id":"public/tags/SPI/index.html","hash":"ebde59f3e77d562d219b5e2f82661d1db4c5a4bb","modified":1576731967843},{"_id":"public/tags/反射/index.html","hash":"73c49c1c66da4d13fe09847ad30d072717cf01df","modified":1576731967843},{"_id":"public/tags/rpc/index.html","hash":"3489494511263d2e00ec2159d9e23ce9962fdb29","modified":1576731967843},{"_id":"public/tags/负载均衡/index.html","hash":"8fda9fbeaccc506f8a1b167ff575c4842dc4eb71","modified":1576731967843},{"_id":"public/tags/LoadBalance/index.html","hash":"84c9e5ec2f7732e4842aa65e9caaa7d9cf16a40d","modified":1576731967843},{"_id":"public/tags/Linux内核/index.html","hash":"166c32c593529c35b85db0380cc65fa5065fa8cd","modified":1576731967843},{"_id":"public/tags/网络编程/index.html","hash":"528f1fe8e18b4ace0785ae2ebfd372dccb9dffcf","modified":1576731967843},{"_id":"public/tags/C/index.html","hash":"4921054a0a199aa37b12c6c826121fa4282573a6","modified":1576731967843},{"_id":"public/tags/Thread/index.html","hash":"7f95082f27623c026470ca1bc8c77ea839d51d89","modified":1576731967843},{"_id":"public/tags/Linux编程/index.html","hash":"37b281eec7e41f993324bee90ef839a55a1d4680","modified":1576731967843},{"_id":"public/2019/12/16/20191216-【并发编程】new-Thread时JVM做了什么？/index.html","hash":"4e137e80691b4da0693f7ba37b8d20a4f238f44f","modified":1576731967843},{"_id":"public/2019/01/09/20190109-【网络编程】NIO的深入解析/index.html","hash":"6aa79e4e51ac703835012d40c42dc60cb15b1a9f","modified":1576731967843},{"_id":"public/2018/11/23/20181123-【Spring源码分析】BeanFactory体系的作用/index.html","hash":"4519628a1a2d2145b21c4bc23e7b2c03084c75a6","modified":1576731967843},{"_id":"public/2018/09/06/20180906-【Dubbo源码分析】四种负载均衡/index.html","hash":"ff095e745aaf0ebdc9da19770066f1db48fcb3e9","modified":1576731967843},{"_id":"public/2018/09/02/20180902-【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致/index.html","hash":"cef4900cc0611d29d31eb0c3fbe40a2abeedaa2e","modified":1576731967843},{"_id":"public/2018/07/02/20180702 -【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！/index.html","hash":"cae1e92c6c207c22592985b001e2edc30cf9e963","modified":1576731967843},{"_id":"public/2018/02/27/20180227-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（一）/index.html","hash":"7e83dff08f413a67057037e6242fe014d4908ec6","modified":1576731967843},{"_id":"public/2017/04/03/20170403-asynchttpclient源码分析-基于Netty的连接池实现/index.html","hash":"c0e55600bd79e2cb1d7cbb13aab580799a4ce565","modified":1576731967843},{"_id":"public/2017/01/29/20170129-初学Clojure—不可变性与惰性/index.html","hash":"dc31646e0b845e3f9641f8ff6b09a043b4b6d9e6","modified":1576731967843},{"_id":"public/2017/01/23/20170123-初学Clojure—集合与数据结构/index.html","hash":"f32fd5ec38fb6bf5af3120500d7ba0c6bceb76e7","modified":1576731967843},{"_id":"public/2017/01/21/20170121-初学Clojure—函数与高阶函数/index.html","hash":"00e70eb6ed4655ec6a8f1f226fd54022fc7ee11a","modified":1576731967843},{"_id":"public/2017/01/19/20170119-初学Clojure—循环与尾递归/index.html","hash":"08853ea51475c6b49ccabf140da00dc2ac09ab48","modified":1576731967843},{"_id":"public/2017/01/15/20170115-初学Clojure—基本语法/index.html","hash":"e4256cb9c335e4898fe3f0ed458c45f3408611a5","modified":1576731967843},{"_id":"public/2017/01/17/20170117-初学Clojure—定义函数/index.html","hash":"8a4fe6f61e0b9012c563d898a7a0b1d2e8d2b3b8","modified":1576731967843},{"_id":"public/2016/12/02/20161202-LinkedIn的Parseq-ning-httpclient异步请求框架的使用/index.html","hash":"1efffd27219933db57cea1bc2955e3dec95e259c","modified":1576731967843},{"_id":"public/2016/10/03/20161003-浅谈Java集合框架-来看看LinkHashMap是啥/index.html","hash":"f227760347480ddd57bfb2cd3efe0f035259f66f","modified":1576731967843},{"_id":"public/2016/07/28/20160728-Linux－awk编程/index.html","hash":"a32e0bd4427a5fc1487f3dad8abd4bb219073ef9","modified":1576731967843},{"_id":"public/2016/07/16/20160716-浅谈Java集合框架－比较HashMap与Hashtable/index.html","hash":"1d84769a403085c107eed116b64eee92226b5c81","modified":1576731967843},{"_id":"public/2016/06/28/20160628－浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？/index.html","hash":"e15194347278da8d15c98d4f59e38b0d85d5d35e","modified":1576731967843},{"_id":"public/2016/06/28/20160628－浅谈Java集合框架－看看HashMap源码，了解它是咋运作的/index.html","hash":"7e70f393753d9749214d17129552b71f5b2c9156","modified":1576731967843},{"_id":"public/2016/05/20/20160520-设计模式－状态模式/index.html","hash":"b2e27524710b602886921f3097aa469581f9a139","modified":1576731967843},{"_id":"public/2016/05/19/20160519-设计模式－策略模式/index.html","hash":"ecaecc3a7b3f2ad230eedc90beae6fc2adbfb7a2","modified":1576731967843},{"_id":"public/2016/05/15/20160515-设计模式－职责链模式/index.html","hash":"3f086c549e4762cc8297e11e6baa9f0aef251fb4","modified":1576731967843},{"_id":"public/2016/05/12/20160512-设计模式－观察者模式/index.html","hash":"4f236b4d717f5a61461918a51761490774903258","modified":1576731967843},{"_id":"public/2016/05/11/20160511-SpringMVC拦截器Interceptor/index.html","hash":"15e345c4566ade2213124db195fcba9d17e84994","modified":1576731967843},{"_id":"public/2016/05/09/20160509-设计模式－组合模式/index.html","hash":"afe7be033e771ac4c60f193e0e46cb84d5b38348","modified":1576731967843},{"_id":"public/2016/05/08/20160508-设计模式－适配器与装饰器/index.html","hash":"54c534d310d4c73020b2d682f4dce15dc16841f5","modified":1576731967843},{"_id":"public/2016/05/06/20160506-设计模式－装饰者模式/index.html","hash":"4c34598659330b3f7bda0a47a635230f2e89ac89","modified":1576731967843},{"_id":"public/2016/05/05/20160505-设计模式－适配器模式/index.html","hash":"ad69fc235f4240cbc1524c8fb79df6fe3c45e13f","modified":1576731967843},{"_id":"public/2016/05/03/20160503-设计模式－桥接模式/index.html","hash":"9b33c1985da4320bc39b1452a904643ea506da2d","modified":1576731967843},{"_id":"public/2016/04/30/20160429-设计模式－模版方法/index.html","hash":"cedce73b1f6ed80bd73d38c7468ffc3cac27ceef","modified":1576731967843},{"_id":"public/2016/04/29/20160429-MyBatis-Spring整合/index.html","hash":"d1ae26b9bd3807124c0fdd7590fb946b36897bdc","modified":1576731967843},{"_id":"public/2016/04/29/20160429-MySQ常见命令/index.html","hash":"9392752a368935cb67c8db70bf3ee0526683361c","modified":1576731967843},{"_id":"public/2016/04/27/20160427-关于女权/index.html","hash":"8206fb2457ad3d7c496e1dcf687b534d9149fa2f","modified":1576731967843},{"_id":"public/index.html","hash":"b72afe80431de16d98274f073ec2464958af713d","modified":1576731967843},{"_id":"public/page/2/index.html","hash":"33d0e95e2b30007797726308d76c7fc8af99d755","modified":1576731967843},{"_id":"public/page/4/index.html","hash":"8c52089ef4f0c94d8c55c872512d67d69e34db60","modified":1576731967843},{"_id":"public/page/3/index.html","hash":"8b29896d7f4d1a83ae83419fe6bc2897885b8174","modified":1576731967843},{"_id":"public/CNAME","hash":"3b6b1716d2150e97e4c2c3731340b43e7287d264","modified":1576671411750},{"_id":"public/apple-touch-icon.png","hash":"241d753379c445a9a231f705bb3bfdb602c7e8fd","modified":1576671411750},{"_id":"public/favicon.ico","hash":"29b26120d2c5d0b2311a0b4aea2f8dd10438b9e2","modified":1576671411750},{"_id":"public/file/ClientDemo.java","hash":"909ec92eabdaddbab4e07b5361a8c5529cbfad04","modified":1576671411750},{"_id":"public/file/ServerDemo.java","hash":"7869dbab305418a1cd3ed69c56730f35551b2211","modified":1576671411750},{"_id":"public/image/ByteBuffer.png","hash":"aa3a3bb217266149b80d2de6fea28bdb556829cf","modified":1576671411750},{"_id":"public/image/bytebuffer指针.png","hash":"000a8cf8cc74075d8e1d9f473e892c641a8d7bd5","modified":1576671411750},{"_id":"public/image/ByteBufAllocator体系.png","hash":"d31e6d986611da2dbbd258a99af3b80849cd6c6e","modified":1576671411750},{"_id":"public/image/jvm虚拟内存地址.png","hash":"b1c91364cae12d77b3dc972126d29baedae4606e","modified":1576671411750},{"_id":"public/img/BTCQR.png","hash":"7d1c80f953bfb6f0a37d432b04c936ea165bfd97","modified":1576671411750},{"_id":"public/img/github.svg","hash":"90ba9a3b0dc19e70e742a39b014194f801e00f97","modified":1576671411750},{"_id":"public/img/AliPayQR.png","hash":"7787b5d91cbf0e19a1260df24f7d949771c7d45b","modified":1576671411750},{"_id":"public/img/alipay.svg","hash":"46cc0552a9f6d700d618db3fcad25e1b8e697e36","modified":1576671411750},{"_id":"public/img/bitcoin.svg","hash":"635f7cca5e675d192be2717788175c7a2146013a","modified":1576671411750},{"_id":"public/img/paypal.svg","hash":"92f3bc495f20a0190d3041be03345c46d6238c25","modified":1576671411750},{"_id":"public/img/wechat.svg","hash":"330496ad42446a29f37a2b97fc388ebd77a8cb9f","modified":1576671411750},{"_id":"public/img/WeChatQR.png","hash":"8c41aca7883e5ff714c56556f5fff8e7e7c38093","modified":1576671411750},{"_id":"public/img/like.svg","hash":"22a2754dc454d7b0321b70914fb2936b8d2ea8ab","modified":1576671411750},{"_id":"public/file/kqueue.pdf","hash":"8a342a6d29e50a7d07db8b11e60b6df17bc51b26","modified":1576671411750},{"_id":"public/image/AnnotationConfigServletWebServerApplicationContext.png","hash":"7356b024cfa640cf922fcfbaa1a384843dbf95f2","modified":1576671411750},{"_id":"public/image/DefaultListableBeanFactory.png","hash":"1dfa6281ffbe85c9801ad822a788def47537ba09","modified":1576671411750},{"_id":"public/image/Channel体系.png","hash":"91f758555e7e373e9287fb6540a1cd78f879a705","modified":1576671411750},{"_id":"public/image/EventLoop家族.png","hash":"d288ace904b19a841c797403f570ed51aad5ebc8","modified":1576671411750},{"_id":"public/css/donate.css","hash":"f019876946aeb80e567ece250d54c1327c794583","modified":1576671411750},{"_id":"public/js/donate.js","hash":"89f0b9d9d0c4fce183161d29c2a44aef750efb27","modified":1576671411750},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1576671411750},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1576671411750},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1576671411750},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1576671411750},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1576671411750},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1576671411750},{"_id":"public/donate/index.html","hash":"206384db356d6eb496c206287b86e716981f365c","modified":1576671411750},{"_id":"public/css/default.css","hash":"7fbb18b73b44ed11193739c55fce53a6f173cf68","modified":1576671411750},{"_id":"public/js/gitment.browser.js","hash":"376446d9c5930576016f97dd63e5e6616c94d8d4","modified":1576671411750},{"_id":"public/image/ByteBuf体系.png","hash":"87ccd21af561f35dfc14d43602709a0c3a546983","modified":1576671411750},{"_id":"public/css/style.css","hash":"52441e0bf7363399a4c13cffc84de875028b1b54","modified":1576671411750},{"_id":"public/image/jstack.png-50pencent","hash":"2d2f9decb2aedcf28682b87cef32068e9b0c18ac","modified":1576671411750},{"_id":"public/image/WX20190615-111406.png","hash":"c8eb825d9a1676c3daf269b408de2672c5105d17","modified":1576671411750}],"Category":[{"name":"java并发编程","_id":"ck4b9g7rn00034ejdg28h5vkp"},{"name":"函数编程","_id":"ck4b9g7rr00084ejd6k1xa6cn"},{"name":"Spring源码分析","_id":"ck4b9g7ru000d4ejd3ryg6nzx"},{"name":"小文","_id":"ck4b9g7rw000i4ejd0ycy7akl"},{"name":"MySQL","_id":"ck4b9g7rz000n4ejddchu9hhw"},{"name":"Java","_id":"ck4b9g7s8000x4ejdawsyaeyy"},{"name":"设计模式","_id":"ck4b9g7sb00134ejda56j6scr"},{"name":"小诗","_id":"ck4b9g7sd00184ejd3t8gcgq9"},{"name":"集合框架","_id":"ck4b9g7t2002s4ejd30bwfm7a"},{"name":"Linux","_id":"ck4b9g7tb003l4ejd79eseq5z"},{"name":"开源框架","_id":"ck4b9g7tc003s4ejd72l59sk9"},{"name":"Netty","_id":"ck4b9g7td003y4ejd0pozaaq5"},{"name":"rpc框架","_id":"ck4b9g7te00444ejdblks35ii"},{"name":"java网络编程","_id":"ck4b9g7ti004d4ejdez0k4uyq"}],"Data":[],"Page":[{"title":"关于我的屁事","date":"2016-04-29T18:35:55.000Z","_content":"\n- 14年入行\n- 坐标：广州 (深圳、杭州)\n- QQ：740762239\n- 邮箱：740762239@qq.com\n- 单位：妖都某p互金公司\n\n- 博客更新计划：\n  - Dubbo源码分析\n    - Protocol\n    - Cluster\n    - Dispatcher\n  - Spirng源码分析\n    - ApplicationContext体系\n    - ~~BeanFactory体系~~\n    - BeanFactory生命周期\n    - FactoryBean，配置向的Bean\n    - Spring拓展与集成自定义框架指南\n  - 线程\n    - 自旋优化\n    - 温旧-内存模型\n  - SOFA相关\n","source":"about/index.md","raw":"---\ntitle: 关于我的屁事\ndate: 2016-04-30 02:35:55\n---\n\n- 14年入行\n- 坐标：广州 (深圳、杭州)\n- QQ：740762239\n- 邮箱：740762239@qq.com\n- 单位：妖都某p互金公司\n\n- 博客更新计划：\n  - Dubbo源码分析\n    - Protocol\n    - Cluster\n    - Dispatcher\n  - Spirng源码分析\n    - ApplicationContext体系\n    - ~~BeanFactory体系~~\n    - BeanFactory生命周期\n    - FactoryBean，配置向的Bean\n    - Spring拓展与集成自定义框架指南\n  - 线程\n    - 自旋优化\n    - 温旧-内存模型\n  - SOFA相关\n","updated":"2019-01-16T16:36:26.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck4b9g7rk00014ejdbe6fdqkv","content":"<ul>\n<li><p>14年入行</p>\n</li>\n<li><p>坐标：广州 (深圳、杭州)</p>\n</li>\n<li><p>QQ：740762239</p>\n</li>\n<li><p>邮箱：<a href=\"mailto:740762239@qq.com\">740762239@qq.com</a></p>\n</li>\n<li><p>单位：妖都某p互金公司</p>\n</li>\n<li><p>博客更新计划：</p>\n<ul>\n<li>Dubbo源码分析<ul>\n<li>Protocol</li>\n<li>Cluster</li>\n<li>Dispatcher</li>\n</ul>\n</li>\n<li>Spirng源码分析<ul>\n<li>ApplicationContext体系</li>\n<li><del>BeanFactory体系</del></li>\n<li>BeanFactory生命周期</li>\n<li>FactoryBean，配置向的Bean</li>\n<li>Spring拓展与集成自定义框架指南</li>\n</ul>\n</li>\n<li>线程<ul>\n<li>自旋优化</li>\n<li>温旧-内存模型</li>\n</ul>\n</li>\n<li>SOFA相关</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>14年入行</p>\n</li>\n<li><p>坐标：广州 (深圳、杭州)</p>\n</li>\n<li><p>QQ：740762239</p>\n</li>\n<li><p>邮箱：<a href=\"mailto:740762239@qq.com\">740762239@qq.com</a></p>\n</li>\n<li><p>单位：妖都某p互金公司</p>\n</li>\n<li><p>博客更新计划：</p>\n<ul>\n<li>Dubbo源码分析<ul>\n<li>Protocol</li>\n<li>Cluster</li>\n<li>Dispatcher</li>\n</ul>\n</li>\n<li>Spirng源码分析<ul>\n<li>ApplicationContext体系</li>\n<li><del>BeanFactory体系</del></li>\n<li>BeanFactory生命周期</li>\n<li>FactoryBean，配置向的Bean</li>\n<li>Spring拓展与集成自定义框架指南</li>\n</ul>\n</li>\n<li>线程<ul>\n<li>自旋优化</li>\n<li>温旧-内存模型</li>\n</ul>\n</li>\n<li>SOFA相关</li>\n</ul>\n</li>\n</ul>\n"}],"Post":[{"title":"【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（二）","date":"2018-03-11T05:17:20.000Z","_content":"\n sss\n\n---\n\n``` java\npublic class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {\n  private final ReentrantReadWriteLock.ReadLock readerLock;\n  private final ReentrantReadWriteLock.WriteLock writerLock;\n  final Sync sync;\n  public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }\n  public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }\n}\n```\n\n``` java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n  static final int SHARED_SHIFT   = 16;\n  static final int SHARED_UNIT    = (1 << SHARED_SHIFT);\n  static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\n  static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n  static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }\n  static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\n\n  private transient ThreadLocalHoldCounter readHolds;\n  private transient HoldCounter cachedHoldCounter;\n  private transient Thread firstReader;\n  private transient int firstReaderHoldCount;\n}\n```\nsss\n``` java\nprotected final int tryAcquireShared(int unused) {\n  Thread current = Thread.currentThread();\n  int c = getState();\n  if (exclusiveCount(c) != 0 &&\n    getExclusiveOwnerThread() != current)\n    return -1;\n  int r = sharedCount(c);\n  if (!readerShouldBlock() &&\n    r < MAX_COUNT &&\n    compareAndSetState(c, c + SHARED_UNIT)) {\n    if (r == 0) {\n      firstReader = current;\n      firstReaderHoldCount = 1;\n    } else if (firstReader == current) {\n      firstReaderHoldCount++;\n    } else {\n      HoldCounter rh = cachedHoldCounter;\n      if (rh == null || rh.tid != getThreadId(current))\n        cachedHoldCounter = rh = readHolds.get();\n      else if (rh.count == 0)\n        readHolds.set(rh);\n      rh.count++;\n    }\n    return 1;\n  }\n  return fullTryAcquireShared(current);\n}\n```\n\nddd\n``` java\nfinal int fullTryAcquireShared(Thread current) {\n  /*\n   * This code is in part redundant with that in\n   * tryAcquireShared but is simpler overall by not\n   * complicating tryAcquireShared with interactions between\n   * retries and lazily reading hold counts.\n   */\n  HoldCounter rh = null;\n  for (;;) {\n    int c = getState();\n    if (exclusiveCount(c) != 0) {\n      if (getExclusiveOwnerThread() != current)\n        return -1;\n      // else we hold the exclusive lock; blocking here\n      // would cause deadlock.\n    } else if (readerShouldBlock()) {\n      // Make sure we're not acquiring read lock reentrantly\n      if (firstReader == current) {\n          // assert firstReaderHoldCount > 0;\n      } else {\n        if (rh == null) {\n          rh = cachedHoldCounter;\n          if (rh == null || rh.tid != getThreadId(current)) {\n            rh = readHolds.get();\n            if (rh.count == 0)\n              readHolds.remove();\n          }\n        }\n        if (rh.count == 0)\n          return -1;\n      }\n    }\n    if (sharedCount(c) == MAX_COUNT)\n      throw new Error(\"Maximum lock count exceeded\");\n    if (compareAndSetState(c, c + SHARED_UNIT)) {\n      if (sharedCount(c) == 0) {\n        firstReader = current;\n        firstReaderHoldCount = 1;\n      } else if (firstReader == current) {\n        firstReaderHoldCount++;\n      } else {\n        if (rh == null)\n          rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current))\n          rh = readHolds.get();\n        else if (rh.count == 0)\n          readHolds.set(rh);\n        rh.count++;\n        cachedHoldCounter = rh; // cache for release\n      }\n      return 1;\n    }\n  }\n}\n```\n\nsss\n``` java\nstatic final class NonfairSync extends Sync {\n  private static final long serialVersionUID = -8159625535654395037L;\n  final boolean writerShouldBlock() {\n    return false;\n  }\n  final boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n  }\n}\nstatic final class FairSync extends Sync {\n  private static final long serialVersionUID = -2274990926593161451L;\n  final boolean writerShouldBlock() {\n    return hasQueuedPredecessors();\n  }\n  final boolean readerShouldBlock() {\n    return hasQueuedPredecessors();\n  }\n}\n```\n","source":"_drafts/20180311-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（二）.md","raw":"---\ntitle: 【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（二）\ndate: 2018-03-11 13:17:20\ntags:\n  - java　\n  - 并发编程\n  - 同步\n  - 公平锁\n  - 非公平锁\n  - 可重入锁\n  - 读写锁\n  - 共享锁\n  - 独占锁\n  - ReentrantReadWriteLock\ncategories:\n  - java并发编程\n---\n\n sss\n\n---\n\n``` java\npublic class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable {\n  private final ReentrantReadWriteLock.ReadLock readerLock;\n  private final ReentrantReadWriteLock.WriteLock writerLock;\n  final Sync sync;\n  public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }\n  public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }\n}\n```\n\n``` java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n  static final int SHARED_SHIFT   = 16;\n  static final int SHARED_UNIT    = (1 << SHARED_SHIFT);\n  static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\n  static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n  static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }\n  static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\n\n  private transient ThreadLocalHoldCounter readHolds;\n  private transient HoldCounter cachedHoldCounter;\n  private transient Thread firstReader;\n  private transient int firstReaderHoldCount;\n}\n```\nsss\n``` java\nprotected final int tryAcquireShared(int unused) {\n  Thread current = Thread.currentThread();\n  int c = getState();\n  if (exclusiveCount(c) != 0 &&\n    getExclusiveOwnerThread() != current)\n    return -1;\n  int r = sharedCount(c);\n  if (!readerShouldBlock() &&\n    r < MAX_COUNT &&\n    compareAndSetState(c, c + SHARED_UNIT)) {\n    if (r == 0) {\n      firstReader = current;\n      firstReaderHoldCount = 1;\n    } else if (firstReader == current) {\n      firstReaderHoldCount++;\n    } else {\n      HoldCounter rh = cachedHoldCounter;\n      if (rh == null || rh.tid != getThreadId(current))\n        cachedHoldCounter = rh = readHolds.get();\n      else if (rh.count == 0)\n        readHolds.set(rh);\n      rh.count++;\n    }\n    return 1;\n  }\n  return fullTryAcquireShared(current);\n}\n```\n\nddd\n``` java\nfinal int fullTryAcquireShared(Thread current) {\n  /*\n   * This code is in part redundant with that in\n   * tryAcquireShared but is simpler overall by not\n   * complicating tryAcquireShared with interactions between\n   * retries and lazily reading hold counts.\n   */\n  HoldCounter rh = null;\n  for (;;) {\n    int c = getState();\n    if (exclusiveCount(c) != 0) {\n      if (getExclusiveOwnerThread() != current)\n        return -1;\n      // else we hold the exclusive lock; blocking here\n      // would cause deadlock.\n    } else if (readerShouldBlock()) {\n      // Make sure we're not acquiring read lock reentrantly\n      if (firstReader == current) {\n          // assert firstReaderHoldCount > 0;\n      } else {\n        if (rh == null) {\n          rh = cachedHoldCounter;\n          if (rh == null || rh.tid != getThreadId(current)) {\n            rh = readHolds.get();\n            if (rh.count == 0)\n              readHolds.remove();\n          }\n        }\n        if (rh.count == 0)\n          return -1;\n      }\n    }\n    if (sharedCount(c) == MAX_COUNT)\n      throw new Error(\"Maximum lock count exceeded\");\n    if (compareAndSetState(c, c + SHARED_UNIT)) {\n      if (sharedCount(c) == 0) {\n        firstReader = current;\n        firstReaderHoldCount = 1;\n      } else if (firstReader == current) {\n        firstReaderHoldCount++;\n      } else {\n        if (rh == null)\n          rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current))\n          rh = readHolds.get();\n        else if (rh.count == 0)\n          readHolds.set(rh);\n        rh.count++;\n        cachedHoldCounter = rh; // cache for release\n      }\n      return 1;\n    }\n  }\n}\n```\n\nsss\n``` java\nstatic final class NonfairSync extends Sync {\n  private static final long serialVersionUID = -8159625535654395037L;\n  final boolean writerShouldBlock() {\n    return false;\n  }\n  final boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n  }\n}\nstatic final class FairSync extends Sync {\n  private static final long serialVersionUID = -2274990926593161451L;\n  final boolean writerShouldBlock() {\n    return hasQueuedPredecessors();\n  }\n  final boolean readerShouldBlock() {\n    return hasQueuedPredecessors();\n  }\n}\n```\n","slug":"20180311-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（二）","published":0,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7re00004ejdcdfdgc22","content":"<p> sss</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">ReadWriteLock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">WriteLock <span class=\"title\">writeLock</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> writerLock; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">ReadLock  <span class=\"title\">readLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> readerLock; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARED_SHIFT   = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARED_UNIT    = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_COUNT      = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT) - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCLUSIVE_MASK = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT) - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sharedCount</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>    </span>&#123; <span class=\"keyword\">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">exclusiveCount</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123; <span class=\"keyword\">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HoldCounter cachedHoldCounter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Thread firstReader;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> firstReaderHoldCount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sss</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">  Thread current = Thread.currentThread();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">    getExclusiveOwnerThread() != current)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r = sharedCount(c);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class=\"line\">    r &lt; MAX_COUNT &amp;&amp;</span><br><span class=\"line\">    compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      firstReader = current;</span><br><span class=\"line\">      firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">      firstReaderHoldCount++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      HoldCounter rh = cachedHoldCounter;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">        cachedHoldCounter = rh = readHolds.get();</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">        readHolds.set(rh);</span><br><span class=\"line\">      rh.count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fullTryAcquireShared(current);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ddd</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullTryAcquireShared</span><span class=\"params\">(Thread current)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * This code is in part redundant with that in</span></span><br><span class=\"line\"><span class=\"comment\">   * tryAcquireShared but is simpler overall by not</span></span><br><span class=\"line\"><span class=\"comment\">   * complicating tryAcquireShared with interactions between</span></span><br><span class=\"line\"><span class=\"comment\">   * retries and lazily reading hold counts.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  HoldCounter rh = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getExclusiveOwnerThread() != current)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else we hold the exclusive lock; blocking here</span></span><br><span class=\"line\">      <span class=\"comment\">// would cause deadlock.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readerShouldBlock()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          rh = cachedHoldCounter;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class=\"line\">            rh = readHolds.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">              readHolds.remove();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sharedCount(c) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        firstReader = current;</span><br><span class=\"line\">        firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">        firstReaderHoldCount++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          rh = cachedHoldCounter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">          rh = readHolds.get();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          readHolds.set(rh);</span><br><span class=\"line\">        rh.count++;</span><br><span class=\"line\">        cachedHoldCounter = rh; <span class=\"comment\">// cache for release</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sss</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">8159625535654395037L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2274990926593161451L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasQueuedPredecessors();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasQueuedPredecessors();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p> sss</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">ReadWriteLock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">WriteLock <span class=\"title\">writeLock</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> writerLock; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> ReentrantReadWriteLock.<span class=\"function\">ReadLock  <span class=\"title\">readLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> readerLock; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARED_SHIFT   = <span class=\"number\">16</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHARED_UNIT    = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_COUNT      = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT) - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCLUSIVE_MASK = (<span class=\"number\">1</span> &lt;&lt; SHARED_SHIFT) - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sharedCount</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>    </span>&#123; <span class=\"keyword\">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">exclusiveCount</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123; <span class=\"keyword\">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HoldCounter cachedHoldCounter;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Thread firstReader;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> firstReaderHoldCount;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sss</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">  Thread current = Thread.currentThread();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">    getExclusiveOwnerThread() != current)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> r = sharedCount(c);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class=\"line\">    r &lt; MAX_COUNT &amp;&amp;</span><br><span class=\"line\">    compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      firstReader = current;</span><br><span class=\"line\">      firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">      firstReaderHoldCount++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      HoldCounter rh = cachedHoldCounter;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">        cachedHoldCounter = rh = readHolds.get();</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">        readHolds.set(rh);</span><br><span class=\"line\">      rh.count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fullTryAcquireShared(current);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ddd</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullTryAcquireShared</span><span class=\"params\">(Thread current)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * This code is in part redundant with that in</span></span><br><span class=\"line\"><span class=\"comment\">   * tryAcquireShared but is simpler overall by not</span></span><br><span class=\"line\"><span class=\"comment\">   * complicating tryAcquireShared with interactions between</span></span><br><span class=\"line\"><span class=\"comment\">   * retries and lazily reading hold counts.</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  HoldCounter rh = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getExclusiveOwnerThread() != current)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"comment\">// else we hold the exclusive lock; blocking here</span></span><br><span class=\"line\">      <span class=\"comment\">// would cause deadlock.</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (readerShouldBlock()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          rh = cachedHoldCounter;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class=\"line\">            rh = readHolds.get();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">              readHolds.remove();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sharedCount(c) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        firstReader = current;</span><br><span class=\"line\">        firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">        firstReaderHoldCount++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          rh = cachedHoldCounter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">          rh = readHolds.get();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          readHolds.set(rh);</span><br><span class=\"line\">        rh.count++;</span><br><span class=\"line\">        cachedHoldCounter = rh; <span class=\"comment\">// cache for release</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>sss</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">8159625535654395037L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">2274990926593161451L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasQueuedPredecessors();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasQueuedPredecessors();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"20170129-初学Clojure—与Java相互调用","date":"2017-01-29T15:27:08.000Z","_content":"","source":"_drafts/20170129-初学Clojure—与Java相互调用.md","raw":"---\ntitle: 20170129-初学Clojure—与Java相互调用\ndate: 2017-01-29 23:27:08\ntags:\n---\n","slug":"20170129-初学Clojure—与Java相互调用","published":0,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rm00024ejdcg8t7nks","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"20170222-初学Clojure—宏！","date":"2017-02-22T14:18:33.000Z","_content":"","source":"_drafts/20170222-初学Clojure—宏！.md","raw":"---\ntitle: 20170222-初学Clojure—宏！\ndate: 2017-02-22 22:18:33\ntags:\n  - clojure\n  - 教程\n  - 并发编程语言\ncategories:\n  - 函数编程\n---\n","slug":"20170222-初学Clojure—宏！","published":0,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7ro00054ejd2pz68h38","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"【Spring源码分析】BeanFactory的生命周期","date":"2018-11-26T03:08:40.000Z","_content":"\n---\n\n两级别生命周期：\n  - 容器级别 \n    - BeanFactoryPostProcessor\n    - BeanDefinitionRegistryPostProcessor\n    - 调用实现逻辑\n      PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors\n  - Bean级别\n\n- InstantiationAwareBeanPostProcessor\n\n  - postProcessBeforeInstantiation\n\n  - postProcessAfterInstantiation\n\n  - postProcessProperties\n","source":"_drafts/20181126-【Spring源码分析】BeanFactory的生命周期.md","raw":"---\ntitle: 【Spring源码分析】BeanFactory的生命周期\ndate: 2018-11-26 11:08:40\ntags:\n  - java　\n  - Spring\n  - AOP\n  - IOC控制反转\n  - BeanFactory\n  - BeanFactory生命周期\ncategories:\n    - Spring源码分析\n---\n\n---\n\n两级别生命周期：\n  - 容器级别 \n    - BeanFactoryPostProcessor\n    - BeanDefinitionRegistryPostProcessor\n    - 调用实现逻辑\n      PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors\n  - Bean级别\n\n- InstantiationAwareBeanPostProcessor\n\n  - postProcessBeforeInstantiation\n\n  - postProcessAfterInstantiation\n\n  - postProcessProperties\n","slug":"20181126-【Spring源码分析】BeanFactory的生命周期","published":0,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rp00064ejd5m314d1q","content":"<hr>\n<p>两级别生命周期：</p>\n<ul>\n<li>容器级别 <ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanDefinitionRegistryPostProcessor</li>\n<li>调用实现逻辑<br>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</li>\n</ul>\n</li>\n<li>Bean级别</li>\n</ul>\n<ul>\n<li><p>InstantiationAwareBeanPostProcessor</p>\n<ul>\n<li><p>postProcessBeforeInstantiation</p>\n</li>\n<li><p>postProcessAfterInstantiation</p>\n</li>\n<li><p>postProcessProperties</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>两级别生命周期：</p>\n<ul>\n<li>容器级别 <ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanDefinitionRegistryPostProcessor</li>\n<li>调用实现逻辑<br>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors</li>\n</ul>\n</li>\n<li>Bean级别</li>\n</ul>\n<ul>\n<li><p>InstantiationAwareBeanPostProcessor</p>\n<ul>\n<li><p>postProcessBeforeInstantiation</p>\n</li>\n<li><p>postProcessAfterInstantiation</p>\n</li>\n<li><p>postProcessProperties</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"date":"2016-04-27T14:47:04.000Z","title":"关于女权","_content":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。\n\n## 正文\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文明正在进步，社会对待女性也有了更多的尊重，继而有了礼让女性的“男士风度”、男士退让的“女士优先”等道德礼仪观念。“风度”和“优先”看起来似乎比“平等”、“女权”微观得多，同时也容易实践于生活当中。可两者间好像隔着什么东西？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔着矛盾！\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“男士风度”是礼让于地位，“女士优先”是退让于机会，也就是说，女性需要“风度”来体现地位、“优先”来获得机会。既然宣传追求“平等”、“女权”，女性需要用“让”来获取地位或机会么？或者说，“平等”、“女权”二者同“让”并不该共存，甚至是对立的。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使如此，我们可抛开“男女平等”、“女权主义”等安利人的字眼不讲，把“风度”和“优先”作为道德礼仪也并不成立，或者说不能作为一种要求，下面如果我们把道德与礼仪统一归为道德的话。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成之无罪，“万物都以永恒之泉水受礼，超于善恶之外，善恶不过是掠影，是阴翳，是流云。”这句话出自尼采的《查拉图斯特拉如是说》，意思是，万物生命本身无罪，且并不遵循道规律，立足于善恶之外。道德礼仪不是“自在之物”，“不存在凭自身成为道德的道德”，一切行为都是出自更深层的动机或需求，并非出于道德，道德只不过是对你某种行为的一种错解。简而言之，一个人对另一个人做出符合“道德”的行为，无非是出自动机而做；反之，不存在动机，就不存在道不道德的行为。回到前面说的“风度”、“优先”，我们业已把它们看作一种道德礼仪观念，自然符合上述：这么说，女性何必要求男性对她产生动机呢？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若道德礼仪是纯粹的，“风度”与“优先”也有悖于其出发点。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的“让”，我们不妨看作同情的行为结果。每个人无论男女都是个体，都有成为强者的可能或意愿。我们视女性为同等，都渴望成为强者，都渴望获得地位、权利。此时，我们却因为女性的一时劣势，我们投以同情的眼光，这无疑给这些渴望变强的人儿的尊严一棍强击。是的，同情与自尊是对立的。那些成天把二者挂在嘴边的女性，只不过是些毫无尊严、只愿做男性依附品的奴性个体罢了。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，鄙夷了所谓“男士风度”、“女士优先”等虚伪观念，那究竟与现今所宣的“男女平等”、“女权主义”有何关？有！我觉得有关！拆楼重建总比危楼修补来得容易，颠覆腾空旧观念再宣新思想不是更好么？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚然，颠覆过去、思考现在、重估未来是当今社会问题最好的解决办法，可惜说起容易做来难。","source":"_posts/20160427-关于女权.md","raw":"---\ndate: 2016-04-27 22:47:04\ncategories: \n- 小文\ntitle: 关于女权\n---\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。\n\n## 正文\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文明正在进步，社会对待女性也有了更多的尊重，继而有了礼让女性的“男士风度”、男士退让的“女士优先”等道德礼仪观念。“风度”和“优先”看起来似乎比“平等”、“女权”微观得多，同时也容易实践于生活当中。可两者间好像隔着什么东西？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔着矛盾！\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“男士风度”是礼让于地位，“女士优先”是退让于机会，也就是说，女性需要“风度”来体现地位、“优先”来获得机会。既然宣传追求“平等”、“女权”，女性需要用“让”来获取地位或机会么？或者说，“平等”、“女权”二者同“让”并不该共存，甚至是对立的。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使如此，我们可抛开“男女平等”、“女权主义”等安利人的字眼不讲，把“风度”和“优先”作为道德礼仪也并不成立，或者说不能作为一种要求，下面如果我们把道德与礼仪统一归为道德的话。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成之无罪，“万物都以永恒之泉水受礼，超于善恶之外，善恶不过是掠影，是阴翳，是流云。”这句话出自尼采的《查拉图斯特拉如是说》，意思是，万物生命本身无罪，且并不遵循道规律，立足于善恶之外。道德礼仪不是“自在之物”，“不存在凭自身成为道德的道德”，一切行为都是出自更深层的动机或需求，并非出于道德，道德只不过是对你某种行为的一种错解。简而言之，一个人对另一个人做出符合“道德”的行为，无非是出自动机而做；反之，不存在动机，就不存在道不道德的行为。回到前面说的“风度”、“优先”，我们业已把它们看作一种道德礼仪观念，自然符合上述：这么说，女性何必要求男性对她产生动机呢？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若道德礼仪是纯粹的，“风度”与“优先”也有悖于其出发点。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的“让”，我们不妨看作同情的行为结果。每个人无论男女都是个体，都有成为强者的可能或意愿。我们视女性为同等，都渴望成为强者，都渴望获得地位、权利。此时，我们却因为女性的一时劣势，我们投以同情的眼光，这无疑给这些渴望变强的人儿的尊严一棍强击。是的，同情与自尊是对立的。那些成天把二者挂在嘴边的女性，只不过是些毫无尊严、只愿做男性依附品的奴性个体罢了。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，鄙夷了所谓“男士风度”、“女士优先”等虚伪观念，那究竟与现今所宣的“男女平等”、“女权主义”有何关？有！我觉得有关！拆楼重建总比危楼修补来得容易，颠覆腾空旧观念再宣新思想不是更好么？\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚然，颠覆过去、思考现在、重估未来是当今社会问题最好的解决办法，可惜说起容易做来难。","slug":"20160427-关于女权","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rq00074ejd9ystar7w","content":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文明正在进步，社会对待女性也有了更多的尊重，继而有了礼让女性的“男士风度”、男士退让的“女士优先”等道德礼仪观念。“风度”和“优先”看起来似乎比“平等”、“女权”微观得多，同时也容易实践于生活当中。可两者间好像隔着什么东西？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔着矛盾！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“男士风度”是礼让于地位，“女士优先”是退让于机会，也就是说，女性需要“风度”来体现地位、“优先”来获得机会。既然宣传追求“平等”、“女权”，女性需要用“让”来获取地位或机会么？或者说，“平等”、“女权”二者同“让”并不该共存，甚至是对立的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使如此，我们可抛开“男女平等”、“女权主义”等安利人的字眼不讲，把“风度”和“优先”作为道德礼仪也并不成立，或者说不能作为一种要求，下面如果我们把道德与礼仪统一归为道德的话。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成之无罪，“万物都以永恒之泉水受礼，超于善恶之外，善恶不过是掠影，是阴翳，是流云。”这句话出自尼采的《查拉图斯特拉如是说》，意思是，万物生命本身无罪，且并不遵循道规律，立足于善恶之外。道德礼仪不是“自在之物”，“不存在凭自身成为道德的道德”，一切行为都是出自更深层的动机或需求，并非出于道德，道德只不过是对你某种行为的一种错解。简而言之，一个人对另一个人做出符合“道德”的行为，无非是出自动机而做；反之，不存在动机，就不存在道不道德的行为。回到前面说的“风度”、“优先”，我们业已把它们看作一种道德礼仪观念，自然符合上述：这么说，女性何必要求男性对她产生动机呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若道德礼仪是纯粹的，“风度”与“优先”也有悖于其出发点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的“让”，我们不妨看作同情的行为结果。每个人无论男女都是个体，都有成为强者的可能或意愿。我们视女性为同等，都渴望成为强者，都渴望获得地位、权利。此时，我们却因为女性的一时劣势，我们投以同情的眼光，这无疑给这些渴望变强的人儿的尊严一棍强击。是的，同情与自尊是对立的。那些成天把二者挂在嘴边的女性，只不过是些毫无尊严、只愿做男性依附品的奴性个体罢了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，鄙夷了所谓“男士风度”、“女士优先”等虚伪观念，那究竟与现今所宣的“男女平等”、“女权主义”有何关？有！我觉得有关！拆楼重建总比危楼修补来得容易，颠覆腾空旧观念再宣新思想不是更好么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚然，颠覆过去、思考现在、重估未来是当今社会问题最好的解决办法，可惜说起容易做来难。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如今经济发展，社会进步，人的观念也逐渐步入成熟的平和。然而宏观上步入平和，微观上可就不见得了，仍有不少观念的不平还是一如既往。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近有若干新闻是关于女性的，具体什么新闻在这不再提了，也没必要，千篇一律。新闻一发，立即被引出一片没完没了的“男女平等”、“女权主义”等关于女性的权利和社会地位的嚷嚷声。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;文明正在进步，社会对待女性也有了更多的尊重，继而有了礼让女性的“男士风度”、男士退让的“女士优先”等道德礼仪观念。“风度”和“优先”看起来似乎比“平等”、“女权”微观得多，同时也容易实践于生活当中。可两者间好像隔着什么东西？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔着矛盾！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“男士风度”是礼让于地位，“女士优先”是退让于机会，也就是说，女性需要“风度”来体现地位、“优先”来获得机会。既然宣传追求“平等”、“女权”，女性需要用“让”来获取地位或机会么？或者说，“平等”、“女权”二者同“让”并不该共存，甚至是对立的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使如此，我们可抛开“男女平等”、“女权主义”等安利人的字眼不讲，把“风度”和“优先”作为道德礼仪也并不成立，或者说不能作为一种要求，下面如果我们把道德与礼仪统一归为道德的话。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成之无罪，“万物都以永恒之泉水受礼，超于善恶之外，善恶不过是掠影，是阴翳，是流云。”这句话出自尼采的《查拉图斯特拉如是说》，意思是，万物生命本身无罪，且并不遵循道规律，立足于善恶之外。道德礼仪不是“自在之物”，“不存在凭自身成为道德的道德”，一切行为都是出自更深层的动机或需求，并非出于道德，道德只不过是对你某种行为的一种错解。简而言之，一个人对另一个人做出符合“道德”的行为，无非是出自动机而做；反之，不存在动机，就不存在道不道德的行为。回到前面说的“风度”、“优先”，我们业已把它们看作一种道德礼仪观念，自然符合上述：这么说，女性何必要求男性对她产生动机呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;倘若道德礼仪是纯粹的，“风度”与“优先”也有悖于其出发点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二者的“让”，我们不妨看作同情的行为结果。每个人无论男女都是个体，都有成为强者的可能或意愿。我们视女性为同等，都渴望成为强者，都渴望获得地位、权利。此时，我们却因为女性的一时劣势，我们投以同情的眼光，这无疑给这些渴望变强的人儿的尊严一棍强击。是的，同情与自尊是对立的。那些成天把二者挂在嘴边的女性，只不过是些毫无尊严、只愿做男性依附品的奴性个体罢了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说了这么多，鄙夷了所谓“男士风度”、“女士优先”等虚伪观念，那究竟与现今所宣的“男女平等”、“女权主义”有何关？有！我觉得有关！拆楼重建总比危楼修补来得容易，颠覆腾空旧观念再宣新思想不是更好么？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诚然，颠覆过去、思考现在、重估未来是当今社会问题最好的解决办法，可惜说起容易做来难。</p>\n"},{"title":"【网络编程】Netty的线程池实现-EventLoop家族","date":"2019-01-20T13:09:58.000Z","_content":"","source":"_drafts/【网络编程】Netty的线程池实现-EventLoop家族.md","raw":"---\ntitle: 【网络编程】Netty的线程池实现-EventLoop家族\ndate: 2019-01-20 21:09:58\ntags:\n---\n","slug":"【网络编程】Netty的线程池实现-EventLoop家族","published":0,"updated":"2019-01-20T13:09:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rs000a4ejddply03lu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"MySQL常见命令","date":"2016-04-28T23:48:48.000Z","_content":"一些常用的MySQL命令，个人工作中使用频率高的，既长又易忘。\n\n\n---\n#### 创建数据库：\n\n``` mysql\nmysql> create database if not exists <db_name> \t--- 数据库名称\n\t\t\t\tdefault charset utf8 \t--- 字符编码\n\t\t\t\tcollate utf8_general_ci;\t--- 字符编码集```\n\t\t\t\t\t\t\t\n---\n#### 修改root密码：\n\n``` mysql\nmysql> set password for 'root'@'localhost'=password('newpass');\nmysql> update user set password=password('newpass') where user='root'```\n\n---\n#### 用户权限：\n\n添加并授权新用户：\n``` mysql\nmysql> grant all on testDB.* to test@localhost identified by '1234';\nmysql> grant select,insert,update,delete,execute  \n\ton *.* to qmsys@\"localhost\" Identified by \"qmsys\";```\n\t\n刷新权限：\n```mysql\nmysql> flush privileges;```\n\n查看权限：\n```mysql\nmysql> show grants for '<user_name>'@'%’;```\n\n删除权限：\n```mysql\nmysql> REVOKE ALL PRIVILEGES ON *.* FROM '<user_name>'@'%';```\n\n---\n#### Event调度器：\n\n查看Event：\n``` mysql\nmysql> show events;\nmysql> show create event <name>;```\n\n开启Event：\n``` mysql\nmysql> SET GLOBAL event_scheduler = ON;```\n或在my.cnf的[mysqld]下添加event_scheduler = ON\n\n创建Event：\n``` mysql\ndelimiter|\nCREATE DEFINER='root';@'%' EVENT 'update_reform'\n\tON SCHEDULE EVERY 1 DAY STARTS TIMESTAMP(current_date(), '00:30:00')\n\tON COMPLETION PRESERVE ENABLE DO\nBEGIN\n/*\n *\n */\nEND    \n|delimiter ; ```\n\n---\n#### 常见易忘函数：\n\n时间加减：\n``` mysql\nmysql> date_add(tc.check_time, interval 3 month);\n```\nday、hour、minute、second、microsecond、week、quarter、year\n\n---\n#### 导出数据库：\n\n指定数据库全量导出：\n``` mysql\nmysql> mysqldump -u root --password=<password> --events -R <db_name> > /root/<db_name>.$(date '+%Y%m%d').sql --lock-tables=false\n```","source":"_posts/20160429-MySQ常见命令.md","raw":"---\ntitle: MySQL常见命令\ndate: 2016-04-29 07:48:48\ncategories: \n- MySQL\ntags: mysql\n---\n一些常用的MySQL命令，个人工作中使用频率高的，既长又易忘。\n\n\n---\n#### 创建数据库：\n\n``` mysql\nmysql> create database if not exists <db_name> \t--- 数据库名称\n\t\t\t\tdefault charset utf8 \t--- 字符编码\n\t\t\t\tcollate utf8_general_ci;\t--- 字符编码集```\n\t\t\t\t\t\t\t\n---\n#### 修改root密码：\n\n``` mysql\nmysql> set password for 'root'@'localhost'=password('newpass');\nmysql> update user set password=password('newpass') where user='root'```\n\n---\n#### 用户权限：\n\n添加并授权新用户：\n``` mysql\nmysql> grant all on testDB.* to test@localhost identified by '1234';\nmysql> grant select,insert,update,delete,execute  \n\ton *.* to qmsys@\"localhost\" Identified by \"qmsys\";```\n\t\n刷新权限：\n```mysql\nmysql> flush privileges;```\n\n查看权限：\n```mysql\nmysql> show grants for '<user_name>'@'%’;```\n\n删除权限：\n```mysql\nmysql> REVOKE ALL PRIVILEGES ON *.* FROM '<user_name>'@'%';```\n\n---\n#### Event调度器：\n\n查看Event：\n``` mysql\nmysql> show events;\nmysql> show create event <name>;```\n\n开启Event：\n``` mysql\nmysql> SET GLOBAL event_scheduler = ON;```\n或在my.cnf的[mysqld]下添加event_scheduler = ON\n\n创建Event：\n``` mysql\ndelimiter|\nCREATE DEFINER='root';@'%' EVENT 'update_reform'\n\tON SCHEDULE EVERY 1 DAY STARTS TIMESTAMP(current_date(), '00:30:00')\n\tON COMPLETION PRESERVE ENABLE DO\nBEGIN\n/*\n *\n */\nEND    \n|delimiter ; ```\n\n---\n#### 常见易忘函数：\n\n时间加减：\n``` mysql\nmysql> date_add(tc.check_time, interval 3 month);\n```\nday、hour、minute、second、microsecond、week、quarter、year\n\n---\n#### 导出数据库：\n\n指定数据库全量导出：\n``` mysql\nmysql> mysqldump -u root --password=<password> --events -R <db_name> > /root/<db_name>.$(date '+%Y%m%d').sql --lock-tables=false\n```","slug":"20160429-MySQ常见命令","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rt000b4ejdepuh7wwk","content":"<p>一些常用的MySQL命令，个人工作中使用频率高的，既长又易忘。</p>\n<hr>\n<h4 id=\"创建数据库：\"><a href=\"#创建数据库：\" class=\"headerlink\" title=\"创建数据库：\"></a>创建数据库：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create database if not exists &lt;db_name&gt; \t--- 数据库名称</span><br><span class=\"line\">\t\t\t\tdefault charset utf8 \t--- 字符编码</span><br><span class=\"line\">\t\t\t\tcollate utf8_general_ci;\t--- 字符编码集</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"修改root密码：\"><a href=\"#修改root密码：\" class=\"headerlink\" title=\"修改root密码：\"></a>修改root密码：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;newpass&#39;);</span><br><span class=\"line\">mysql&gt; update user set password&#x3D;password(&#39;newpass&#39;) where user&#x3D;&#39;root&#39;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"用户权限：\"><a href=\"#用户权限：\" class=\"headerlink\" title=\"用户权限：\"></a>用户权限：</h4><p>添加并授权新用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; grant all on testDB.* to test@localhost identified by &#39;1234&#39;;</span><br><span class=\"line\">mysql&gt; grant select,insert,update,delete,execute  </span><br><span class=\"line\">\ton *.* to qmsys@&quot;localhost&quot; Identified by &quot;qmsys&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>刷新权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>\n\n<p>查看权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show grants for &#39;&lt;user_name&gt;&#39;@&#39;%’;</span><br></pre></td></tr></table></figure>\n\n<p>删除权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; REVOKE ALL PRIVILEGES ON *.* FROM &#39;&lt;user_name&gt;&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Event调度器：\"><a href=\"#Event调度器：\" class=\"headerlink\" title=\"Event调度器：\"></a>Event调度器：</h4><p>查看Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show events;</span><br><span class=\"line\">mysql&gt; show create event &lt;name&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>开启Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET GLOBAL event_scheduler &#x3D; ON;</span><br></pre></td></tr></table></figure>\n<p>或在my.cnf的[mysqld]下添加event_scheduler = ON</p>\n<p>创建Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delimiter|</span><br><span class=\"line\">CREATE DEFINER&#x3D;&#39;root&#39;;@&#39;%&#39; EVENT &#39;update_reform&#39;</span><br><span class=\"line\">\tON SCHEDULE EVERY 1 DAY STARTS TIMESTAMP(current_date(), &#39;00:30:00&#39;)</span><br><span class=\"line\">\tON COMPLETION PRESERVE ENABLE DO</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">END    </span><br><span class=\"line\">|delimiter ;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"常见易忘函数：\"><a href=\"#常见易忘函数：\" class=\"headerlink\" title=\"常见易忘函数：\"></a>常见易忘函数：</h4><p>时间加减：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; date_add(tc.check_time, interval 3 month);</span><br></pre></td></tr></table></figure>\n<p>day、hour、minute、second、microsecond、week、quarter、year</p>\n<hr>\n<h4 id=\"导出数据库：\"><a href=\"#导出数据库：\" class=\"headerlink\" title=\"导出数据库：\"></a>导出数据库：</h4><p>指定数据库全量导出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; mysqldump -u root --password&#x3D;&lt;password&gt; --events -R &lt;db_name&gt; &gt; &#x2F;root&#x2F;&lt;db_name&gt;.$(date &#39;+%Y%m%d&#39;).sql --lock-tables&#x3D;false</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>一些常用的MySQL命令，个人工作中使用频率高的，既长又易忘。</p>\n<hr>\n<h4 id=\"创建数据库：\"><a href=\"#创建数据库：\" class=\"headerlink\" title=\"创建数据库：\"></a>创建数据库：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; create database if not exists &lt;db_name&gt; \t--- 数据库名称</span><br><span class=\"line\">\t\t\t\tdefault charset utf8 \t--- 字符编码</span><br><span class=\"line\">\t\t\t\tcollate utf8_general_ci;\t--- 字符编码集</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"修改root密码：\"><a href=\"#修改root密码：\" class=\"headerlink\" title=\"修改root密码：\"></a>修改root密码：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;&#x3D;password(&#39;newpass&#39;);</span><br><span class=\"line\">mysql&gt; update user set password&#x3D;password(&#39;newpass&#39;) where user&#x3D;&#39;root&#39;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"用户权限：\"><a href=\"#用户权限：\" class=\"headerlink\" title=\"用户权限：\"></a>用户权限：</h4><p>添加并授权新用户：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; grant all on testDB.* to test@localhost identified by &#39;1234&#39;;</span><br><span class=\"line\">mysql&gt; grant select,insert,update,delete,execute  </span><br><span class=\"line\">\ton *.* to qmsys@&quot;localhost&quot; Identified by &quot;qmsys&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>刷新权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>\n\n<p>查看权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show grants for &#39;&lt;user_name&gt;&#39;@&#39;%’;</span><br></pre></td></tr></table></figure>\n\n<p>删除权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; REVOKE ALL PRIVILEGES ON *.* FROM &#39;&lt;user_name&gt;&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"Event调度器：\"><a href=\"#Event调度器：\" class=\"headerlink\" title=\"Event调度器：\"></a>Event调度器：</h4><p>查看Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show events;</span><br><span class=\"line\">mysql&gt; show create event &lt;name&gt;;</span><br></pre></td></tr></table></figure>\n\n<p>开启Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; SET GLOBAL event_scheduler &#x3D; ON;</span><br></pre></td></tr></table></figure>\n<p>或在my.cnf的[mysqld]下添加event_scheduler = ON</p>\n<p>创建Event：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delimiter|</span><br><span class=\"line\">CREATE DEFINER&#x3D;&#39;root&#39;;@&#39;%&#39; EVENT &#39;update_reform&#39;</span><br><span class=\"line\">\tON SCHEDULE EVERY 1 DAY STARTS TIMESTAMP(current_date(), &#39;00:30:00&#39;)</span><br><span class=\"line\">\tON COMPLETION PRESERVE ENABLE DO</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">END    </span><br><span class=\"line\">|delimiter ;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"常见易忘函数：\"><a href=\"#常见易忘函数：\" class=\"headerlink\" title=\"常见易忘函数：\"></a>常见易忘函数：</h4><p>时间加减：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; date_add(tc.check_time, interval 3 month);</span><br></pre></td></tr></table></figure>\n<p>day、hour、minute、second、microsecond、week、quarter、year</p>\n<hr>\n<h4 id=\"导出数据库：\"><a href=\"#导出数据库：\" class=\"headerlink\" title=\"导出数据库：\"></a>导出数据库：</h4><p>指定数据库全量导出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; mysqldump -u root --password&#x3D;&lt;password&gt; --events -R &lt;db_name&gt; &gt; &#x2F;root&#x2F;&lt;db_name&gt;.$(date &#39;+%Y%m%d&#39;).sql --lock-tables&#x3D;false</span><br></pre></td></tr></table></figure>"},{"title":"MySQL5.6安装","date":"2016-04-29T03:23:39.000Z","_content":"只针对mysql5.6，其他版本mysql_install_db步骤可能有所不同.\n\n#### yum安装依赖包\n\n``` bash\n$ yum install gcc-c++\n$ yum install cmake\n$ yum install make\n$ yum install bison.x86_64\n$ yum install ncurses-devel.x86_64\n```\n\n#### 解压并编译mysql\n\n``` bash\n$ tar -xzvf mysql.**.tar.gz\n$ cd /usr/local/mysql\n$ cmake .\n$ make && make install\n```\n\n#### 常见用户组及用户\n\n``` bash\n$ groupadd mysql\n$ useradd -r -g mysql mysql\n```\n\n#### 安装MySQL\n\n``` bash\n$ chmod 777 scripts/mysql_install_db\n$ scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data\n```","source":"_posts/20160429-MySQL5-6安装.md","raw":"---\ntitle: MySQL5.6安装\ndate: 2016-04-29 11:23:39\ncategories: \n- MySQL\ntags: mysql\n---\n只针对mysql5.6，其他版本mysql_install_db步骤可能有所不同.\n\n#### yum安装依赖包\n\n``` bash\n$ yum install gcc-c++\n$ yum install cmake\n$ yum install make\n$ yum install bison.x86_64\n$ yum install ncurses-devel.x86_64\n```\n\n#### 解压并编译mysql\n\n``` bash\n$ tar -xzvf mysql.**.tar.gz\n$ cd /usr/local/mysql\n$ cmake .\n$ make && make install\n```\n\n#### 常见用户组及用户\n\n``` bash\n$ groupadd mysql\n$ useradd -r -g mysql mysql\n```\n\n#### 安装MySQL\n\n``` bash\n$ chmod 777 scripts/mysql_install_db\n$ scripts/mysql_install_db --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data\n```","slug":"20160429-MySQL5-6安装","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7ru000f4ejd5jc4aloh","content":"<p>只针对mysql5.6，其他版本mysql_install_db步骤可能有所不同.</p>\n<h4 id=\"yum安装依赖包\"><a href=\"#yum安装依赖包\" class=\"headerlink\" title=\"yum安装依赖包\"></a>yum安装依赖包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install gcc-c++</span><br><span class=\"line\">$ yum install cmake</span><br><span class=\"line\">$ yum install make</span><br><span class=\"line\">$ yum install bison.x86_64</span><br><span class=\"line\">$ yum install ncurses-devel.x86_64</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解压并编译mysql\"><a href=\"#解压并编译mysql\" class=\"headerlink\" title=\"解压并编译mysql\"></a>解压并编译mysql</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -xzvf mysql.**.tar.gz</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mysql</span><br><span class=\"line\">$ cmake .</span><br><span class=\"line\">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见用户组及用户\"><a href=\"#常见用户组及用户\" class=\"headerlink\" title=\"常见用户组及用户\"></a>常见用户组及用户</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ groupadd mysql</span><br><span class=\"line\">$ useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装MySQL</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod 777 scripts/mysql_install_db</span><br><span class=\"line\">$ scripts/mysql_install_db --user=mysql --basedir=/usr/<span class=\"built_in\">local</span>/mysql --datadir=/usr/<span class=\"built_in\">local</span>/mysql/data</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>只针对mysql5.6，其他版本mysql_install_db步骤可能有所不同.</p>\n<h4 id=\"yum安装依赖包\"><a href=\"#yum安装依赖包\" class=\"headerlink\" title=\"yum安装依赖包\"></a>yum安装依赖包</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ yum install gcc-c++</span><br><span class=\"line\">$ yum install cmake</span><br><span class=\"line\">$ yum install make</span><br><span class=\"line\">$ yum install bison.x86_64</span><br><span class=\"line\">$ yum install ncurses-devel.x86_64</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解压并编译mysql\"><a href=\"#解压并编译mysql\" class=\"headerlink\" title=\"解压并编译mysql\"></a>解压并编译mysql</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ tar -xzvf mysql.**.tar.gz</span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/mysql</span><br><span class=\"line\">$ cmake .</span><br><span class=\"line\">$ make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"常见用户组及用户\"><a href=\"#常见用户组及用户\" class=\"headerlink\" title=\"常见用户组及用户\"></a>常见用户组及用户</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ groupadd mysql</span><br><span class=\"line\">$ useradd -r -g mysql mysql</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装MySQL</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ chmod 777 scripts/mysql_install_db</span><br><span class=\"line\">$ scripts/mysql_install_db --user=mysql --basedir=/usr/<span class=\"built_in\">local</span>/mysql --datadir=/usr/<span class=\"built_in\">local</span>/mysql/data</span><br></pre></td></tr></table></figure>"},{"title":"MyBatis+Spring整合","date":"2016-04-29T03:52:56.000Z","_content":"MyBatis整合，PageHelper分页插件，Spring事物管理。\n\n\n#### MyBatis整合\n在web.xml配置放jdbc.properties等配置文件的目录路径。\n``` xml\n<context-param>\n        <param-name>PROP_HOME</param-name>\n        <param-value>/Users/**/config</param-value>\n</context-param>\n```\n在spring的spring-mvc.xml引入上面配的`PROP_HOME`。\n``` xml\n<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n\t<property name=\"locations\">\n\t\t<list>\n\t\t\t<value>file:///${PROP_HOME}/jdbc.properties</value>\n\t\t</list>\n\t</property>\n</bean>\n```\n\n用c3p0配置连接池。\n``` xml\n<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t<property name=\"jdbcUrl\" value=\"${mysql.url}\" />\n\t<property name=\"user\" value=\"${mysql.username}\" />\n\t<property name=\"password\" value=\"${mysql.password}\" />\n\t<property name=\"driverClass\" value=\"${mysql.driverClassName}\" />\n\t<property name=\"maxPoolSize\" value=\"${mysql.maxPoolSize}\"/>\n\t<property name=\"minPoolSize\" value=\"${mysql.minPoolSize}\"/>\n\t<property name=\"initialPoolSize\" value=\"${mysql.initialPoolSize}\"/>\n\t<property name=\"maxIdleTime\" value=\"${mysql.maxIdleTime}\"/>\n\t<property name=\"acquireIncrement\" value=\"${mysql.acquireIncrement}\"/>\n\t<property name=\"maxStatements\" value=\"${mysql.maxStatements}\"/>\n\t<property name=\"idleConnectionTestPeriod\" value=\"${mysql.idleConnectionTestPeriod}\"/>\n</bean>\n```\n\n配置MyBatis。\n``` xml\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t<!-- 自动匹配Mapper映射文件 -->\n\t<property name=\"mapperLocations\" value=\"classpath*:mappings/**/*apper.xml\"/>\n \t<property name=\"typeAliasesPackage\" value=\"com.bayes.entity\"/>\n\t<property name=\"plugins\">\n\t\t<array>\n\t\t\t<bean class=\"com.github.pagehelper.PageHelper\">\n\t\t\t\t<property name=\"properties\">\n\t\t\t\t\t<value>\n\t\t\t\t\t\tdialect=mysql\n\t\t\t\t\t\toffsetAsPageNum=true\n\t\t\t\t\t\trowBoundsWithCount=true\n\t\t\t\t\t\tpageSizeZero=true\n\t\t\t\t\t\treasonable=false\n\t\t\t\t\t\tsupportMethodsArguments=false\n\t\t\t\t\t\treturnPageInfo=always\n\t\t\t\t\t\tparams=pageNum=pageHelperStart;pageSize=pageHelperRows;\n\t\t\t\t\t</value>\n\t\t\t\t</property>\n\t\t\t</bean>\n\t\t</array>\n\t</property>\n</bean>```\n\n配置MyBatis注解。\n``` xml\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t<property name=\"basePackage\" value=\"com.bayes.mapper\" />\n</bean>\n```\n\njdbc.properties配置内容。\n\n``` properties\nmysql.driverClassName=com.mysql.jdbc.Driver\nmysql.url=jdbc:mysql://*.*.*.*:3306/***?useUnicode:true&characterEncoding:UTF-8&allowMultiQueries:true&noAccessToProcedureBodies=true\nmysql.username=***\nmysql.password=**#**\nmysql.initialPoolSize=20  \nmysql.maxPoolSize=100  \nmysql.minPoolSize=10  \nmysql.maxIdleTime=600  \nmysql.acquireIncrement=5  \nmysql.maxStatements=5  \nmysql.idleConnectionTestPeriod=60\n```\n\n---\n\n#### PageHelper分页插件集成Spring，以及使用\n\nPageHelper集成配置已经在上述`配置MyBatis`给出。\n官方github有详细文档，可参照。\n\n---\n\n#### 配置Spring事物管理\n\n配置Spring-jdbc事物。\n``` xml\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n```\n\n匹配符合规则的方法。\n``` xml\n<tx:advice id=\"bayesAdvice\" transaction-manager=\"transactionManager\">\n\t<tx:attributes>\n\t\t<tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"del*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"add*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"find*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"get*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"apply*\" propagation=\"REQUIRED\"/>\n\t</tx:attributes>\n</tx:advice>\n<aop:config>\n\t<aop:pointcut id=\"allAdviceServiceMethod\" expression=\"execution(* com.bayes.service.*.*(..))\"/>\n\t<aop:advisor pointcut-ref=\"allAdviceServiceMethod\" advice-ref=\"bayesAdvice\" />\n</aop:config>\n```\n","source":"_posts/20160429-MyBatis-Spring整合.md","raw":"---\ntitle: MyBatis+Spring整合\ndate: 2016-04-29 11:52:56\ncategories:\n- Java\ntags:\n- java\n- spring\n---\nMyBatis整合，PageHelper分页插件，Spring事物管理。\n\n\n#### MyBatis整合\n在web.xml配置放jdbc.properties等配置文件的目录路径。\n``` xml\n<context-param>\n        <param-name>PROP_HOME</param-name>\n        <param-value>/Users/**/config</param-value>\n</context-param>\n```\n在spring的spring-mvc.xml引入上面配的`PROP_HOME`。\n``` xml\n<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">\n\t<property name=\"locations\">\n\t\t<list>\n\t\t\t<value>file:///${PROP_HOME}/jdbc.properties</value>\n\t\t</list>\n\t</property>\n</bean>\n```\n\n用c3p0配置连接池。\n``` xml\n<bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\">\n\t<property name=\"jdbcUrl\" value=\"${mysql.url}\" />\n\t<property name=\"user\" value=\"${mysql.username}\" />\n\t<property name=\"password\" value=\"${mysql.password}\" />\n\t<property name=\"driverClass\" value=\"${mysql.driverClassName}\" />\n\t<property name=\"maxPoolSize\" value=\"${mysql.maxPoolSize}\"/>\n\t<property name=\"minPoolSize\" value=\"${mysql.minPoolSize}\"/>\n\t<property name=\"initialPoolSize\" value=\"${mysql.initialPoolSize}\"/>\n\t<property name=\"maxIdleTime\" value=\"${mysql.maxIdleTime}\"/>\n\t<property name=\"acquireIncrement\" value=\"${mysql.acquireIncrement}\"/>\n\t<property name=\"maxStatements\" value=\"${mysql.maxStatements}\"/>\n\t<property name=\"idleConnectionTestPeriod\" value=\"${mysql.idleConnectionTestPeriod}\"/>\n</bean>\n```\n\n配置MyBatis。\n``` xml\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n\t<property name=\"dataSource\" ref=\"dataSource\" />\n\t<!-- 自动匹配Mapper映射文件 -->\n\t<property name=\"mapperLocations\" value=\"classpath*:mappings/**/*apper.xml\"/>\n \t<property name=\"typeAliasesPackage\" value=\"com.bayes.entity\"/>\n\t<property name=\"plugins\">\n\t\t<array>\n\t\t\t<bean class=\"com.github.pagehelper.PageHelper\">\n\t\t\t\t<property name=\"properties\">\n\t\t\t\t\t<value>\n\t\t\t\t\t\tdialect=mysql\n\t\t\t\t\t\toffsetAsPageNum=true\n\t\t\t\t\t\trowBoundsWithCount=true\n\t\t\t\t\t\tpageSizeZero=true\n\t\t\t\t\t\treasonable=false\n\t\t\t\t\t\tsupportMethodsArguments=false\n\t\t\t\t\t\treturnPageInfo=always\n\t\t\t\t\t\tparams=pageNum=pageHelperStart;pageSize=pageHelperRows;\n\t\t\t\t\t</value>\n\t\t\t\t</property>\n\t\t\t</bean>\n\t\t</array>\n\t</property>\n</bean>```\n\n配置MyBatis注解。\n``` xml\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n\t<property name=\"basePackage\" value=\"com.bayes.mapper\" />\n</bean>\n```\n\njdbc.properties配置内容。\n\n``` properties\nmysql.driverClassName=com.mysql.jdbc.Driver\nmysql.url=jdbc:mysql://*.*.*.*:3306/***?useUnicode:true&characterEncoding:UTF-8&allowMultiQueries:true&noAccessToProcedureBodies=true\nmysql.username=***\nmysql.password=**#**\nmysql.initialPoolSize=20  \nmysql.maxPoolSize=100  \nmysql.minPoolSize=10  \nmysql.maxIdleTime=600  \nmysql.acquireIncrement=5  \nmysql.maxStatements=5  \nmysql.idleConnectionTestPeriod=60\n```\n\n---\n\n#### PageHelper分页插件集成Spring，以及使用\n\nPageHelper集成配置已经在上述`配置MyBatis`给出。\n官方github有详细文档，可参照。\n\n---\n\n#### 配置Spring事物管理\n\n配置Spring-jdbc事物。\n``` xml\n<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n```\n\n匹配符合规则的方法。\n``` xml\n<tx:advice id=\"bayesAdvice\" transaction-manager=\"transactionManager\">\n\t<tx:attributes>\n\t\t<tx:method name=\"save*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"del*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"update*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"add*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"find*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"get*\" propagation=\"REQUIRED\"/>\n\t\t<tx:method name=\"apply*\" propagation=\"REQUIRED\"/>\n\t</tx:attributes>\n</tx:advice>\n<aop:config>\n\t<aop:pointcut id=\"allAdviceServiceMethod\" expression=\"execution(* com.bayes.service.*.*(..))\"/>\n\t<aop:advisor pointcut-ref=\"allAdviceServiceMethod\" advice-ref=\"bayesAdvice\" />\n</aop:config>\n```\n","slug":"20160429-MyBatis-Spring整合","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rv000g4ejd84pe0mti","content":"<p>MyBatis整合，PageHelper分页插件，Spring事物管理。</p>\n<h4 id=\"MyBatis整合\"><a href=\"#MyBatis整合\" class=\"headerlink\" title=\"MyBatis整合\"></a>MyBatis整合</h4><p>在web.xml配置放jdbc.properties等配置文件的目录路径。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>PROP_HOME<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/Users/**/config<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在spring的spring-mvc.xml引入上面配的<code>PROP_HOME</code>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"locations\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:///$&#123;PROP_HOME&#125;/jdbc.properties<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>用c3p0配置连接池。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.url&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.username&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.password&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.driverClassName&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.minPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.initialPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxIdleTime&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"acquireIncrement\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.acquireIncrement&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxStatements\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxStatements&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"idleConnectionTestPeriod\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.idleConnectionTestPeriod&#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>配置MyBatis。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 自动匹配Mapper映射文件 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath*:mappings/**/*apper.xml\"</span>/&gt;</span></span><br><span class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"typeAliasesPackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.bayes.entity\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"plugins\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.github.pagehelper.PageHelper\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"properties\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\tdialect=mysql</span><br><span class=\"line\">\t\t\t\t\t\toffsetAsPageNum=true</span><br><span class=\"line\">\t\t\t\t\t\trowBoundsWithCount=true</span><br><span class=\"line\">\t\t\t\t\t\tpageSizeZero=true</span><br><span class=\"line\">\t\t\t\t\t\treasonable=false</span><br><span class=\"line\">\t\t\t\t\t\tsupportMethodsArguments=false</span><br><span class=\"line\">\t\t\t\t\t\treturnPageInfo=always</span><br><span class=\"line\">\t\t\t\t\t\tparams=pageNum=pageHelperStart;pageSize=pageHelperRows;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>配置MyBatis注解。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.bayes.mapper\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>jdbc.properties配置内容。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">mysql.driverClassName</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"meta\">mysql.url</span>=<span class=\"string\">jdbc:mysql://*.*.*.*:3306/***?useUnicode:true&amp;characterEncoding:UTF-8&amp;allowMultiQueries:true&amp;noAccessToProcedureBodies=true</span></span><br><span class=\"line\"><span class=\"meta\">mysql.username</span>=<span class=\"string\">***</span></span><br><span class=\"line\"><span class=\"meta\">mysql.password</span>=<span class=\"string\">**#**</span></span><br><span class=\"line\"><span class=\"meta\">mysql.initialPoolSize</span>=<span class=\"string\">20  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxPoolSize</span>=<span class=\"string\">100  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.minPoolSize</span>=<span class=\"string\">10  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxIdleTime</span>=<span class=\"string\">600  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.acquireIncrement</span>=<span class=\"string\">5  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxStatements</span>=<span class=\"string\">5  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.idleConnectionTestPeriod</span>=<span class=\"string\">60</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"PageHelper分页插件集成Spring，以及使用\"><a href=\"#PageHelper分页插件集成Spring，以及使用\" class=\"headerlink\" title=\"PageHelper分页插件集成Spring，以及使用\"></a>PageHelper分页插件集成Spring，以及使用</h4><p>PageHelper集成配置已经在上述<code>配置MyBatis</code>给出。<br>官方github有详细文档，可参照。</p>\n<hr>\n<h4 id=\"配置Spring事物管理\"><a href=\"#配置Spring事物管理\" class=\"headerlink\" title=\"配置Spring事物管理\"></a>配置Spring事物管理</h4><p>配置Spring-jdbc事物。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>匹配符合规则的方法。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bayesAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"save*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"del*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"update*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"add*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apply*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"allAdviceServiceMethod\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* com.bayes.service.*.*(..))\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"allAdviceServiceMethod\"</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"bayesAdvice\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>MyBatis整合，PageHelper分页插件，Spring事物管理。</p>\n<h4 id=\"MyBatis整合\"><a href=\"#MyBatis整合\" class=\"headerlink\" title=\"MyBatis整合\"></a>MyBatis整合</h4><p>在web.xml配置放jdbc.properties等配置文件的目录路径。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>PROP_HOME<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/Users/**/config<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>在spring的spring-mvc.xml引入上面配的<code>PROP_HOME</code>。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"locations\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>file:///$&#123;PROP_HOME&#125;/jdbc.properties<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>用c3p0配置连接池。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.mchange.v2.c3p0.ComboPooledDataSource\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.url&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.username&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.password&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClass\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.driverClassName&#125;\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"minPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.minPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"initialPoolSize\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.initialPoolSize&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxIdleTime\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxIdleTime&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"acquireIncrement\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.acquireIncrement&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"maxStatements\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.maxStatements&#125;\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"idleConnectionTestPeriod\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;mysql.idleConnectionTestPeriod&#125;\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>配置MyBatis。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sqlSessionFactory\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.SqlSessionFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- 自动匹配Mapper映射文件 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"mapperLocations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"classpath*:mappings/**/*apper.xml\"</span>/&gt;</span></span><br><span class=\"line\"> \t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"typeAliasesPackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.bayes.entity\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"plugins\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.github.pagehelper.PageHelper\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"properties\"</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\tdialect=mysql</span><br><span class=\"line\">\t\t\t\t\t\toffsetAsPageNum=true</span><br><span class=\"line\">\t\t\t\t\t\trowBoundsWithCount=true</span><br><span class=\"line\">\t\t\t\t\t\tpageSizeZero=true</span><br><span class=\"line\">\t\t\t\t\t\treasonable=false</span><br><span class=\"line\">\t\t\t\t\t\tsupportMethodsArguments=false</span><br><span class=\"line\">\t\t\t\t\t\treturnPageInfo=always</span><br><span class=\"line\">\t\t\t\t\t\tparams=pageNum=pageHelperStart;pageSize=pageHelperRows;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">array</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>配置MyBatis注解。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.mybatis.spring.mapper.MapperScannerConfigurer\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"basePackage\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.bayes.mapper\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>jdbc.properties配置内容。</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">mysql.driverClassName</span>=<span class=\"string\">com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"meta\">mysql.url</span>=<span class=\"string\">jdbc:mysql://*.*.*.*:3306/***?useUnicode:true&amp;characterEncoding:UTF-8&amp;allowMultiQueries:true&amp;noAccessToProcedureBodies=true</span></span><br><span class=\"line\"><span class=\"meta\">mysql.username</span>=<span class=\"string\">***</span></span><br><span class=\"line\"><span class=\"meta\">mysql.password</span>=<span class=\"string\">**#**</span></span><br><span class=\"line\"><span class=\"meta\">mysql.initialPoolSize</span>=<span class=\"string\">20  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxPoolSize</span>=<span class=\"string\">100  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.minPoolSize</span>=<span class=\"string\">10  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxIdleTime</span>=<span class=\"string\">600  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.acquireIncrement</span>=<span class=\"string\">5  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.maxStatements</span>=<span class=\"string\">5  </span></span><br><span class=\"line\"><span class=\"meta\">mysql.idleConnectionTestPeriod</span>=<span class=\"string\">60</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"PageHelper分页插件集成Spring，以及使用\"><a href=\"#PageHelper分页插件集成Spring，以及使用\" class=\"headerlink\" title=\"PageHelper分页插件集成Spring，以及使用\"></a>PageHelper分页插件集成Spring，以及使用</h4><p>PageHelper集成配置已经在上述<code>配置MyBatis</code>给出。<br>官方github有详细文档，可参照。</p>\n<hr>\n<h4 id=\"配置Spring事物管理\"><a href=\"#配置Spring事物管理\" class=\"headerlink\" title=\"配置Spring事物管理\"></a>配置Spring事物管理</h4><p>配置Spring-jdbc事物。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"transactionManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>匹配符合规则的方法。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"bayesAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"save*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"del*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"update*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"add*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apply*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"allAdviceServiceMethod\"</span> <span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* com.bayes.service.*.*(..))\"</span>/&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"allAdviceServiceMethod\"</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"bayesAdvice\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式－模板方法模式","date":"2016-04-29T16:51:53.000Z","_content":"模板方法算是种较为常见的设计模式，同时对于大多数场景来说也很实用。在面临多算法交换更替使用的情况下，模板方法为你提供了各种算法的“开关”，提高算法的代码复用度。\n\n---\n\n- ### 举例\n\n不画类图了，直接上代码示例。\n\n这是算法的模板抽象类，`process*()`是算法的每个步骤，`execute()`则是完整得执行算法。\n``` java\npublic abstract class PublicExecute {\n\tpublic int process1() {\n\t\treturn 0; \n\t}\n\tpublic void process2(int i) {\n\t\tSystem.out.println(\"打印\t\t>>>>>\t\" + i);\n\t}\n\tpublic abstract void process3();\n\t//执行算法\n\tpublic void execute() {\n\t\tprocess2(process1());\n\t\tprocess3();\n\t}\n}\n```\n\n下面有两个继承`PublicExecute`并实现其抽象方法的实现类，补充了算法的完整性。\n``` java\n//算法1\npublic class Execute1 extends PublicExecute {\n\t@Override\n\tpublic void process3() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"完成\t\t>>>>>\tExecute1\");\n\t}\t\n\tpublic void process2(int i) {\n\t\tSystem.out.println(\"打印\t\t>>>>>\t\" + (i + 100));\n\t}\n}\n//算法2\npublic class Execute2 extends PublicExecute {\n\t@Override\n\tpublic void process3() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"完成\t\t>>>>>\tExecute2\");\n\t}\t\n}\n```\n上述代码可见，`Execute1`实现了`process3()`，也同时重写`process2(int i)`；`Execute2`仅仅实现了`process3()`。\n\n代码跑起！！！\n``` java\n/*\n * \t我觉得模板方法应该不难看懂，说白了就是重写算法每个步骤的实现方法。\n */\npublic class TemplateMethod {\n\tpublic static void main(String[] args) {\n\t\tPublicExecute execute1 = new Execute1();\n\t\tPublicExecute execute2 = new Execute2();\t\n\t\t/*\n\t\t * 打印\t\t>>>>>\t100\n\t\t * 完成\t\t>>>>>\tExecute1\n\t\t */\n\t\texecute1.execute();\n\t\t/*\n\t\t * 打印\t\t>>>>>\t0\n\t\t * 完成\t\t>>>>>\tExecute2\n\t\t */\n\t\t//execute2.execute();\n\t}\n}\n```\n\n- ### JDK中的模板方法模式\n\njdk可谓是设计模式之集大成，肯定少不了模板方法的。\n``` java \npublic class Arrays {\n\tpublic static void sort(Object[] a) {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a);\n        else\n            ComparableTimSort.sort(a);\n    }\t\n  \n    /** To be removed in a future release. */\n    private static void legacyMergeSort(Object[] a) {\n        Object[] aux = a.clone();\n        mergeSort(aux, a, 0, a.length, 0);\n    }\n    \n    /**\n     * Src is the source array that starts at index 0\n     * Dest is the (possibly larger) array destination with a possible offset\n     * low is the index in dest to start sorting\n     * high is the end index in dest to end sorting\n     * off is the offset to generate corresponding low, high in src\n     * To be removed in a future release.\n     */\n    private static void mergeSort(Object[] src,\n                                  Object[] dest,\n                                  int low,\n                                  int high,\n                                  int off) {\n\n        // Insertion sort on smallest arrays\n        if (length < INSERTIONSORT_THRESHOLD) {\n            for (int i=low; i<high; i++)\n                for (int j=i; j>low &&\n                         ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n                    swap(dest, j, j-1);\n            return;\n        }\n        /*\n         *\t略\n         */\n        // If list is already sorted, just copy from src to dest.  This is an\n        // optimization that results in faster sorts for nearly ordered lists.\n        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n            System.arraycopy(src, low, dest, destLow, length);\n            return;\n        }\n\n        // Merge sorted halves (now in src) into dest\n        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)\n                dest[i] = src[p++];\n            else\n                dest[i] = src[q++];\n        }\n    }\n}\n```\n\nJDK中`java.util.Arrays`的`sort`方法就是典型的模版方法，而从私有方法`mergeSort`来看，为我们提供算法修改的方法则是`Object`的`compareTo`。\n\n- ### 写个`compareTo`的例子\n\n``` java\nclass Dick implements Comparable<Dick> {\n\t\n\tprivate String name;\n\tprivate int size;\n\t\n\tpublic Dick(String name, int size) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.size = size;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Dick [name=\" + name + \", size=\" + size + \"cm]\";\n\t}\n\t\n\t// 实现Comparable接口\n\t@Override\n\tpublic int compareTo(Dick o) {\n\t\t// TODO Auto-generated method stub\n\t\tif(this.size == o.getSize())\n\t\t\treturn 0;\n\t\telse if(this.size >= o.getSize())\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n}\n```\n\n测试、打印.\n\n``` java\npublic class TestArraysSort {\n\tpublic static void main(String[] args) {\n\t\tDick[] fuckers = {new Dick(\"张三\", 17),\n\t\t\t\t\t\t\tnew Dick(\"李四\", 14), \n\t\t\t\t\t\t\tnew Dick(\"王五\", 29), \n\t\t\t\t\t\t\tnew Dick(\"老六\", 22), \n\t\t\t\t\t\t\tnew Dick(\"赵七\", 11)};\n\t\tArrays.sort(fuckers);\n\t\tfor(Dick fucker : fuckers)\n\t\t\tSystem.out.println(fucker);\n\t}\n}\n```\n结果：\n```\nDick [name=赵七, size=11cm]\nDick [name=李四, size=14cm]\nDick [name=张三, size=17cm]\nDick [name=老六, size=22cm]\nDick [name=王五, size=29cm]\n```","source":"_posts/20160429-设计模式－模版方法.md","raw":"---\ntitle: 设计模式－模板方法模式\ndate: 2016-04-30 00:51:53\ncategories: \n- 设计模式\ntags: \n- java\n- 设计模式\n---\n模板方法算是种较为常见的设计模式，同时对于大多数场景来说也很实用。在面临多算法交换更替使用的情况下，模板方法为你提供了各种算法的“开关”，提高算法的代码复用度。\n\n---\n\n- ### 举例\n\n不画类图了，直接上代码示例。\n\n这是算法的模板抽象类，`process*()`是算法的每个步骤，`execute()`则是完整得执行算法。\n``` java\npublic abstract class PublicExecute {\n\tpublic int process1() {\n\t\treturn 0; \n\t}\n\tpublic void process2(int i) {\n\t\tSystem.out.println(\"打印\t\t>>>>>\t\" + i);\n\t}\n\tpublic abstract void process3();\n\t//执行算法\n\tpublic void execute() {\n\t\tprocess2(process1());\n\t\tprocess3();\n\t}\n}\n```\n\n下面有两个继承`PublicExecute`并实现其抽象方法的实现类，补充了算法的完整性。\n``` java\n//算法1\npublic class Execute1 extends PublicExecute {\n\t@Override\n\tpublic void process3() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"完成\t\t>>>>>\tExecute1\");\n\t}\t\n\tpublic void process2(int i) {\n\t\tSystem.out.println(\"打印\t\t>>>>>\t\" + (i + 100));\n\t}\n}\n//算法2\npublic class Execute2 extends PublicExecute {\n\t@Override\n\tpublic void process3() {\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"完成\t\t>>>>>\tExecute2\");\n\t}\t\n}\n```\n上述代码可见，`Execute1`实现了`process3()`，也同时重写`process2(int i)`；`Execute2`仅仅实现了`process3()`。\n\n代码跑起！！！\n``` java\n/*\n * \t我觉得模板方法应该不难看懂，说白了就是重写算法每个步骤的实现方法。\n */\npublic class TemplateMethod {\n\tpublic static void main(String[] args) {\n\t\tPublicExecute execute1 = new Execute1();\n\t\tPublicExecute execute2 = new Execute2();\t\n\t\t/*\n\t\t * 打印\t\t>>>>>\t100\n\t\t * 完成\t\t>>>>>\tExecute1\n\t\t */\n\t\texecute1.execute();\n\t\t/*\n\t\t * 打印\t\t>>>>>\t0\n\t\t * 完成\t\t>>>>>\tExecute2\n\t\t */\n\t\t//execute2.execute();\n\t}\n}\n```\n\n- ### JDK中的模板方法模式\n\njdk可谓是设计模式之集大成，肯定少不了模板方法的。\n``` java \npublic class Arrays {\n\tpublic static void sort(Object[] a) {\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a);\n        else\n            ComparableTimSort.sort(a);\n    }\t\n  \n    /** To be removed in a future release. */\n    private static void legacyMergeSort(Object[] a) {\n        Object[] aux = a.clone();\n        mergeSort(aux, a, 0, a.length, 0);\n    }\n    \n    /**\n     * Src is the source array that starts at index 0\n     * Dest is the (possibly larger) array destination with a possible offset\n     * low is the index in dest to start sorting\n     * high is the end index in dest to end sorting\n     * off is the offset to generate corresponding low, high in src\n     * To be removed in a future release.\n     */\n    private static void mergeSort(Object[] src,\n                                  Object[] dest,\n                                  int low,\n                                  int high,\n                                  int off) {\n\n        // Insertion sort on smallest arrays\n        if (length < INSERTIONSORT_THRESHOLD) {\n            for (int i=low; i<high; i++)\n                for (int j=i; j>low &&\n                         ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n                    swap(dest, j, j-1);\n            return;\n        }\n        /*\n         *\t略\n         */\n        // If list is already sorted, just copy from src to dest.  This is an\n        // optimization that results in faster sorts for nearly ordered lists.\n        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n            System.arraycopy(src, low, dest, destLow, length);\n            return;\n        }\n\n        // Merge sorted halves (now in src) into dest\n        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0)\n                dest[i] = src[p++];\n            else\n                dest[i] = src[q++];\n        }\n    }\n}\n```\n\nJDK中`java.util.Arrays`的`sort`方法就是典型的模版方法，而从私有方法`mergeSort`来看，为我们提供算法修改的方法则是`Object`的`compareTo`。\n\n- ### 写个`compareTo`的例子\n\n``` java\nclass Dick implements Comparable<Dick> {\n\t\n\tprivate String name;\n\tprivate int size;\n\t\n\tpublic Dick(String name, int size) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.size = size;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Dick [name=\" + name + \", size=\" + size + \"cm]\";\n\t}\n\t\n\t// 实现Comparable接口\n\t@Override\n\tpublic int compareTo(Dick o) {\n\t\t// TODO Auto-generated method stub\n\t\tif(this.size == o.getSize())\n\t\t\treturn 0;\n\t\telse if(this.size >= o.getSize())\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n}\n```\n\n测试、打印.\n\n``` java\npublic class TestArraysSort {\n\tpublic static void main(String[] args) {\n\t\tDick[] fuckers = {new Dick(\"张三\", 17),\n\t\t\t\t\t\t\tnew Dick(\"李四\", 14), \n\t\t\t\t\t\t\tnew Dick(\"王五\", 29), \n\t\t\t\t\t\t\tnew Dick(\"老六\", 22), \n\t\t\t\t\t\t\tnew Dick(\"赵七\", 11)};\n\t\tArrays.sort(fuckers);\n\t\tfor(Dick fucker : fuckers)\n\t\t\tSystem.out.println(fucker);\n\t}\n}\n```\n结果：\n```\nDick [name=赵七, size=11cm]\nDick [name=李四, size=14cm]\nDick [name=张三, size=17cm]\nDick [name=老六, size=22cm]\nDick [name=王五, size=29cm]\n```","slug":"20160429-设计模式－模版方法","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rw000k4ejd4ry6dhbu","content":"<p>模板方法算是种较为常见的设计模式，同时对于大多数场景来说也很实用。在面临多算法交换更替使用的情况下，模板方法为你提供了各种算法的“开关”，提高算法的代码复用度。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>不画类图了，直接上代码示例。</p>\n<p>这是算法的模板抽象类，<code>process*()</code>是算法的每个步骤，<code>execute()</code>则是完整得执行算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">process1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"打印\t\t&gt;&gt;&gt;&gt;&gt;\t\"</span> + i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//执行算法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tprocess2(process1());</span><br><span class=\"line\">\t\tprocess3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面有两个继承<code>PublicExecute</code>并实现其抽象方法的实现类，补充了算法的完整性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Execute1</span> <span class=\"keyword\">extends</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute1\"</span>);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"打印\t\t&gt;&gt;&gt;&gt;&gt;\t\"</span> + (i + <span class=\"number\">100</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//算法2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Execute2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute2\"</span>);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码可见，<code>Execute1</code>实现了<code>process3()</code>，也同时重写<code>process2(int i)</code>；<code>Execute2</code>仅仅实现了<code>process3()</code>。</p>\n<p>代码跑起！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * \t我觉得模板方法应该不难看懂，说白了就是重写算法每个步骤的实现方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateMethod</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tPublicExecute execute1 = <span class=\"keyword\">new</span> Execute1();</span><br><span class=\"line\">\t\tPublicExecute execute2 = <span class=\"keyword\">new</span> Execute2();\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 打印\t\t&gt;&gt;&gt;&gt;&gt;\t100</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute1</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\texecute1.execute();</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 打印\t\t&gt;&gt;&gt;&gt;&gt;\t0</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute2</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//execute2.execute();</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的模板方法模式\"><a href=\"#JDK中的模板方法模式\" class=\"headerlink\" title=\"JDK中的模板方法模式\"></a>JDK中的模板方法模式</h3></li>\n</ul>\n<p>jdk可谓是设计模式之集大成，肯定少不了模板方法的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arrays</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Object[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LegacyMergeSort.userRequested)</span><br><span class=\"line\">            legacyMergeSort(a);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ComparableTimSort.sort(a);</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** To be removed in a future release. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">legacyMergeSort</span><span class=\"params\">(Object[] a)</span> </span>&#123;</span><br><span class=\"line\">        Object[] aux = a.clone();</span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Src is the source array that starts at index 0</span></span><br><span class=\"line\"><span class=\"comment\">     * Dest is the (possibly larger) array destination with a possible offset</span></span><br><span class=\"line\"><span class=\"comment\">     * low is the index in dest to start sorting</span></span><br><span class=\"line\"><span class=\"comment\">     * high is the end index in dest to end sorting</span></span><br><span class=\"line\"><span class=\"comment\">     * off is the offset to generate corresponding low, high in src</span></span><br><span class=\"line\"><span class=\"comment\">     * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(Object[] src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] dest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> low,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> high,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> off)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Insertion sort on smallest arrays</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low; i&lt;high; i++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class=\"line\">                         ((Comparable) dest[j-<span class=\"number\">1</span>]).compareTo(dest[j])&gt;<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                    swap(dest, j, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         *\t略</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class=\"line\">        <span class=\"comment\">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (((Comparable)src[mid-<span class=\"number\">1</span>]).compareTo(src[mid]) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.arraycopy(src, low, dest, destLow, length);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Merge sorted halves (now in src) into dest</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">                dest[i] = src[p++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                dest[i] = src[q++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JDK中<code>java.util.Arrays</code>的<code>sort</code>方法就是典型的模版方法，而从私有方法<code>mergeSort</code>来看，为我们提供算法修改的方法则是<code>Object</code>的<code>compareTo</code>。</p>\n<ul>\n<li><h3 id=\"写个compareTo的例子\"><a href=\"#写个compareTo的例子\" class=\"headerlink\" title=\"写个compareTo的例子\"></a>写个<code>compareTo</code>的例子</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dick</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Dick</span>&gt; </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dick</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Dick [name=\"</span> + name + <span class=\"string\">\", size=\"</span> + size + <span class=\"string\">\"cm]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 实现Comparable接口</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Dick o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size == o.getSize())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size &gt;= o.getSize())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试、打印.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestArraysSort</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDick[] fuckers = &#123;<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"张三\"</span>, <span class=\"number\">17</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"李四\"</span>, <span class=\"number\">14</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"王五\"</span>, <span class=\"number\">29</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"老六\"</span>, <span class=\"number\">22</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"赵七\"</span>, <span class=\"number\">11</span>)&#125;;</span><br><span class=\"line\">\t\tArrays.sort(fuckers);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Dick fucker : fuckers)</span><br><span class=\"line\">\t\t\tSystem.out.println(fucker);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dick [name&#x3D;赵七, size&#x3D;11cm]</span><br><span class=\"line\">Dick [name&#x3D;李四, size&#x3D;14cm]</span><br><span class=\"line\">Dick [name&#x3D;张三, size&#x3D;17cm]</span><br><span class=\"line\">Dick [name&#x3D;老六, size&#x3D;22cm]</span><br><span class=\"line\">Dick [name&#x3D;王五, size&#x3D;29cm]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>模板方法算是种较为常见的设计模式，同时对于大多数场景来说也很实用。在面临多算法交换更替使用的情况下，模板方法为你提供了各种算法的“开关”，提高算法的代码复用度。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>不画类图了，直接上代码示例。</p>\n<p>这是算法的模板抽象类，<code>process*()</code>是算法的每个步骤，<code>execute()</code>则是完整得执行算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">process1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"打印\t\t&gt;&gt;&gt;&gt;&gt;\t\"</span> + i);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//执行算法</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tprocess2(process1());</span><br><span class=\"line\">\t\tprocess3();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面有两个继承<code>PublicExecute</code>并实现其抽象方法的实现类，补充了算法的完整性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Execute1</span> <span class=\"keyword\">extends</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute1\"</span>);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process2</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"打印\t\t&gt;&gt;&gt;&gt;&gt;\t\"</span> + (i + <span class=\"number\">100</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//算法2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Execute2</span> <span class=\"keyword\">extends</span> <span class=\"title\">PublicExecute</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">process3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute2\"</span>);</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码可见，<code>Execute1</code>实现了<code>process3()</code>，也同时重写<code>process2(int i)</code>；<code>Execute2</code>仅仅实现了<code>process3()</code>。</p>\n<p>代码跑起！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * \t我觉得模板方法应该不难看懂，说白了就是重写算法每个步骤的实现方法。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TemplateMethod</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tPublicExecute execute1 = <span class=\"keyword\">new</span> Execute1();</span><br><span class=\"line\">\t\tPublicExecute execute2 = <span class=\"keyword\">new</span> Execute2();\t</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 打印\t\t&gt;&gt;&gt;&gt;&gt;\t100</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute1</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\texecute1.execute();</span><br><span class=\"line\">\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 打印\t\t&gt;&gt;&gt;&gt;&gt;\t0</span></span><br><span class=\"line\"><span class=\"comment\">\t\t * 完成\t\t&gt;&gt;&gt;&gt;&gt;\tExecute2</span></span><br><span class=\"line\"><span class=\"comment\">\t\t */</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//execute2.execute();</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的模板方法模式\"><a href=\"#JDK中的模板方法模式\" class=\"headerlink\" title=\"JDK中的模板方法模式\"></a>JDK中的模板方法模式</h3></li>\n</ul>\n<p>jdk可谓是设计模式之集大成，肯定少不了模板方法的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arrays</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Object[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (LegacyMergeSort.userRequested)</span><br><span class=\"line\">            legacyMergeSort(a);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            ComparableTimSort.sort(a);</span><br><span class=\"line\">    &#125;\t</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** To be removed in a future release. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">legacyMergeSort</span><span class=\"params\">(Object[] a)</span> </span>&#123;</span><br><span class=\"line\">        Object[] aux = a.clone();</span><br><span class=\"line\">        mergeSort(aux, a, <span class=\"number\">0</span>, a.length, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Src is the source array that starts at index 0</span></span><br><span class=\"line\"><span class=\"comment\">     * Dest is the (possibly larger) array destination with a possible offset</span></span><br><span class=\"line\"><span class=\"comment\">     * low is the index in dest to start sorting</span></span><br><span class=\"line\"><span class=\"comment\">     * high is the end index in dest to end sorting</span></span><br><span class=\"line\"><span class=\"comment\">     * off is the offset to generate corresponding low, high in src</span></span><br><span class=\"line\"><span class=\"comment\">     * To be removed in a future release.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">mergeSort</span><span class=\"params\">(Object[] src,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  Object[] dest,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> low,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> high,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                  <span class=\"keyword\">int</span> off)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Insertion sort on smallest arrays</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=low; i&lt;high; i++)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class=\"line\">                         ((Comparable) dest[j-<span class=\"number\">1</span>]).compareTo(dest[j])&gt;<span class=\"number\">0</span>; j--)</span><br><span class=\"line\">                    swap(dest, j, j-<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         *\t略</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"comment\">// If list is already sorted, just copy from src to dest.  This is an</span></span><br><span class=\"line\">        <span class=\"comment\">// optimization that results in faster sorts for nearly ordered lists.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (((Comparable)src[mid-<span class=\"number\">1</span>]).compareTo(src[mid]) &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.arraycopy(src, low, dest, destLow, length);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Merge sorted halves (now in src) into dest</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = destLow, p = low, q = mid; i &lt; destHigh; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">                dest[i] = src[p++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                dest[i] = src[q++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JDK中<code>java.util.Arrays</code>的<code>sort</code>方法就是典型的模版方法，而从私有方法<code>mergeSort</code>来看，为我们提供算法修改的方法则是<code>Object</code>的<code>compareTo</code>。</p>\n<ul>\n<li><h3 id=\"写个compareTo的例子\"><a href=\"#写个compareTo的例子\" class=\"headerlink\" title=\"写个compareTo的例子\"></a>写个<code>compareTo</code>的例子</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dick</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Dick</span>&gt; </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dick</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Dick [name=\"</span> + name + <span class=\"string\">\", size=\"</span> + size + <span class=\"string\">\"cm]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 实现Comparable接口</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Dick o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size == o.getSize())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.size &gt;= o.getSize())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试、打印.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestArraysSort</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDick[] fuckers = &#123;<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"张三\"</span>, <span class=\"number\">17</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"李四\"</span>, <span class=\"number\">14</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"王五\"</span>, <span class=\"number\">29</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"老六\"</span>, <span class=\"number\">22</span>), </span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"赵七\"</span>, <span class=\"number\">11</span>)&#125;;</span><br><span class=\"line\">\t\tArrays.sort(fuckers);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Dick fucker : fuckers)</span><br><span class=\"line\">\t\t\tSystem.out.println(fucker);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dick [name&#x3D;赵七, size&#x3D;11cm]</span><br><span class=\"line\">Dick [name&#x3D;李四, size&#x3D;14cm]</span><br><span class=\"line\">Dick [name&#x3D;张三, size&#x3D;17cm]</span><br><span class=\"line\">Dick [name&#x3D;老六, size&#x3D;22cm]</span><br><span class=\"line\">Dick [name&#x3D;王五, size&#x3D;29cm]</span><br></pre></td></tr></table></figure>"},{"title":"无题小诗几首","date":"2016-04-29T14:46:09.000Z","_content":"\n寅夜周遭化水音，\n高山闻猴啼希心。\n书中玉颜金屋在，\n难及伊倾续人丁。\n\n---\n\n墨针轻坠空谷径，\n猿声不鸣唯泼猴。\n周遭无烟闻足音，\n数里幽兰迎哲心。\n\n---\n\n寂听枯叶随风，寥闻冷夜微雨。\n云散不见星辰，帘闭难掩孤灯。\n人儿思甜入梦，影踪幻于无境。\n独卧瞑望阳春，自为太乙归秋。\n\n---\n\n明如夜里星辰，暗如日下人心。\n醉于字里行间，迷于车马流川。\n生在盛枝荫地，死在枯草荒土。\n\n简直天差地别。\n\n---\n\n清晨寒风未刺骨，\n存储过程却凉透我心。\n\n---\n\n墨云翻浪作白雨，无烟箐道闻弦声。\n画中乐者清自闲，欲做竹丛屋中人。\n\n墨雨无声。\n\n---\n\n我的心死，只为你身体的真全。\n我的泪干，只为你血液的流淌。\n我的幻灭，只为你思想的实现。\n我的下葬，只为你地上的长存。\n我，只是另一个我的你。\n生来老去，你我相依。\n\n---","source":"_posts/20160429-小诗几首.md","raw":"---\ntitle: 无题小诗几首\ndate: 2016-04-29 22:46:09\ncategories: \n- 小诗\ntags:\n---\n\n寅夜周遭化水音，\n高山闻猴啼希心。\n书中玉颜金屋在，\n难及伊倾续人丁。\n\n---\n\n墨针轻坠空谷径，\n猿声不鸣唯泼猴。\n周遭无烟闻足音，\n数里幽兰迎哲心。\n\n---\n\n寂听枯叶随风，寥闻冷夜微雨。\n云散不见星辰，帘闭难掩孤灯。\n人儿思甜入梦，影踪幻于无境。\n独卧瞑望阳春，自为太乙归秋。\n\n---\n\n明如夜里星辰，暗如日下人心。\n醉于字里行间，迷于车马流川。\n生在盛枝荫地，死在枯草荒土。\n\n简直天差地别。\n\n---\n\n清晨寒风未刺骨，\n存储过程却凉透我心。\n\n---\n\n墨云翻浪作白雨，无烟箐道闻弦声。\n画中乐者清自闲，欲做竹丛屋中人。\n\n墨雨无声。\n\n---\n\n我的心死，只为你身体的真全。\n我的泪干，只为你血液的流淌。\n我的幻灭，只为你思想的实现。\n我的下葬，只为你地上的长存。\n我，只是另一个我的你。\n生来老去，你我相依。\n\n---","slug":"20160429-小诗几首","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rx000l4ejdfgebh8hc","content":"<p>寅夜周遭化水音，<br>高山闻猴啼希心。<br>书中玉颜金屋在，<br>难及伊倾续人丁。</p>\n<hr>\n<p>墨针轻坠空谷径，<br>猿声不鸣唯泼猴。<br>周遭无烟闻足音，<br>数里幽兰迎哲心。</p>\n<hr>\n<p>寂听枯叶随风，寥闻冷夜微雨。<br>云散不见星辰，帘闭难掩孤灯。<br>人儿思甜入梦，影踪幻于无境。<br>独卧瞑望阳春，自为太乙归秋。</p>\n<hr>\n<p>明如夜里星辰，暗如日下人心。<br>醉于字里行间，迷于车马流川。<br>生在盛枝荫地，死在枯草荒土。</p>\n<p>简直天差地别。</p>\n<hr>\n<p>清晨寒风未刺骨，<br>存储过程却凉透我心。</p>\n<hr>\n<p>墨云翻浪作白雨，无烟箐道闻弦声。<br>画中乐者清自闲，欲做竹丛屋中人。</p>\n<p>墨雨无声。</p>\n<hr>\n<p>我的心死，只为你身体的真全。<br>我的泪干，只为你血液的流淌。<br>我的幻灭，只为你思想的实现。<br>我的下葬，只为你地上的长存。<br>我，只是另一个我的你。<br>生来老去，你我相依。</p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>寅夜周遭化水音，<br>高山闻猴啼希心。<br>书中玉颜金屋在，<br>难及伊倾续人丁。</p>\n<hr>\n<p>墨针轻坠空谷径，<br>猿声不鸣唯泼猴。<br>周遭无烟闻足音，<br>数里幽兰迎哲心。</p>\n<hr>\n<p>寂听枯叶随风，寥闻冷夜微雨。<br>云散不见星辰，帘闭难掩孤灯。<br>人儿思甜入梦，影踪幻于无境。<br>独卧瞑望阳春，自为太乙归秋。</p>\n<hr>\n<p>明如夜里星辰，暗如日下人心。<br>醉于字里行间，迷于车马流川。<br>生在盛枝荫地，死在枯草荒土。</p>\n<p>简直天差地别。</p>\n<hr>\n<p>清晨寒风未刺骨，<br>存储过程却凉透我心。</p>\n<hr>\n<p>墨云翻浪作白雨，无烟箐道闻弦声。<br>画中乐者清自闲，欲做竹丛屋中人。</p>\n<p>墨雨无声。</p>\n<hr>\n<p>我的心死，只为你身体的真全。<br>我的泪干，只为你血液的流淌。<br>我的幻灭，只为你思想的实现。<br>我的下葬，只为你地上的长存。<br>我，只是另一个我的你。<br>生来老去，你我相依。</p>\n<hr>\n"},{"title":"设计模式－适配器模式","date":"2016-05-05T14:50:12.000Z","_content":"这次，我们来说说一个极其不常用到的模式——适配器模式。也并不是绝对极不常用，如果自个写框架之类的话，也许会变得很常用。怎么个常用法呢？在需要使用某个类时，其提供的接口并不是你所希望的，又或者说你还需处理接口返回的结果，你就可以用适配器模式解决此类问题。\n\n---\n\n- ### 举例\n\n当已存在的接口不满足需求时。\n``` java\n//适配器接口\npublic interface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器\npublic class Adapter implements Target {\n\n\tprivate Adaptee adaptee;\n\t\n\tpublic Adapter(Adaptee adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t//适配方法\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n//被适配\npublic class Adaptee {\n\tpublic void simpleRequest(String[] boby) {}\n}\n```\n\n上述代码可见，`Adaptee`的`simpleRequest(String[] boby)`并不满足`Map<String, String>`类型的参数，所以需要适配器`Adapter`的`request(Map<String, String> boby)`方法。\n通常，我们并不会只针对某个子类做适配器，更多的是为一系列的子类(同一父类)做适配，例如上述代码`Adaptee`的子类们。\n\n- ### JDK中的适配器模式\n\n``` java\npublic class FileInputStream extends InputStream {\n\n    /* File Descriptor - handle to the open file */\n    private final FileDescriptor fd;\n    public FileInputStream(FileDescriptor fdObj) {\n        // ...\n        fd = fdObj;\n        // ...\n    }\n    public FileInputStream(String name) throws FileNotFoundException {\n        this(name != null ? new File(name) : null);\n    }\n    public FileInputStream(File file) throws FileNotFoundException {\n    \t// ...\n        fd = new FileDescriptor();\n        // ...\n    }\n    public void close() throws IOException {\n        synchronized (closeLock) {\n            if (closed) {\n                return;\n            }\n            closed = true;\n        }\n        if (channel != null) {\n            /*\n             * Decrement the FD use count associated with the channel\n             * The use count is incremented whenever a new channel\n             * is obtained from this stream.\n             */\n           fd.decrementAndGetUseCount();\n           channel.close();\n        }\n        \n        /*\n         * Decrement the FD use count associated with this stream\n         */\n        int useCount = fd.decrementAndGetUseCount();\n        \n        /*\n         * If FileDescriptor is still in use by another stream, the finalizer\n         * will not close it.\n         */\n        if ((useCount <= 0) || !isRunningFinalize()) {\n            close0();\n        }\n    }\n}\n```\n\n`java.io.FileInputStream`已经是`FileDescriptor`的适配器，由三个构造方法可见，都需要传递或实例化`FileDescriptor`对象。\n\n- ### 适配器模式与装饰器模式\n\n适配器模式的类与类间的代码结构，跟装饰者模式是相似的，但有一点不一样的是，适配器与被适配者没有亲戚关系。装饰者模式会在下一篇讲到！\n","source":"_posts/20160505-设计模式－适配器模式.md","raw":"---\ntitle: 设计模式－适配器模式\ndate: 2016-05-05 22:50:12\ncategories: \n- 设计模式\ntags:\n- java\n- 设计模式\n---\n这次，我们来说说一个极其不常用到的模式——适配器模式。也并不是绝对极不常用，如果自个写框架之类的话，也许会变得很常用。怎么个常用法呢？在需要使用某个类时，其提供的接口并不是你所希望的，又或者说你还需处理接口返回的结果，你就可以用适配器模式解决此类问题。\n\n---\n\n- ### 举例\n\n当已存在的接口不满足需求时。\n``` java\n//适配器接口\npublic interface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器\npublic class Adapter implements Target {\n\n\tprivate Adaptee adaptee;\n\t\n\tpublic Adapter(Adaptee adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t//适配方法\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n//被适配\npublic class Adaptee {\n\tpublic void simpleRequest(String[] boby) {}\n}\n```\n\n上述代码可见，`Adaptee`的`simpleRequest(String[] boby)`并不满足`Map<String, String>`类型的参数，所以需要适配器`Adapter`的`request(Map<String, String> boby)`方法。\n通常，我们并不会只针对某个子类做适配器，更多的是为一系列的子类(同一父类)做适配，例如上述代码`Adaptee`的子类们。\n\n- ### JDK中的适配器模式\n\n``` java\npublic class FileInputStream extends InputStream {\n\n    /* File Descriptor - handle to the open file */\n    private final FileDescriptor fd;\n    public FileInputStream(FileDescriptor fdObj) {\n        // ...\n        fd = fdObj;\n        // ...\n    }\n    public FileInputStream(String name) throws FileNotFoundException {\n        this(name != null ? new File(name) : null);\n    }\n    public FileInputStream(File file) throws FileNotFoundException {\n    \t// ...\n        fd = new FileDescriptor();\n        // ...\n    }\n    public void close() throws IOException {\n        synchronized (closeLock) {\n            if (closed) {\n                return;\n            }\n            closed = true;\n        }\n        if (channel != null) {\n            /*\n             * Decrement the FD use count associated with the channel\n             * The use count is incremented whenever a new channel\n             * is obtained from this stream.\n             */\n           fd.decrementAndGetUseCount();\n           channel.close();\n        }\n        \n        /*\n         * Decrement the FD use count associated with this stream\n         */\n        int useCount = fd.decrementAndGetUseCount();\n        \n        /*\n         * If FileDescriptor is still in use by another stream, the finalizer\n         * will not close it.\n         */\n        if ((useCount <= 0) || !isRunningFinalize()) {\n            close0();\n        }\n    }\n}\n```\n\n`java.io.FileInputStream`已经是`FileDescriptor`的适配器，由三个构造方法可见，都需要传递或实例化`FileDescriptor`对象。\n\n- ### 适配器模式与装饰器模式\n\n适配器模式的类与类间的代码结构，跟装饰者模式是相似的，但有一点不一样的是，适配器与被适配者没有亲戚关系。装饰者模式会在下一篇讲到！\n","slug":"20160505-设计模式－适配器模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7rz000p4ejdew5odlyl","content":"<p>这次，我们来说说一个极其不常用到的模式——适配器模式。也并不是绝对极不常用，如果自个写框架之类的话，也许会变得很常用。怎么个常用法呢？在需要使用某个类时，其提供的接口并不是你所希望的，又或者说你还需处理接口返回的结果，你就可以用适配器模式解决此类问题。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>当已存在的接口不满足需求时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//适配方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码可见，<code>Adaptee</code>的<code>simpleRequest(String[] boby)</code>并不满足<code>Map&lt;String, String&gt;</code>类型的参数，所以需要适配器<code>Adapter</code>的<code>request(Map&lt;String, String&gt; boby)</code>方法。<br>通常，我们并不会只针对某个子类做适配器，更多的是为一系列的子类(同一父类)做适配，例如上述代码<code>Adaptee</code>的子类们。</p>\n<ul>\n<li><h3 id=\"JDK中的适配器模式\"><a href=\"#JDK中的适配器模式\" class=\"headerlink\" title=\"JDK中的适配器模式\"></a>JDK中的适配器模式</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* File Descriptor - handle to the open file */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FileDescriptor fd;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        fd = fdObj;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> File(name) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// ...</span></span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (closeLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            closed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Decrement the FD use count associated with the channel</span></span><br><span class=\"line\"><span class=\"comment\">             * The use count is incremented whenever a new channel</span></span><br><span class=\"line\"><span class=\"comment\">             * is obtained from this stream.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">           fd.decrementAndGetUseCount();</span><br><span class=\"line\">           channel.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Decrement the FD use count associated with this stream</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> useCount = fd.decrementAndGetUseCount();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * If FileDescriptor is still in use by another stream, the finalizer</span></span><br><span class=\"line\"><span class=\"comment\">         * will not close it.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((useCount &lt;= <span class=\"number\">0</span>) || !isRunningFinalize()) &#123;</span><br><span class=\"line\">            close0();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>java.io.FileInputStream</code>已经是<code>FileDescriptor</code>的适配器，由三个构造方法可见，都需要传递或实例化<code>FileDescriptor</code>对象。</p>\n<ul>\n<li><h3 id=\"适配器模式与装饰器模式\"><a href=\"#适配器模式与装饰器模式\" class=\"headerlink\" title=\"适配器模式与装饰器模式\"></a>适配器模式与装饰器模式</h3></li>\n</ul>\n<p>适配器模式的类与类间的代码结构，跟装饰者模式是相似的，但有一点不一样的是，适配器与被适配者没有亲戚关系。装饰者模式会在下一篇讲到！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这次，我们来说说一个极其不常用到的模式——适配器模式。也并不是绝对极不常用，如果自个写框架之类的话，也许会变得很常用。怎么个常用法呢？在需要使用某个类时，其提供的接口并不是你所希望的，又或者说你还需处理接口返回的结果，你就可以用适配器模式解决此类问题。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>当已存在的接口不满足需求时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//适配方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码可见，<code>Adaptee</code>的<code>simpleRequest(String[] boby)</code>并不满足<code>Map&lt;String, String&gt;</code>类型的参数，所以需要适配器<code>Adapter</code>的<code>request(Map&lt;String, String&gt; boby)</code>方法。<br>通常，我们并不会只针对某个子类做适配器，更多的是为一系列的子类(同一父类)做适配，例如上述代码<code>Adaptee</code>的子类们。</p>\n<ul>\n<li><h3 id=\"JDK中的适配器模式\"><a href=\"#JDK中的适配器模式\" class=\"headerlink\" title=\"JDK中的适配器模式\"></a>JDK中的适配器模式</h3></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* File Descriptor - handle to the open file */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FileDescriptor fd;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        fd = fdObj;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> File(name) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// ...</span></span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (closeLock) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (closed) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            closed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">             * Decrement the FD use count associated with the channel</span></span><br><span class=\"line\"><span class=\"comment\">             * The use count is incremented whenever a new channel</span></span><br><span class=\"line\"><span class=\"comment\">             * is obtained from this stream.</span></span><br><span class=\"line\"><span class=\"comment\">             */</span></span><br><span class=\"line\">           fd.decrementAndGetUseCount();</span><br><span class=\"line\">           channel.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Decrement the FD use count associated with this stream</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> useCount = fd.decrementAndGetUseCount();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * If FileDescriptor is still in use by another stream, the finalizer</span></span><br><span class=\"line\"><span class=\"comment\">         * will not close it.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((useCount &lt;= <span class=\"number\">0</span>) || !isRunningFinalize()) &#123;</span><br><span class=\"line\">            close0();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>java.io.FileInputStream</code>已经是<code>FileDescriptor</code>的适配器，由三个构造方法可见，都需要传递或实例化<code>FileDescriptor</code>对象。</p>\n<ul>\n<li><h3 id=\"适配器模式与装饰器模式\"><a href=\"#适配器模式与装饰器模式\" class=\"headerlink\" title=\"适配器模式与装饰器模式\"></a>适配器模式与装饰器模式</h3></li>\n</ul>\n<p>适配器模式的类与类间的代码结构，跟装饰者模式是相似的，但有一点不一样的是，适配器与被适配者没有亲戚关系。装饰者模式会在下一篇讲到！</p>\n"},{"title":"设计模式－适配器与装饰器的比较","date":"2016-05-07T16:50:26.000Z","_content":"前面已经说到了适配器和装饰器两种模式，两种怎么看都一样的，其实它们龙凤双胞胎。\n\n---\n\n- ### 适配器\n\n咱们先来看看适配器模式的代码。\n\n``` java\n//适配器接口\npublic interface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器\npublic class Adapter implements Target {\n\n\tprivate Adaptee adaptee;\n\t\n\tpublic Adapter(Adaptee adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t//适配方法\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n//被适配\npublic class Adaptee {\n\tpublic void simpleRequest(String[] boby) {}\n}\n```\n\n可以看到上诉代码，这只纯粹一个被适配者和适配器的关系，那假如被适配者又是另外一个被适配者的适配器呢？呵呵～～\n\n``` java\ninterface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器一号\nclass Adapter implements Target {\n\n\tprivate Target2 adaptee;\n\t\n\tpublic Adapter(Target2 adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n\ninterface Target2 {\n\tvoid simpleRequest(String[] boby);\n}\n//适配器二号，又被适配器一号适配\nclass Adaptee implements Target2 {\n\tprivate Adaptee2 adaptee2;\n\tpublic Adaptee(Adaptee2 adaptee2) {\n\t\tthis.adaptee2 = adaptee2;\n\t}\n\tpublic void simpleRequest(String[] boby) {}\n}\n//被适配者\nclass Adaptee2 {\n\tpublic void dickRequest(String[] boby) {}\n}\n\npublic class AdapterTemplate {\n\tpublic static void main(String[] args) {\n\t\tTarget target = new Adapter(new Adaptee(new Adaptee2()));\n\t\ttarget.request(new HashMap<String, String>());\n\t}\n}\n```\n\n咱们来看，`Adaptee`适配`Adaptee2`的同时，也被`Adapter`所适配，最终在main方法中的代码呈现给我们的是这样的\n\n``` java\nTarget target = new Adapter(new Adaptee(new Adaptee2()));\n```\n\n- ### 装饰器\n\n跟装饰器并没有什么两样。好吧，还是有区别的，让我们回头再看看装饰器怎样的？\n\n``` java\n//基类（接口）\npublic interface DecoratorTarget {\n\tvoid read(byte[] bs);\n}\n//源基类\npublic class DecoratorTargetSource implements DecoratorTarget {\n\n\t@Override\n\tpublic void read(byte[] bs) {}\n\t\n}\n//源基类装饰器1\npublic class Decorator1 implements DecoratorTarget {\n\n\tprotected DecoratorTarget target;\n\tpublic Decorator1(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器2\npublic class Decorator2 implements DecoratorTarget {\n\t\n\tprotected DecoratorTarget target;\n\tpublic Decorator2(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器3\npublic class Decorator3 extends Decorator1 {\n\n\tpublic Decorator3(DecoratorTarget target) {\n\t\tsuper(target);\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n```\n\n在main方法中，是这样呈现的，\n``` java\nDecoratorTarget target = new Decorator1(new Decorator3(new Decorator2(new DecoratorTargetSource())));\n```\n\nOK！认真讨论一下装饰器的特点，装饰器与被装饰者通常是一个家族的，也就是它们派生于同个Object外的祖宗，包括源、装饰器本身。\n\n- ### 为什么还要区分适配器与装饰器呢？\n\n对比一下适配器，装饰器模式的`DecoratorTargetSource`几乎等同适配器模式的`Adaptee2`，它们的原理几乎是一样的，一个源头的接口需要修改或添加功能，则需要适配器或装饰器解决问题，不同的是不同适配器间往往没有血缘关系，而装饰器之间确实近亲关系甚至后代。\n\n代码结构关系上，确实没什么必要区分开来，但它们的作用才能决定这一事情！\n装饰器着重点在于，一个体系内的类的功能累加或修改，例如IO库。本来体系内的类已经有了很庞大复杂的继承关系，仅仅完善子类的功能而使用唯一的继承位置是浪费的，所以装饰器为体系的所有类提供了另一种继承方法，并且也为了类之间的相互适用。\n\n适配器着重点在于，解决一个接口的不适用，也就是说它并不需要考虑继承体系内类的相互适用性，针对性强许多，倘若某个适配器确实还是需要一个适配器，你大可重写适配器（装饰器未必可以，你需要考虑体系其他类是否支持）。\n","source":"_posts/20160508-设计模式－适配器与装饰器.md","raw":"---\ntitle: 设计模式－适配器与装饰器的比较\ndate: 2016-05-08 00:50:26\ncategories: \n- 设计模式\ntags: \n- java\n- 设计模式\n---\n前面已经说到了适配器和装饰器两种模式，两种怎么看都一样的，其实它们龙凤双胞胎。\n\n---\n\n- ### 适配器\n\n咱们先来看看适配器模式的代码。\n\n``` java\n//适配器接口\npublic interface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器\npublic class Adapter implements Target {\n\n\tprivate Adaptee adaptee;\n\t\n\tpublic Adapter(Adaptee adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t//适配方法\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n//被适配\npublic class Adaptee {\n\tpublic void simpleRequest(String[] boby) {}\n}\n```\n\n可以看到上诉代码，这只纯粹一个被适配者和适配器的关系，那假如被适配者又是另外一个被适配者的适配器呢？呵呵～～\n\n``` java\ninterface Target {\n\tvoid request(Map<String, String> boby);\n}\n//适配器一号\nclass Adapter implements Target {\n\n\tprivate Target2 adaptee;\n\t\n\tpublic Adapter(Target2 adaptee) {\n\t\tthis.adaptee = adaptee;\n\t}\n\t\n\t@Override\n\tpublic void request(Map<String, String> boby) {\n\t\tList<String> list = new ArrayList<String>();\n\t\tfor(Entry<String, String> entry : boby.entrySet()) {\n\t\t\tlist.add(entry.getKey() + \"-\" + entry.getValue());\n\t\t}\n\t\tadaptee.simpleRequest((String[]) list.toArray());\n\t}\n\t\n}\n\ninterface Target2 {\n\tvoid simpleRequest(String[] boby);\n}\n//适配器二号，又被适配器一号适配\nclass Adaptee implements Target2 {\n\tprivate Adaptee2 adaptee2;\n\tpublic Adaptee(Adaptee2 adaptee2) {\n\t\tthis.adaptee2 = adaptee2;\n\t}\n\tpublic void simpleRequest(String[] boby) {}\n}\n//被适配者\nclass Adaptee2 {\n\tpublic void dickRequest(String[] boby) {}\n}\n\npublic class AdapterTemplate {\n\tpublic static void main(String[] args) {\n\t\tTarget target = new Adapter(new Adaptee(new Adaptee2()));\n\t\ttarget.request(new HashMap<String, String>());\n\t}\n}\n```\n\n咱们来看，`Adaptee`适配`Adaptee2`的同时，也被`Adapter`所适配，最终在main方法中的代码呈现给我们的是这样的\n\n``` java\nTarget target = new Adapter(new Adaptee(new Adaptee2()));\n```\n\n- ### 装饰器\n\n跟装饰器并没有什么两样。好吧，还是有区别的，让我们回头再看看装饰器怎样的？\n\n``` java\n//基类（接口）\npublic interface DecoratorTarget {\n\tvoid read(byte[] bs);\n}\n//源基类\npublic class DecoratorTargetSource implements DecoratorTarget {\n\n\t@Override\n\tpublic void read(byte[] bs) {}\n\t\n}\n//源基类装饰器1\npublic class Decorator1 implements DecoratorTarget {\n\n\tprotected DecoratorTarget target;\n\tpublic Decorator1(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器2\npublic class Decorator2 implements DecoratorTarget {\n\t\n\tprotected DecoratorTarget target;\n\tpublic Decorator2(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器3\npublic class Decorator3 extends Decorator1 {\n\n\tpublic Decorator3(DecoratorTarget target) {\n\t\tsuper(target);\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n```\n\n在main方法中，是这样呈现的，\n``` java\nDecoratorTarget target = new Decorator1(new Decorator3(new Decorator2(new DecoratorTargetSource())));\n```\n\nOK！认真讨论一下装饰器的特点，装饰器与被装饰者通常是一个家族的，也就是它们派生于同个Object外的祖宗，包括源、装饰器本身。\n\n- ### 为什么还要区分适配器与装饰器呢？\n\n对比一下适配器，装饰器模式的`DecoratorTargetSource`几乎等同适配器模式的`Adaptee2`，它们的原理几乎是一样的，一个源头的接口需要修改或添加功能，则需要适配器或装饰器解决问题，不同的是不同适配器间往往没有血缘关系，而装饰器之间确实近亲关系甚至后代。\n\n代码结构关系上，确实没什么必要区分开来，但它们的作用才能决定这一事情！\n装饰器着重点在于，一个体系内的类的功能累加或修改，例如IO库。本来体系内的类已经有了很庞大复杂的继承关系，仅仅完善子类的功能而使用唯一的继承位置是浪费的，所以装饰器为体系的所有类提供了另一种继承方法，并且也为了类之间的相互适用。\n\n适配器着重点在于，解决一个接口的不适用，也就是说它并不需要考虑继承体系内类的相互适用性，针对性强许多，倘若某个适配器确实还是需要一个适配器，你大可重写适配器（装饰器未必可以，你需要考虑体系其他类是否支持）。\n","slug":"20160508-设计模式－适配器与装饰器","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7s0000q4ejdc2q98r3a","content":"<p>前面已经说到了适配器和装饰器两种模式，两种怎么看都一样的，其实它们龙凤双胞胎。</p>\n<hr>\n<ul>\n<li><h3 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h3></li>\n</ul>\n<p>咱们先来看看适配器模式的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//适配方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到上诉代码，这只纯粹一个被适配者和适配器的关系，那假如被适配者又是另外一个被适配者的适配器呢？呵呵～～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器一号</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Target2 adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Target2 adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器二号，又被适配器一号适配</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee2 adaptee2;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adaptee</span><span class=\"params\">(Adaptee2 adaptee2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee2 = adaptee2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配者</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dickRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterTemplate</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tTarget target = <span class=\"keyword\">new</span> Adapter(<span class=\"keyword\">new</span> Adaptee(<span class=\"keyword\">new</span> Adaptee2()));</span><br><span class=\"line\">\t\ttarget.request(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>咱们来看，<code>Adaptee</code>适配<code>Adaptee2</code>的同时，也被<code>Adapter</code>所适配，最终在main方法中的代码呈现给我们的是这样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Target target = <span class=\"keyword\">new</span> Adapter(<span class=\"keyword\">new</span> Adaptee(<span class=\"keyword\">new</span> Adaptee2()));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3></li>\n</ul>\n<p>跟装饰器并没有什么两样。好吧，还是有区别的，让我们回头再看看装饰器怎样的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类（接口）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTargetSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator1</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator1</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator2</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator2</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Decorator1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator3</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(target);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在main方法中，是这样呈现的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratorTarget target = <span class=\"keyword\">new</span> Decorator1(<span class=\"keyword\">new</span> Decorator3(<span class=\"keyword\">new</span> Decorator2(<span class=\"keyword\">new</span> DecoratorTargetSource())));</span><br></pre></td></tr></table></figure>\n\n<p>OK！认真讨论一下装饰器的特点，装饰器与被装饰者通常是一个家族的，也就是它们派生于同个Object外的祖宗，包括源、装饰器本身。</p>\n<ul>\n<li><h3 id=\"为什么还要区分适配器与装饰器呢？\"><a href=\"#为什么还要区分适配器与装饰器呢？\" class=\"headerlink\" title=\"为什么还要区分适配器与装饰器呢？\"></a>为什么还要区分适配器与装饰器呢？</h3></li>\n</ul>\n<p>对比一下适配器，装饰器模式的<code>DecoratorTargetSource</code>几乎等同适配器模式的<code>Adaptee2</code>，它们的原理几乎是一样的，一个源头的接口需要修改或添加功能，则需要适配器或装饰器解决问题，不同的是不同适配器间往往没有血缘关系，而装饰器之间确实近亲关系甚至后代。</p>\n<p>代码结构关系上，确实没什么必要区分开来，但它们的作用才能决定这一事情！<br>装饰器着重点在于，一个体系内的类的功能累加或修改，例如IO库。本来体系内的类已经有了很庞大复杂的继承关系，仅仅完善子类的功能而使用唯一的继承位置是浪费的，所以装饰器为体系的所有类提供了另一种继承方法，并且也为了类之间的相互适用。</p>\n<p>适配器着重点在于，解决一个接口的不适用，也就是说它并不需要考虑继承体系内类的相互适用性，针对性强许多，倘若某个适配器确实还是需要一个适配器，你大可重写适配器（装饰器未必可以，你需要考虑体系其他类是否支持）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>前面已经说到了适配器和装饰器两种模式，两种怎么看都一样的，其实它们龙凤双胞胎。</p>\n<hr>\n<ul>\n<li><h3 id=\"适配器\"><a href=\"#适配器\" class=\"headerlink\" title=\"适配器\"></a>适配器</h3></li>\n</ul>\n<p>咱们先来看看适配器模式的代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//适配器接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Adaptee adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">//适配方法</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到上诉代码，这只纯粹一个被适配者和适配器的关系，那假如被适配者又是另外一个被适配者的适配器呢？呵呵～～</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器一号</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Target2 adaptee;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adapter</span><span class=\"params\">(Target2 adaptee)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee = adaptee;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(Map&lt;String, String&gt; boby)</span> </span>&#123;</span><br><span class=\"line\">\t\tList&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Entry&lt;String, String&gt; entry : boby.entrySet()) &#123;</span><br><span class=\"line\">\t\t\tlist.add(entry.getKey() + <span class=\"string\">\"-\"</span> + entry.getValue());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tadaptee.simpleRequest((String[]) list.toArray());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Target2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//适配器二号，又被适配器一号适配</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee</span> <span class=\"keyword\">implements</span> <span class=\"title\">Target2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Adaptee2 adaptee2;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Adaptee</span><span class=\"params\">(Adaptee2 adaptee2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.adaptee2 = adaptee2;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">simpleRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被适配者</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Adaptee2</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dickRequest</span><span class=\"params\">(String[] boby)</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdapterTemplate</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tTarget target = <span class=\"keyword\">new</span> Adapter(<span class=\"keyword\">new</span> Adaptee(<span class=\"keyword\">new</span> Adaptee2()));</span><br><span class=\"line\">\t\ttarget.request(<span class=\"keyword\">new</span> HashMap&lt;String, String&gt;());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>咱们来看，<code>Adaptee</code>适配<code>Adaptee2</code>的同时，也被<code>Adapter</code>所适配，最终在main方法中的代码呈现给我们的是这样的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Target target = <span class=\"keyword\">new</span> Adapter(<span class=\"keyword\">new</span> Adaptee(<span class=\"keyword\">new</span> Adaptee2()));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3></li>\n</ul>\n<p>跟装饰器并没有什么两样。好吧，还是有区别的，让我们回头再看看装饰器怎样的？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类（接口）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTargetSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator1</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator1</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator2</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator2</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Decorator1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator3</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(target);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在main方法中，是这样呈现的，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DecoratorTarget target = <span class=\"keyword\">new</span> Decorator1(<span class=\"keyword\">new</span> Decorator3(<span class=\"keyword\">new</span> Decorator2(<span class=\"keyword\">new</span> DecoratorTargetSource())));</span><br></pre></td></tr></table></figure>\n\n<p>OK！认真讨论一下装饰器的特点，装饰器与被装饰者通常是一个家族的，也就是它们派生于同个Object外的祖宗，包括源、装饰器本身。</p>\n<ul>\n<li><h3 id=\"为什么还要区分适配器与装饰器呢？\"><a href=\"#为什么还要区分适配器与装饰器呢？\" class=\"headerlink\" title=\"为什么还要区分适配器与装饰器呢？\"></a>为什么还要区分适配器与装饰器呢？</h3></li>\n</ul>\n<p>对比一下适配器，装饰器模式的<code>DecoratorTargetSource</code>几乎等同适配器模式的<code>Adaptee2</code>，它们的原理几乎是一样的，一个源头的接口需要修改或添加功能，则需要适配器或装饰器解决问题，不同的是不同适配器间往往没有血缘关系，而装饰器之间确实近亲关系甚至后代。</p>\n<p>代码结构关系上，确实没什么必要区分开来，但它们的作用才能决定这一事情！<br>装饰器着重点在于，一个体系内的类的功能累加或修改，例如IO库。本来体系内的类已经有了很庞大复杂的继承关系，仅仅完善子类的功能而使用唯一的继承位置是浪费的，所以装饰器为体系的所有类提供了另一种继承方法，并且也为了类之间的相互适用。</p>\n<p>适配器着重点在于，解决一个接口的不适用，也就是说它并不需要考虑继承体系内类的相互适用性，针对性强许多，倘若某个适配器确实还是需要一个适配器，你大可重写适配器（装饰器未必可以，你需要考虑体系其他类是否支持）。</p>\n"},{"title":"设计模式－桥接模式","date":"2016-05-03T07:13:20.000Z","_content":"   桥接模式在实际应用中，相比模板方法更为常见。在现实应用情况中，我们面对的是各种各样关系的维度，通过拼接不同维度能方便地实现不同功能，然而给我们的代码带来不少麻烦。一般地，我们面对关系复杂的维度，通常会使用树及林，其结果就是整片代码复杂的继承关系（有时也浪费了这个继承），桥接模式似乎能解决这个问题。\n\n---\n\n- ### 举例\n惯例，不想画类图，直接上代码。\n\n我们如何用代码表述“一件某品牌的某商品”？\n一般地，我们会如此表述：\n``` java\nclass Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件商品！\");\n\t}\n}\nclass LifeGoods extends Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件生活用品！\");\n\t}\n}\nclass OfficialGoods extends Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件办公用品！\");\n\t}\n}\nclass Brand1LifeGoods extends LifeGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的生活用品！\");\n\t}\n}\nclass Brand2LifeGoods extends LifeGoods {public void content() {\n\tSystem.out.println(\"这是一件品牌2产的生活用品！\");\n}}\nclass Brand1OfficialGoods extends OfficialGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的办公用品！\");\n\t}\n}\nclass Brand2OfficialGoods extends OfficialGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的办公用品！\");\n\t}\n}\n```\n\nyep!!!你没看错，就是这么恶心的继承关系，类图可以自己想象。\n用桥接模式大概会成什么样呢？\n``` java\nabstract class Goods {\n\tprotected Brand brand;\n\tpublic void setBrand(Brand brand) {\n\t\tthis.brand = brand;\n\t}\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"商品！\");\n\t}\n}\nclass LifeGoods extends Goods {\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"生活用品！\");\n\t}\n}\nclass OfficialGoods extends Goods {\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"办公用品！\");\n\t}\n}\n/* ========================================= */\nabstract class Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件\");\n\t}\n}\nclass Brand1 extends Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的\");\n\t}\n}\nclass Brand2 extends Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌2产的\");\n\t}\n}\n```\nso？！用聚合！\n``` java\npublic class Bridge {\n\tpublic static void main(String[] args) {\n\t\tGoods goods = new LifeGoods();\n\t\tgoods.setBrand(new Brand1());\n\t\tgoods.content();\n\t\tgoods.setBrand(new Brand2());\n\t\tgoods.content();\n\n\t\tgoods = new OfficialGoods();\n\t\tgoods.setBrand(new Brand2());\n\t\tgoods.content();\n\t}\n}\n```\n\nprint >>>\n```\n这是一件品牌1产的生活用品！\n这是一件品牌2产的生活用品！\n这是一件品牌2产的办公用品！\n```\n\n显然桥接少了一堆的继承关系，客体之间更加清晰，降低了耦合。聚合后的`Bridge`类相比`Brand1LifeGoods`之类，前者留出了唯一的继承位置，可以让我们的`Bridge`做更多的事儿。\n","source":"_posts/20160503-设计模式－桥接模式.md","raw":"---\ntitle: 设计模式－桥接模式\ndate: 2016-05-03 15:13:20\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n   桥接模式在实际应用中，相比模板方法更为常见。在现实应用情况中，我们面对的是各种各样关系的维度，通过拼接不同维度能方便地实现不同功能，然而给我们的代码带来不少麻烦。一般地，我们面对关系复杂的维度，通常会使用树及林，其结果就是整片代码复杂的继承关系（有时也浪费了这个继承），桥接模式似乎能解决这个问题。\n\n---\n\n- ### 举例\n惯例，不想画类图，直接上代码。\n\n我们如何用代码表述“一件某品牌的某商品”？\n一般地，我们会如此表述：\n``` java\nclass Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件商品！\");\n\t}\n}\nclass LifeGoods extends Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件生活用品！\");\n\t}\n}\nclass OfficialGoods extends Goods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件办公用品！\");\n\t}\n}\nclass Brand1LifeGoods extends LifeGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的生活用品！\");\n\t}\n}\nclass Brand2LifeGoods extends LifeGoods {public void content() {\n\tSystem.out.println(\"这是一件品牌2产的生活用品！\");\n}}\nclass Brand1OfficialGoods extends OfficialGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的办公用品！\");\n\t}\n}\nclass Brand2OfficialGoods extends OfficialGoods {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的办公用品！\");\n\t}\n}\n```\n\nyep!!!你没看错，就是这么恶心的继承关系，类图可以自己想象。\n用桥接模式大概会成什么样呢？\n``` java\nabstract class Goods {\n\tprotected Brand brand;\n\tpublic void setBrand(Brand brand) {\n\t\tthis.brand = brand;\n\t}\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"商品！\");\n\t}\n}\nclass LifeGoods extends Goods {\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"生活用品！\");\n\t}\n}\nclass OfficialGoods extends Goods {\n\tpublic void content() {\n\t\tbrand.content();\n\t\tSystem.out.println(\"办公用品！\");\n\t}\n}\n/* ========================================= */\nabstract class Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件\");\n\t}\n}\nclass Brand1 extends Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌1产的\");\n\t}\n}\nclass Brand2 extends Brand {\n\tpublic void content() {\n\t\tSystem.out.println(\"这是一件品牌2产的\");\n\t}\n}\n```\nso？！用聚合！\n``` java\npublic class Bridge {\n\tpublic static void main(String[] args) {\n\t\tGoods goods = new LifeGoods();\n\t\tgoods.setBrand(new Brand1());\n\t\tgoods.content();\n\t\tgoods.setBrand(new Brand2());\n\t\tgoods.content();\n\n\t\tgoods = new OfficialGoods();\n\t\tgoods.setBrand(new Brand2());\n\t\tgoods.content();\n\t}\n}\n```\n\nprint >>>\n```\n这是一件品牌1产的生活用品！\n这是一件品牌2产的生活用品！\n这是一件品牌2产的办公用品！\n```\n\n显然桥接少了一堆的继承关系，客体之间更加清晰，降低了耦合。聚合后的`Bridge`类相比`Brand1LifeGoods`之类，前者留出了唯一的继承位置，可以让我们的`Bridge`做更多的事儿。\n","slug":"20160503-设计模式－桥接模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7s1000s4ejd07p65xrj","content":"<p>   桥接模式在实际应用中，相比模板方法更为常见。在现实应用情况中，我们面对的是各种各样关系的维度，通过拼接不同维度能方便地实现不同功能，然而给我们的代码带来不少麻烦。一般地，我们面对关系复杂的维度，通常会使用树及林，其结果就是整片代码复杂的继承关系（有时也浪费了这个继承），桥接模式似乎能解决这个问题。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3>惯例，不想画类图，直接上代码。</li>\n</ul>\n<p>我们如何用代码表述“一件某品牌的某商品”？<br>一般地，我们会如此表述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件商品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifeGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifeGoods</span> </span>&#123;<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"这是一件品牌2产的生活用品！\"</span>);</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">OfficialGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">OfficialGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yep!!!你没看错，就是这么恶心的继承关系，类图可以自己想象。<br>用桥接模式大概会成什么样呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> Brand brand;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBrand</span><span class=\"params\">(Brand brand)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.brand = brand;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"商品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* ========================================= */</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌2产的\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>so？！用聚合！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bridge</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tGoods goods = <span class=\"keyword\">new</span> LifeGoods();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand1());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand2());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgoods = <span class=\"keyword\">new</span> OfficialGoods();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand2());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>print &gt;&gt;&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一件品牌1产的生活用品！</span><br><span class=\"line\">这是一件品牌2产的生活用品！</span><br><span class=\"line\">这是一件品牌2产的办公用品！</span><br></pre></td></tr></table></figure>\n\n<p>显然桥接少了一堆的继承关系，客体之间更加清晰，降低了耦合。聚合后的<code>Bridge</code>类相比<code>Brand1LifeGoods</code>之类，前者留出了唯一的继承位置，可以让我们的<code>Bridge</code>做更多的事儿。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>   桥接模式在实际应用中，相比模板方法更为常见。在现实应用情况中，我们面对的是各种各样关系的维度，通过拼接不同维度能方便地实现不同功能，然而给我们的代码带来不少麻烦。一般地，我们面对关系复杂的维度，通常会使用树及林，其结果就是整片代码复杂的继承关系（有时也浪费了这个继承），桥接模式似乎能解决这个问题。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3>惯例，不想画类图，直接上代码。</li>\n</ul>\n<p>我们如何用代码表述“一件某品牌的某商品”？<br>一般地，我们会如此表述：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件商品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifeGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">LifeGoods</span> </span>&#123;<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\"这是一件品牌2产的生活用品！\"</span>);</span><br><span class=\"line\">&#125;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">OfficialGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">OfficialGoods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>yep!!!你没看错，就是这么恶心的继承关系，类图可以自己想象。<br>用桥接模式大概会成什么样呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> Brand brand;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setBrand</span><span class=\"params\">(Brand brand)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.brand = brand;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"商品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LifeGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"生活用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OfficialGoods</span> <span class=\"keyword\">extends</span> <span class=\"title\">Goods</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tbrand.content();</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"办公用品！\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* ========================================= */</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand1</span> <span class=\"keyword\">extends</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌1产的\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Brand2</span> <span class=\"keyword\">extends</span> <span class=\"title\">Brand</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">content</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"这是一件品牌2产的\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>so？！用聚合！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bridge</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tGoods goods = <span class=\"keyword\">new</span> LifeGoods();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand1());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand2());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tgoods = <span class=\"keyword\">new</span> OfficialGoods();</span><br><span class=\"line\">\t\tgoods.setBrand(<span class=\"keyword\">new</span> Brand2());</span><br><span class=\"line\">\t\tgoods.content();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>print &gt;&gt;&gt;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这是一件品牌1产的生活用品！</span><br><span class=\"line\">这是一件品牌2产的生活用品！</span><br><span class=\"line\">这是一件品牌2产的办公用品！</span><br></pre></td></tr></table></figure>\n\n<p>显然桥接少了一堆的继承关系，客体之间更加清晰，降低了耦合。聚合后的<code>Bridge</code>类相比<code>Brand1LifeGoods</code>之类，前者留出了唯一的继承位置，可以让我们的<code>Bridge</code>做更多的事儿。</p>\n"},{"title":"设计模式－组合模式","date":"2016-05-09T09:59:02.000Z","_content":"\n如何用一个对象表达一棵树？如何用一个对象遍历一棵树的所有节点？这是我们下面要讨论的一个设计模式——组合模式。该模式其实并不常见，也不常用，但需要解决树形的数据结构时，它是极佳的解决方法。\n\n---\n\n- ### 举例\n\n为末节点`Leaf`和非末节点即组件`Composite`声明接口`Component`。\n注意到接口又添加删除方法，用来添加单个或多个零件所构的组件。\n\n``` java\n//组件\npublic abstract class Component {\n\n\tprotected String code;\n\tprotected String name;\n\n\tpublic Component(String code, String name) {\n\t\tthis.code = code;\n\t\tthis.name = name;\n\t}\n\n\tpublic abstract void add(Component component);\n\n\tpublic abstract void remove(Component component);\n\n\tpublic abstract String printInfo();\n\n}\n//末节点\npublic class Leaf extends Component {\n\n\tpublic Leaf(String code, String name) {\n\t\tsuper(code, name);\n\t}\n\n\t//我是纯粹的零件，没有添加删除\n\t@Override\n\tpublic void add(Component component) {}\n\n\t@Override\n\tpublic void remove(Component component) {}\n\n\t//打印零件信息\n\t@Override\n\tpublic String printInfo() {\n\t\treturn this.code + \":\" + this.name;\n\t}\n\n}\n//非末节点\npublic class Composite extends Component {\n\n\tpublic Composite(String code, String name) {\n\t\tsuper(code, name);\n\t}\n\n\tprivate List<Component> components = new ArrayList<Component>();\n\n\t//我是组件，必须添加删除\n\t@Override\n\tpublic void add(Component component) {\n\t\tcomponents.add(component);\n\t}\n\n\t@Override\n\tpublic void remove(Component component) {\n\t\tcomponents.remove(component);\n\t}\n\n\t//遍历零件信息\n\t@Override\n\tpublic String printInfo() {\n\t\tStringBuffer info = new StringBuffer(this.code + \":\" + this.name).append(\"-->\");\n\t\tfor(Component component : this.components)\n\t\t\tinfo.append(component.printInfo()).append(\",\");\n\t\treturn info.substring(0, info.length()-1);\n\t}\n\n}\n```\n\n咱们可联想一下树形部门结构是咋样的？\n```\n总经理\n\t--- 人事部\n\t\t---\tA组\n\t\t\t--- 王五\n\t\t--- B司\n\t--- 研发部\n\t\t--- 产品A研发\n\t\t\t--- 张三\n\t\t--- 产品B研发\n\t\t\t--- 李四\n\t--- 市场部\n```\n于是乎。。。\n\n``` java\npublic class CompositeTemplate {\n\tpublic static void main(String[] args) {\n\t\tComponent general = new Composite(\"001\", \"总经理\");\n\t\tComponent hr = new Composite(\"101\", \"人事部\");\n\t\tComponent tech = new Composite(\"102\", \"研发部\");\n\t\tComponent market = new Composite(\"103\", \"市场部\");\n\t\tLeaf leaf = new Leaf(\"10101\", \"张三\");\n\t\tLeaf leaf2 = new Leaf(\"10202\", \"李四\");\n\t\tLeaf leaf3 = new Leaf(\"10303\", \"王五\");\n\t\thr.add(leaf);\n\t\ttech.add(leaf2);\n\t\tmarket.add(leaf3);\n\t\tgeneral.add(hr);\n\t\tgeneral.add(tech);\n\t\tgeneral.add(market);\n\t\t// 001:总经理:{101:人事部:{10101:张三},102:研发部:{10202:李四},103:市场部:{10303:王五}}\n\t\tSystem.out.println(general.printInfo());\n\t}\n}\n```\n\n- ### JDK中的组合模式\n\nJDK中的`java.util.ArrayList`类中有`addAll`、`removeAll`就有组合模式的效果，尽管最后表现出来的依然是一维数组。\n\n``` java\n\tpublic boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\tpublic boolean removeAll(Collection<?> c) {\n        return batchRemove(c, false);\n    }\n    private boolean batchRemove(Collection<?> c, boolean complement) {\n        final Object[] elementData = this.elementData;\n        int r = 0, w = 0;\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                if (c.contains(elementData[r]) == complement)\n                    elementData[w++] = elementData[r];\n        } finally {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            if (r != size) {\n                System.arraycopy(elementData, r,\n                                 elementData, w,\n                                 size - r);\n                w += size - r;\n            }\n            if (w != size) {\n                // clear to let GC do its work\n                for (int i = w; i < size; i++)\n                    elementData[i] = null;\n                modCount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n```\n","source":"_posts/20160509-设计模式－组合模式.md","raw":"---\ntitle: 设计模式－组合模式\ndate: 2016-05-09 17:59:02\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n\n如何用一个对象表达一棵树？如何用一个对象遍历一棵树的所有节点？这是我们下面要讨论的一个设计模式——组合模式。该模式其实并不常见，也不常用，但需要解决树形的数据结构时，它是极佳的解决方法。\n\n---\n\n- ### 举例\n\n为末节点`Leaf`和非末节点即组件`Composite`声明接口`Component`。\n注意到接口又添加删除方法，用来添加单个或多个零件所构的组件。\n\n``` java\n//组件\npublic abstract class Component {\n\n\tprotected String code;\n\tprotected String name;\n\n\tpublic Component(String code, String name) {\n\t\tthis.code = code;\n\t\tthis.name = name;\n\t}\n\n\tpublic abstract void add(Component component);\n\n\tpublic abstract void remove(Component component);\n\n\tpublic abstract String printInfo();\n\n}\n//末节点\npublic class Leaf extends Component {\n\n\tpublic Leaf(String code, String name) {\n\t\tsuper(code, name);\n\t}\n\n\t//我是纯粹的零件，没有添加删除\n\t@Override\n\tpublic void add(Component component) {}\n\n\t@Override\n\tpublic void remove(Component component) {}\n\n\t//打印零件信息\n\t@Override\n\tpublic String printInfo() {\n\t\treturn this.code + \":\" + this.name;\n\t}\n\n}\n//非末节点\npublic class Composite extends Component {\n\n\tpublic Composite(String code, String name) {\n\t\tsuper(code, name);\n\t}\n\n\tprivate List<Component> components = new ArrayList<Component>();\n\n\t//我是组件，必须添加删除\n\t@Override\n\tpublic void add(Component component) {\n\t\tcomponents.add(component);\n\t}\n\n\t@Override\n\tpublic void remove(Component component) {\n\t\tcomponents.remove(component);\n\t}\n\n\t//遍历零件信息\n\t@Override\n\tpublic String printInfo() {\n\t\tStringBuffer info = new StringBuffer(this.code + \":\" + this.name).append(\"-->\");\n\t\tfor(Component component : this.components)\n\t\t\tinfo.append(component.printInfo()).append(\",\");\n\t\treturn info.substring(0, info.length()-1);\n\t}\n\n}\n```\n\n咱们可联想一下树形部门结构是咋样的？\n```\n总经理\n\t--- 人事部\n\t\t---\tA组\n\t\t\t--- 王五\n\t\t--- B司\n\t--- 研发部\n\t\t--- 产品A研发\n\t\t\t--- 张三\n\t\t--- 产品B研发\n\t\t\t--- 李四\n\t--- 市场部\n```\n于是乎。。。\n\n``` java\npublic class CompositeTemplate {\n\tpublic static void main(String[] args) {\n\t\tComponent general = new Composite(\"001\", \"总经理\");\n\t\tComponent hr = new Composite(\"101\", \"人事部\");\n\t\tComponent tech = new Composite(\"102\", \"研发部\");\n\t\tComponent market = new Composite(\"103\", \"市场部\");\n\t\tLeaf leaf = new Leaf(\"10101\", \"张三\");\n\t\tLeaf leaf2 = new Leaf(\"10202\", \"李四\");\n\t\tLeaf leaf3 = new Leaf(\"10303\", \"王五\");\n\t\thr.add(leaf);\n\t\ttech.add(leaf2);\n\t\tmarket.add(leaf3);\n\t\tgeneral.add(hr);\n\t\tgeneral.add(tech);\n\t\tgeneral.add(market);\n\t\t// 001:总经理:{101:人事部:{10101:张三},102:研发部:{10202:李四},103:市场部:{10303:王五}}\n\t\tSystem.out.println(general.printInfo());\n\t}\n}\n```\n\n- ### JDK中的组合模式\n\nJDK中的`java.util.ArrayList`类中有`addAll`、`removeAll`就有组合模式的效果，尽管最后表现出来的依然是一维数组。\n\n``` java\n\tpublic boolean addAll(Collection<? extends E> c) {\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        ensureCapacityInternal(size + numNew);  // Increments modCount\n        System.arraycopy(a, 0, elementData, size, numNew);\n        size += numNew;\n        return numNew != 0;\n    }\n\tpublic boolean removeAll(Collection<?> c) {\n        return batchRemove(c, false);\n    }\n    private boolean batchRemove(Collection<?> c, boolean complement) {\n        final Object[] elementData = this.elementData;\n        int r = 0, w = 0;\n        boolean modified = false;\n        try {\n            for (; r < size; r++)\n                if (c.contains(elementData[r]) == complement)\n                    elementData[w++] = elementData[r];\n        } finally {\n            // Preserve behavioral compatibility with AbstractCollection,\n            // even if c.contains() throws.\n            if (r != size) {\n                System.arraycopy(elementData, r,\n                                 elementData, w,\n                                 size - r);\n                w += size - r;\n            }\n            if (w != size) {\n                // clear to let GC do its work\n                for (int i = w; i < size; i++)\n                    elementData[i] = null;\n                modCount += size - w;\n                size = w;\n                modified = true;\n            }\n        }\n        return modified;\n    }\n```\n","slug":"20160509-设计模式－组合模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7s5000v4ejd8b9da5ll","content":"<p>如何用一个对象表达一棵树？如何用一个对象遍历一棵树的所有节点？这是我们下面要讨论的一个设计模式——组合模式。该模式其实并不常见，也不常用，但需要解决树形的数据结构时，它是极佳的解决方法。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>为末节点<code>Leaf</code>和非末节点即组件<code>Composite</code>声明接口<code>Component</code>。<br>注意到接口又添加删除方法，用来添加单个或多个零件所构的组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//组件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> String code;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末节点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(code, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//我是纯粹的零件，没有添加删除</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//打印零件信息</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.code + <span class=\"string\">\":\"</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//非末节点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(code, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Component&gt; components = <span class=\"keyword\">new</span> ArrayList&lt;Component&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//我是组件，必须添加删除</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">\t\tcomponents.add(component);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">\t\tcomponents.remove(component);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历零件信息</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuffer info = <span class=\"keyword\">new</span> StringBuffer(<span class=\"keyword\">this</span>.code + <span class=\"string\">\":\"</span> + <span class=\"keyword\">this</span>.name).append(<span class=\"string\">\"--&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Component component : <span class=\"keyword\">this</span>.components)</span><br><span class=\"line\">\t\t\tinfo.append(component.printInfo()).append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> info.substring(<span class=\"number\">0</span>, info.length()-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>咱们可联想一下树形部门结构是咋样的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总经理</span><br><span class=\"line\">\t--- 人事部</span><br><span class=\"line\">\t\t---\tA组</span><br><span class=\"line\">\t\t\t--- 王五</span><br><span class=\"line\">\t\t--- B司</span><br><span class=\"line\">\t--- 研发部</span><br><span class=\"line\">\t\t--- 产品A研发</span><br><span class=\"line\">\t\t\t--- 张三</span><br><span class=\"line\">\t\t--- 产品B研发</span><br><span class=\"line\">\t\t\t--- 李四</span><br><span class=\"line\">\t--- 市场部</span><br></pre></td></tr></table></figure>\n<p>于是乎。。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompositeTemplate</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tComponent general = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"001\"</span>, <span class=\"string\">\"总经理\"</span>);</span><br><span class=\"line\">\t\tComponent hr = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"101\"</span>, <span class=\"string\">\"人事部\"</span>);</span><br><span class=\"line\">\t\tComponent tech = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"102\"</span>, <span class=\"string\">\"研发部\"</span>);</span><br><span class=\"line\">\t\tComponent market = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"103\"</span>, <span class=\"string\">\"市场部\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10101\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf2 = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10202\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf3 = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10303\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">\t\thr.add(leaf);</span><br><span class=\"line\">\t\ttech.add(leaf2);</span><br><span class=\"line\">\t\tmarket.add(leaf3);</span><br><span class=\"line\">\t\tgeneral.add(hr);</span><br><span class=\"line\">\t\tgeneral.add(tech);</span><br><span class=\"line\">\t\tgeneral.add(market);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 001:总经理:&#123;101:人事部:&#123;10101:张三&#125;,102:研发部:&#123;10202:李四&#125;,103:市场部:&#123;10303:王五&#125;&#125;</span></span><br><span class=\"line\">\t\tSystem.out.println(general.printInfo());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的组合模式\"><a href=\"#JDK中的组合模式\" class=\"headerlink\" title=\"JDK中的组合模式\"></a>JDK中的组合模式</h3></li>\n</ul>\n<p>JDK中的<code>java.util.ArrayList</code>类中有<code>addAll</code>、<code>removeAll</code>就有组合模式的效果，尽管最后表现出来的依然是一维数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       Object[] a = c.toArray();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">       ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">       System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">       size += numNew;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">batchRemove</span><span class=\"params\">(Collection&lt;?&gt; c, <span class=\"keyword\">boolean</span> complement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Object[] elementData = <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (; r &lt; size; r++)</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c.contains(elementData[r]) == complement)</span><br><span class=\"line\">                   elementData[w++] = elementData[r];</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class=\"line\">           <span class=\"comment\">// even if c.contains() throws.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (r != size) &#123;</span><br><span class=\"line\">               System.arraycopy(elementData, r,</span><br><span class=\"line\">                                elementData, w,</span><br><span class=\"line\">                                size - r);</span><br><span class=\"line\">               w += size - r;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (w != size) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = w; i &lt; size; i++)</span><br><span class=\"line\">                   elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">               modCount += size - w;</span><br><span class=\"line\">               size = w;</span><br><span class=\"line\">               modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>如何用一个对象表达一棵树？如何用一个对象遍历一棵树的所有节点？这是我们下面要讨论的一个设计模式——组合模式。该模式其实并不常见，也不常用，但需要解决树形的数据结构时，它是极佳的解决方法。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>为末节点<code>Leaf</code>和非末节点即组件<code>Composite</code>声明接口<code>Component</code>。<br>注意到接口又添加删除方法，用来添加单个或多个零件所构的组件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//组件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> String code;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Component</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//末节点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Leaf</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Leaf</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(code, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//我是纯粹的零件，没有添加删除</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//打印零件信息</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.code + <span class=\"string\">\":\"</span> + <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//非末节点</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Composite</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Composite</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(code, name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Component&gt; components = <span class=\"keyword\">new</span> ArrayList&lt;Component&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//我是组件，必须添加删除</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">\t\tcomponents.add(component);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(Component component)</span> </span>&#123;</span><br><span class=\"line\">\t\tcomponents.remove(component);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//遍历零件信息</span></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">printInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tStringBuffer info = <span class=\"keyword\">new</span> StringBuffer(<span class=\"keyword\">this</span>.code + <span class=\"string\">\":\"</span> + <span class=\"keyword\">this</span>.name).append(<span class=\"string\">\"--&gt;\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Component component : <span class=\"keyword\">this</span>.components)</span><br><span class=\"line\">\t\t\tinfo.append(component.printInfo()).append(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> info.substring(<span class=\"number\">0</span>, info.length()-<span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>咱们可联想一下树形部门结构是咋样的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">总经理</span><br><span class=\"line\">\t--- 人事部</span><br><span class=\"line\">\t\t---\tA组</span><br><span class=\"line\">\t\t\t--- 王五</span><br><span class=\"line\">\t\t--- B司</span><br><span class=\"line\">\t--- 研发部</span><br><span class=\"line\">\t\t--- 产品A研发</span><br><span class=\"line\">\t\t\t--- 张三</span><br><span class=\"line\">\t\t--- 产品B研发</span><br><span class=\"line\">\t\t\t--- 李四</span><br><span class=\"line\">\t--- 市场部</span><br></pre></td></tr></table></figure>\n<p>于是乎。。。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompositeTemplate</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tComponent general = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"001\"</span>, <span class=\"string\">\"总经理\"</span>);</span><br><span class=\"line\">\t\tComponent hr = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"101\"</span>, <span class=\"string\">\"人事部\"</span>);</span><br><span class=\"line\">\t\tComponent tech = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"102\"</span>, <span class=\"string\">\"研发部\"</span>);</span><br><span class=\"line\">\t\tComponent market = <span class=\"keyword\">new</span> Composite(<span class=\"string\">\"103\"</span>, <span class=\"string\">\"市场部\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10101\"</span>, <span class=\"string\">\"张三\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf2 = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10202\"</span>, <span class=\"string\">\"李四\"</span>);</span><br><span class=\"line\">\t\tLeaf leaf3 = <span class=\"keyword\">new</span> Leaf(<span class=\"string\">\"10303\"</span>, <span class=\"string\">\"王五\"</span>);</span><br><span class=\"line\">\t\thr.add(leaf);</span><br><span class=\"line\">\t\ttech.add(leaf2);</span><br><span class=\"line\">\t\tmarket.add(leaf3);</span><br><span class=\"line\">\t\tgeneral.add(hr);</span><br><span class=\"line\">\t\tgeneral.add(tech);</span><br><span class=\"line\">\t\tgeneral.add(market);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 001:总经理:&#123;101:人事部:&#123;10101:张三&#125;,102:研发部:&#123;10202:李四&#125;,103:市场部:&#123;10303:王五&#125;&#125;</span></span><br><span class=\"line\">\t\tSystem.out.println(general.printInfo());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的组合模式\"><a href=\"#JDK中的组合模式\" class=\"headerlink\" title=\"JDK中的组合模式\"></a>JDK中的组合模式</h3></li>\n</ul>\n<p>JDK中的<code>java.util.ArrayList</code>类中有<code>addAll</code>、<code>removeAll</code>就有组合模式的效果，尽管最后表现出来的依然是一维数组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       Object[] a = c.toArray();</span><br><span class=\"line\">       <span class=\"keyword\">int</span> numNew = a.length;</span><br><span class=\"line\">       ensureCapacityInternal(size + numNew);  <span class=\"comment\">// Increments modCount</span></span><br><span class=\"line\">       System.arraycopy(a, <span class=\"number\">0</span>, elementData, size, numNew);</span><br><span class=\"line\">       size += numNew;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> numNew != <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> batchRemove(c, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">batchRemove</span><span class=\"params\">(Collection&lt;?&gt; c, <span class=\"keyword\">boolean</span> complement)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">final</span> Object[] elementData = <span class=\"keyword\">this</span>.elementData;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> r = <span class=\"number\">0</span>, w = <span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (; r &lt; size; r++)</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (c.contains(elementData[r]) == complement)</span><br><span class=\"line\">                   elementData[w++] = elementData[r];</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class=\"line\">           <span class=\"comment\">// even if c.contains() throws.</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (r != size) &#123;</span><br><span class=\"line\">               System.arraycopy(elementData, r,</span><br><span class=\"line\">                                elementData, w,</span><br><span class=\"line\">                                size - r);</span><br><span class=\"line\">               w += size - r;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (w != size) &#123;</span><br><span class=\"line\">               <span class=\"comment\">// clear to let GC do its work</span></span><br><span class=\"line\">               <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = w; i &lt; size; i++)</span><br><span class=\"line\">                   elementData[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">               modCount += size - w;</span><br><span class=\"line\">               size = w;</span><br><span class=\"line\">               modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"SpringMVC拦截器Interceptor","date":"2016-05-10T16:26:08.000Z","_content":"\nSpringMVC拦截器是个非常好用的东西，对于每个请求有分别对进入控制器前、执行控制器后渲染之前、渲染之后的行为都能拦截。通常我们用拦截器实现了权限管理、MyBatis分页功能等。\n\n---\n\n- ### 实现`HandlerInterceptor`接口\n\n拦截器一般直接实现`HandlerInterceptor`接口，Spring也只处理该类型的拦截器。有些文章说也可以选择继承`HandlerInterceptorAdapter`抽象类，此方式我强烈不建议，不仅因为该类并不是严格的拦截器接口，也浪费了继承位置，并且`afterConcurrentHandlingStarted`方法在其实并没有什么卵用，Spring完全调用不到该方法。\n\n``` java\npublic class FuckInterceptor implements HandlerInterceptor {\n\n  //进入控制器之前执行,若为false,不执行控制器.\n  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n\n      return true;\n  }\n\n  //出控制器后,若有新页面并未渲染之前执行\n  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n\n  }\n\n  //整个请求结束之后\n  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n  }\n}\n\n// ===============================================================\npublic abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor {\n}\n\npublic interface AsyncHandlerInterceptor extends HandlerInterceptor {\n  void afterConcurrentHandlingStarted(\n\t\t\tHttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception;\n}\n```\n\n- ### 实现`WebRequestInterceptor`接口\n\n其次还有实现`WebRequestInterceptor`接口的方式，为`WebRequest`已经封装`HttpServletRequest`的全部常用操作。但此类拦截器并不能让如上述拦截器一般，停止请求继续进行，所以通常只做请求的预备工作。\n\n``` java\npublic class FuckInterceptor implements WebRequestInterceptor {\n\n  //进入控制器之前执行.\n  public void preHandle(WebRequest request) throws Exception {}\n\n  //出控制器后,若有新页面并未渲染之前执行\n  public void postHandle(WebRequest request, ModelMap model) throws Exception {}\n\n  //整个请求结束之后\n  public void afterCompletion(WebRequest request, Exception ex) throws Exception {}\n}\n\npublic interface WebRequest extends RequestAttributes {\n\n\tString getHeader(String headerName);\n\n\tString[] getHeaderValues(String headerName);\n\n\tIterator<String> getHeaderNames();\n\n\tString getParameter(String paramName);\n\n\tString[] getParameterValues(String paramName);\n\n\tIterator<String> getParameterNames();\n\n\tMap<String, String[]> getParameterMap();\n\n\tLocale getLocale();\n\n\tString getContextPath();\n\n\tString getRemoteUser();\n\n\tPrincipal getUserPrincipal();\n\n\tboolean isUserInRole(String role);\n\n\tboolean isSecure();\n\n\tboolean checkNotModified(long lastModifiedTimestamp);\n\n\tboolean checkNotModified(String etag);\n\n\tboolean checkNotModified(String etag, long lastModifiedTimestamp);\n\n\tString getDescription(boolean includeClientInfo);\n\n}\n```\n\n- ### 配置拦截器\n\n引用标签\n``` xml\nxmlns:mvc=\"http://www.springframework.org/schema/mvc\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/mvc\n  http://www.springframework.org/schema/mvc/spring-mvc.xsd\"\n```\n\n配置拦截器\n``` xml\n<mvc:interceptors>\n  <!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 -->\n  <mvc:interceptor>\n    <mvc:mapping path=\"/fuck/**\"/>\n    <!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 -->\n    <bean class=\"com.bayes.interceptor.WechatInterceptor\"/>\n  </mvc:interceptor>\n</mvc:interceptors>\n```\n","source":"_posts/20160511-SpringMVC拦截器Interceptor.md","raw":"---\ntitle: SpringMVC拦截器Interceptor\ndate: 2016-05-11 00:26:08\ncategories:\n- Java\ntags:\n- java\n- spring\n---\n\nSpringMVC拦截器是个非常好用的东西，对于每个请求有分别对进入控制器前、执行控制器后渲染之前、渲染之后的行为都能拦截。通常我们用拦截器实现了权限管理、MyBatis分页功能等。\n\n---\n\n- ### 实现`HandlerInterceptor`接口\n\n拦截器一般直接实现`HandlerInterceptor`接口，Spring也只处理该类型的拦截器。有些文章说也可以选择继承`HandlerInterceptorAdapter`抽象类，此方式我强烈不建议，不仅因为该类并不是严格的拦截器接口，也浪费了继承位置，并且`afterConcurrentHandlingStarted`方法在其实并没有什么卵用，Spring完全调用不到该方法。\n\n``` java\npublic class FuckInterceptor implements HandlerInterceptor {\n\n  //进入控制器之前执行,若为false,不执行控制器.\n  public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {\n\n      return true;\n  }\n\n  //出控制器后,若有新页面并未渲染之前执行\n  public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {\n\n  }\n\n  //整个请求结束之后\n  public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {\n\n  }\n}\n\n// ===============================================================\npublic abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor {\n}\n\npublic interface AsyncHandlerInterceptor extends HandlerInterceptor {\n  void afterConcurrentHandlingStarted(\n\t\t\tHttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception;\n}\n```\n\n- ### 实现`WebRequestInterceptor`接口\n\n其次还有实现`WebRequestInterceptor`接口的方式，为`WebRequest`已经封装`HttpServletRequest`的全部常用操作。但此类拦截器并不能让如上述拦截器一般，停止请求继续进行，所以通常只做请求的预备工作。\n\n``` java\npublic class FuckInterceptor implements WebRequestInterceptor {\n\n  //进入控制器之前执行.\n  public void preHandle(WebRequest request) throws Exception {}\n\n  //出控制器后,若有新页面并未渲染之前执行\n  public void postHandle(WebRequest request, ModelMap model) throws Exception {}\n\n  //整个请求结束之后\n  public void afterCompletion(WebRequest request, Exception ex) throws Exception {}\n}\n\npublic interface WebRequest extends RequestAttributes {\n\n\tString getHeader(String headerName);\n\n\tString[] getHeaderValues(String headerName);\n\n\tIterator<String> getHeaderNames();\n\n\tString getParameter(String paramName);\n\n\tString[] getParameterValues(String paramName);\n\n\tIterator<String> getParameterNames();\n\n\tMap<String, String[]> getParameterMap();\n\n\tLocale getLocale();\n\n\tString getContextPath();\n\n\tString getRemoteUser();\n\n\tPrincipal getUserPrincipal();\n\n\tboolean isUserInRole(String role);\n\n\tboolean isSecure();\n\n\tboolean checkNotModified(long lastModifiedTimestamp);\n\n\tboolean checkNotModified(String etag);\n\n\tboolean checkNotModified(String etag, long lastModifiedTimestamp);\n\n\tString getDescription(boolean includeClientInfo);\n\n}\n```\n\n- ### 配置拦截器\n\n引用标签\n``` xml\nxmlns:mvc=\"http://www.springframework.org/schema/mvc\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/mvc\n  http://www.springframework.org/schema/mvc/spring-mvc.xsd\"\n```\n\n配置拦截器\n``` xml\n<mvc:interceptors>\n  <!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 -->\n  <mvc:interceptor>\n    <mvc:mapping path=\"/fuck/**\"/>\n    <!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 -->\n    <bean class=\"com.bayes.interceptor.WechatInterceptor\"/>\n  </mvc:interceptor>\n</mvc:interceptors>\n```\n","slug":"20160511-SpringMVC拦截器Interceptor","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7s7000w4ejdh4chaaz4","content":"<p>SpringMVC拦截器是个非常好用的东西，对于每个请求有分别对进入控制器前、执行控制器后渲染之前、渲染之后的行为都能拦截。通常我们用拦截器实现了权限管理、MyBatis分页功能等。</p>\n<hr>\n<ul>\n<li><h3 id=\"实现HandlerInterceptor接口\"><a href=\"#实现HandlerInterceptor接口\" class=\"headerlink\" title=\"实现HandlerInterceptor接口\"></a>实现<code>HandlerInterceptor</code>接口</h3></li>\n</ul>\n<p>拦截器一般直接实现<code>HandlerInterceptor</code>接口，Spring也只处理该类型的拦截器。有些文章说也可以选择继承<code>HandlerInterceptorAdapter</code>抽象类，此方式我强烈不建议，不仅因为该类并不是严格的拦截器接口，也浪费了继承位置，并且<code>afterConcurrentHandlingStarted</code>方法在其实并没有什么卵用，Spring完全调用不到该方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FuckInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//进入控制器之前执行,若为false,不执行控制器.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//整个请求结束之后</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ===============================================================</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerInterceptorAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AsyncHandlerInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterConcurrentHandlingStarted</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tHttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"实现WebRequestInterceptor接口\"><a href=\"#实现WebRequestInterceptor接口\" class=\"headerlink\" title=\"实现WebRequestInterceptor接口\"></a>实现<code>WebRequestInterceptor</code>接口</h3></li>\n</ul>\n<p>其次还有实现<code>WebRequestInterceptor</code>接口的方式，为<code>WebRequest</code>已经封装<code>HttpServletRequest</code>的全部常用操作。但此类拦截器并不能让如上述拦截器一般，停止请求继续进行，所以通常只做请求的预备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FuckInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebRequestInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//进入控制器之前执行.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preHandle</span><span class=\"params\">(WebRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(WebRequest request, ModelMap model)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//整个请求结束之后</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(WebRequest request, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WebRequest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RequestAttributes</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getHeader</span><span class=\"params\">(String headerName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString[] getHeaderValues(String headerName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Iterator&lt;String&gt; <span class=\"title\">getHeaderNames</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getParameter</span><span class=\"params\">(String paramName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString[] getParameterValues(String paramName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Iterator&lt;String&gt; <span class=\"title\">getParameterNames</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMap&lt;String, String[]&gt; getParameterMap();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Locale <span class=\"title\">getLocale</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getContextPath</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getRemoteUser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Principal <span class=\"title\">getUserPrincipal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isUserInRole</span><span class=\"params\">(String role)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSecure</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(<span class=\"keyword\">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(String etag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(String etag, <span class=\"keyword\">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getDescription</span><span class=\"params\">(<span class=\"keyword\">boolean</span> includeClientInfo)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"配置拦截器\"><a href=\"#配置拦截器\" class=\"headerlink\" title=\"配置拦截器\"></a>配置拦截器</h3></li>\n</ul>\n<p>引用标签</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:mvc=\"http://www.springframework.org/schema/mvc\"</span><br><span class=\"line\">xsi:schemaLocation=\"http://www.springframework.org/schema/mvc</span><br><span class=\"line\">  http://www.springframework.org/schema/mvc/spring-mvc.xsd\"</span><br></pre></td></tr></table></figure>\n\n<p>配置拦截器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/fuck/**\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.bayes.interceptor.WechatInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>SpringMVC拦截器是个非常好用的东西，对于每个请求有分别对进入控制器前、执行控制器后渲染之前、渲染之后的行为都能拦截。通常我们用拦截器实现了权限管理、MyBatis分页功能等。</p>\n<hr>\n<ul>\n<li><h3 id=\"实现HandlerInterceptor接口\"><a href=\"#实现HandlerInterceptor接口\" class=\"headerlink\" title=\"实现HandlerInterceptor接口\"></a>实现<code>HandlerInterceptor</code>接口</h3></li>\n</ul>\n<p>拦截器一般直接实现<code>HandlerInterceptor</code>接口，Spring也只处理该类型的拦截器。有些文章说也可以选择继承<code>HandlerInterceptorAdapter</code>抽象类，此方式我强烈不建议，不仅因为该类并不是严格的拦截器接口，也浪费了继承位置，并且<code>afterConcurrentHandlingStarted</code>方法在其实并没有什么卵用，Spring完全调用不到该方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FuckInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//进入控制器之前执行,若为false,不执行控制器.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//整个请求结束之后</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ===============================================================</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerInterceptorAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AsyncHandlerInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterConcurrentHandlingStarted</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tHttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"实现WebRequestInterceptor接口\"><a href=\"#实现WebRequestInterceptor接口\" class=\"headerlink\" title=\"实现WebRequestInterceptor接口\"></a>实现<code>WebRequestInterceptor</code>接口</h3></li>\n</ul>\n<p>其次还有实现<code>WebRequestInterceptor</code>接口的方式，为<code>WebRequest</code>已经封装<code>HttpServletRequest</code>的全部常用操作。但此类拦截器并不能让如上述拦截器一般，停止请求继续进行，所以通常只做请求的预备工作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FuckInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebRequestInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//进入控制器之前执行.</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">preHandle</span><span class=\"params\">(WebRequest request)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//出控制器后,若有新页面并未渲染之前执行</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(WebRequest request, ModelMap model)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//整个请求结束之后</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(WebRequest request, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WebRequest</span> <span class=\"keyword\">extends</span> <span class=\"title\">RequestAttributes</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getHeader</span><span class=\"params\">(String headerName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString[] getHeaderValues(String headerName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Iterator&lt;String&gt; <span class=\"title\">getHeaderNames</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getParameter</span><span class=\"params\">(String paramName)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tString[] getParameterValues(String paramName);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Iterator&lt;String&gt; <span class=\"title\">getParameterNames</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tMap&lt;String, String[]&gt; getParameterMap();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Locale <span class=\"title\">getLocale</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getContextPath</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getRemoteUser</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">Principal <span class=\"title\">getUserPrincipal</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isUserInRole</span><span class=\"params\">(String role)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSecure</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(<span class=\"keyword\">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(String etag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">checkNotModified</span><span class=\"params\">(String etag, <span class=\"keyword\">long</span> lastModifiedTimestamp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">String <span class=\"title\">getDescription</span><span class=\"params\">(<span class=\"keyword\">boolean</span> includeClientInfo)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"配置拦截器\"><a href=\"#配置拦截器\" class=\"headerlink\" title=\"配置拦截器\"></a>配置拦截器</h3></li>\n</ul>\n<p>引用标签</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xmlns:mvc=\"http://www.springframework.org/schema/mvc\"</span><br><span class=\"line\">xsi:schemaLocation=\"http://www.springframework.org/schema/mvc</span><br><span class=\"line\">  http://www.springframework.org/schema/mvc/spring-mvc.xsd\"</span><br></pre></td></tr></table></figure>\n\n<p>配置拦截器</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mvc:mapping</span> <span class=\"attr\">path</span>=<span class=\"string\">\"/fuck/**\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.bayes.interceptor.WechatInterceptor\"</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptor</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式－装饰器模式","date":"2016-05-06T06:30:20.000Z","_content":"上一篇说到适配器模式，这次说它的同胞兄弟——装饰器模式。我们有时会遇到需要对类自身方法功能的累加，比如`FilterInputStream`需要`InputStream`其他子类的`read`上累加功能。\n\n---\n\n- ### 举例\n\n装饰器通常需要一个源，即你认为需要包装或基于此添加功能的类，源需要与装饰器同父类。\n\n如下代码，源`DecoratorTargetSource`被实例化时并不需要传入任何`DecoratorTarget`类型，而`Decorator1`、`Decorator2`、`Decorator3`等装饰类实例化时需要`DecoratorTarget`类型对象。\n\n``` java\n//基类（接口）\npublic interface DecoratorTarget {\n\tvoid read(byte[] bs);\n}\n//源基类\npublic class DecoratorTargetSource implements DecoratorTarget {\n\n\t@Override\n\tpublic void read(byte[] bs) {}\n\t\n}\n//源基类装饰器1\npublic class Decorator1 implements DecoratorTarget {\n\n\tprotected DecoratorTarget target;\n\tpublic Decorator1(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器2\npublic class Decorator2 implements DecoratorTarget {\n\t\n\tprotected DecoratorTarget target;\n\tpublic Decorator2(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器3\npublic class Decorator3 extends Decorator1 {\n\n\tpublic Decorator3(DecoratorTarget target) {\n\t\tsuper(target);\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n\npublic class DecoratorTemplate {\t\n\tpublic static void main(String[] args) {\n\t\tDecoratorTarget target = new Decorator1(new Decorator3(new Decorator2(new DecoratorTargetSource())));\n\t}\n}\n```\n\n\n- ### JDK中的装饰器模式\n\nJava中最为人所知的装饰器模式，莫过于IO框架。源码如下：\n\n``` java\n//基类\npublic abstract class InputStream implements Closeable {\n\t//...\n}\n//装饰器FilterInputStream\npublic class FilterInputStream extends InputStream {\n\tprotected volatile InputStream in;\n\tprotected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n}\n//装饰器BufferedInputStream，继承于FilterInputStream\npublic class BufferedInputStream extends FilterInputStream {\n\tprivate InputStream getInIfOpen() throws IOException {\n\t\tInputStream input = in;\n\t\tif (input == null)\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\treturn input;\n\t}\n    \n\tprivate void fill() throws IOException {\n\t\t// ...\n\t\tint n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n\t\t// ...\n\t}\n    \n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n}\n//源\npublic class FileInputStream extends InputStream {\n\tpublic FileInputStream(String name) throws FileNotFoundException {\n        this(name != null ? new File(name) : null);\n    }\n    public FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n    }\n    public FileInputStream(FileDescriptor fdObj) {\n        SecurityManager security = System.getSecurityManager();\n        if (fdObj == null) {\n            throw new NullPointerException();\n        }\n        if (security != null) {\n            security.checkRead(fdObj);\n        }\n        fd = fdObj;\n        path = null;\n        fd.incrementAndGetUseCount();\n    }\n}\n```\n\n上述源码中，`FileInputStream`并没有参数包含`InputStream`类型，所以可以看成是一个源，那么`FilterInputStream`及其子类`BufferedInputStream`则是装饰器。\n\n\n","source":"_posts/20160506-设计模式－装饰者模式.md","raw":"---\ntitle: 设计模式－装饰器模式\ndate: 2016-05-06 14:30:20\ncategories: \n- 设计模式\ntags: \n- java\n- 设计模式\n---\n上一篇说到适配器模式，这次说它的同胞兄弟——装饰器模式。我们有时会遇到需要对类自身方法功能的累加，比如`FilterInputStream`需要`InputStream`其他子类的`read`上累加功能。\n\n---\n\n- ### 举例\n\n装饰器通常需要一个源，即你认为需要包装或基于此添加功能的类，源需要与装饰器同父类。\n\n如下代码，源`DecoratorTargetSource`被实例化时并不需要传入任何`DecoratorTarget`类型，而`Decorator1`、`Decorator2`、`Decorator3`等装饰类实例化时需要`DecoratorTarget`类型对象。\n\n``` java\n//基类（接口）\npublic interface DecoratorTarget {\n\tvoid read(byte[] bs);\n}\n//源基类\npublic class DecoratorTargetSource implements DecoratorTarget {\n\n\t@Override\n\tpublic void read(byte[] bs) {}\n\t\n}\n//源基类装饰器1\npublic class Decorator1 implements DecoratorTarget {\n\n\tprotected DecoratorTarget target;\n\tpublic Decorator1(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器2\npublic class Decorator2 implements DecoratorTarget {\n\t\n\tprotected DecoratorTarget target;\n\tpublic Decorator2(DecoratorTarget target) {\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n//源基类装饰器3\npublic class Decorator3 extends Decorator1 {\n\n\tpublic Decorator3(DecoratorTarget target) {\n\t\tsuper(target);\n\t\tthis.target = target;\n\t}\n\t@Override\n\tpublic void read(byte[] bs) {\n\t\t// ...\n\t\ttarget.read(bs);\n\t\t// ...\n\t}\n\t\n}\n\npublic class DecoratorTemplate {\t\n\tpublic static void main(String[] args) {\n\t\tDecoratorTarget target = new Decorator1(new Decorator3(new Decorator2(new DecoratorTargetSource())));\n\t}\n}\n```\n\n\n- ### JDK中的装饰器模式\n\nJava中最为人所知的装饰器模式，莫过于IO框架。源码如下：\n\n``` java\n//基类\npublic abstract class InputStream implements Closeable {\n\t//...\n}\n//装饰器FilterInputStream\npublic class FilterInputStream extends InputStream {\n\tprotected volatile InputStream in;\n\tprotected FilterInputStream(InputStream in) {\n        this.in = in;\n    }\n}\n//装饰器BufferedInputStream，继承于FilterInputStream\npublic class BufferedInputStream extends FilterInputStream {\n\tprivate InputStream getInIfOpen() throws IOException {\n\t\tInputStream input = in;\n\t\tif (input == null)\n\t\t\tthrow new IOException(\"Stream closed\");\n\t\treturn input;\n\t}\n    \n\tprivate void fill() throws IOException {\n\t\t// ...\n\t\tint n = getInIfOpen().read(buffer, pos, buffer.length - pos);\n\t\t// ...\n\t}\n    \n    public synchronized int read() throws IOException {\n        if (pos >= count) {\n            fill();\n            if (pos >= count)\n                return -1;\n        }\n        return getBufIfOpen()[pos++] & 0xff;\n    }\n}\n//源\npublic class FileInputStream extends InputStream {\n\tpublic FileInputStream(String name) throws FileNotFoundException {\n        this(name != null ? new File(name) : null);\n    }\n    public FileInputStream(File file) throws FileNotFoundException {\n        String name = (file != null ? file.getPath() : null);\n        SecurityManager security = System.getSecurityManager();\n        if (security != null) {\n            security.checkRead(name);\n        }\n        if (name == null) {\n            throw new NullPointerException();\n        }\n        if (file.isInvalid()) {\n            throw new FileNotFoundException(\"Invalid file path\");\n        }\n        fd = new FileDescriptor();\n        fd.incrementAndGetUseCount();\n        this.path = name;\n        open(name);\n    }\n    public FileInputStream(FileDescriptor fdObj) {\n        SecurityManager security = System.getSecurityManager();\n        if (fdObj == null) {\n            throw new NullPointerException();\n        }\n        if (security != null) {\n            security.checkRead(fdObj);\n        }\n        fd = fdObj;\n        path = null;\n        fd.incrementAndGetUseCount();\n    }\n}\n```\n\n上述源码中，`FileInputStream`并没有参数包含`InputStream`类型，所以可以看成是一个源，那么`FilterInputStream`及其子类`BufferedInputStream`则是装饰器。\n\n\n","slug":"20160506-设计模式－装饰者模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7s900104ejddk2g9vy5","content":"<p>上一篇说到适配器模式，这次说它的同胞兄弟——装饰器模式。我们有时会遇到需要对类自身方法功能的累加，比如<code>FilterInputStream</code>需要<code>InputStream</code>其他子类的<code>read</code>上累加功能。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>装饰器通常需要一个源，即你认为需要包装或基于此添加功能的类，源需要与装饰器同父类。</p>\n<p>如下代码，源<code>DecoratorTargetSource</code>被实例化时并不需要传入任何<code>DecoratorTarget</code>类型，而<code>Decorator1</code>、<code>Decorator2</code>、<code>Decorator3</code>等装饰类实例化时需要<code>DecoratorTarget</code>类型对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类（接口）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTargetSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator1</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator1</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator2</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator2</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Decorator1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator3</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(target);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTemplate</span> </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDecoratorTarget target = <span class=\"keyword\">new</span> Decorator1(<span class=\"keyword\">new</span> Decorator3(<span class=\"keyword\">new</span> Decorator2(<span class=\"keyword\">new</span> DecoratorTargetSource())));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"JDK中的装饰器模式\"><a href=\"#JDK中的装饰器模式\" class=\"headerlink\" title=\"JDK中的装饰器模式\"></a>JDK中的装饰器模式</h3></li>\n</ul>\n<p>Java中最为人所知的装饰器模式，莫过于IO框架。源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//装饰器FilterInputStream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">FilterInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//装饰器BufferedInputStream，继承于FilterInputStream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">FilterInputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> InputStream <span class=\"title\">getInIfOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\tInputStream input = in;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Stream closed\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> input;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &gt;= count) &#123;</span><br><span class=\"line\">            fill();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= count)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBufIfOpen()[pos++] &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> File(name) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = name;</span><br><span class=\"line\">        open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fdObj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(fdObj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = fdObj;</span><br><span class=\"line\">        path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述源码中，<code>FileInputStream</code>并没有参数包含<code>InputStream</code>类型，所以可以看成是一个源，那么<code>FilterInputStream</code>及其子类<code>BufferedInputStream</code>则是装饰器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上一篇说到适配器模式，这次说它的同胞兄弟——装饰器模式。我们有时会遇到需要对类自身方法功能的累加，比如<code>FilterInputStream</code>需要<code>InputStream</code>其他子类的<code>read</code>上累加功能。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>装饰器通常需要一个源，即你认为需要包装或基于此添加功能的类，源需要与装饰器同父类。</p>\n<p>如下代码，源<code>DecoratorTargetSource</code>被实例化时并不需要传入任何<code>DecoratorTarget</code>类型，而<code>Decorator1</code>、<code>Decorator2</code>、<code>Decorator3</code>等装饰类实例化时需要<code>DecoratorTarget</code>类型对象。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类（接口）</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTargetSource</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator1</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator1</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator2</span> <span class=\"keyword\">implements</span> <span class=\"title\">DecoratorTarget</span> </span>&#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> DecoratorTarget target;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator2</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源基类装饰器3</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Decorator3</span> <span class=\"keyword\">extends</span> <span class=\"title\">Decorator1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Decorator3</span><span class=\"params\">(DecoratorTarget target)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>(target);</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">byte</span>[] bs)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\ttarget.read(bs);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecoratorTemplate</span> </span>&#123;\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDecoratorTarget target = <span class=\"keyword\">new</span> Decorator1(<span class=\"keyword\">new</span> Decorator3(<span class=\"keyword\">new</span> Decorator2(<span class=\"keyword\">new</span> DecoratorTargetSource())));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"JDK中的装饰器模式\"><a href=\"#JDK中的装饰器模式\" class=\"headerlink\" title=\"JDK中的装饰器模式\"></a>JDK中的装饰器模式</h3></li>\n</ul>\n<p>Java中最为人所知的装饰器模式，莫过于IO框架。源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputStream</span> <span class=\"keyword\">implements</span> <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//装饰器FilterInputStream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FilterInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">protected</span> <span class=\"keyword\">volatile</span> InputStream in;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">FilterInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//装饰器BufferedInputStream，继承于FilterInputStream</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BufferedInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">FilterInputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> InputStream <span class=\"title\">getInIfOpen</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\tInputStream input = in;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IOException(<span class=\"string\">\"Stream closed\"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> input;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">fill</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class=\"line\">\t\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &gt;= count) &#123;</span><br><span class=\"line\">            fill();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= count)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getBufIfOpen()[pos++] &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//源</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileInputStream</span> <span class=\"keyword\">extends</span> <span class=\"title\">InputStream</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>(name != <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> File(name) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(File file)</span> <span class=\"keyword\">throws</span> FileNotFoundException </span>&#123;</span><br><span class=\"line\">        String name = (file != <span class=\"keyword\">null</span> ? file.getPath() : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (file.isInvalid()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> FileNotFoundException(<span class=\"string\">\"Invalid file path\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = name;</span><br><span class=\"line\">        open(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileInputStream</span><span class=\"params\">(FileDescriptor fdObj)</span> </span>&#123;</span><br><span class=\"line\">        SecurityManager security = System.getSecurityManager();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fdObj == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (security != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            security.checkRead(fdObj);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fd = fdObj;</span><br><span class=\"line\">        path = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        fd.incrementAndGetUseCount();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述源码中，<code>FileInputStream</code>并没有参数包含<code>InputStream</code>类型，所以可以看成是一个源，那么<code>FilterInputStream</code>及其子类<code>BufferedInputStream</code>则是装饰器。</p>\n"},{"title":"设计模式－观察者模式","date":"2016-05-11T16:34:55.000Z","_content":"\n业务总会有环环相扣的联动，一环变化会引发后续环的变动。一个对象的变化，可能会引发一个或多个对象的变化，今天我就要说的能引用此种场景的设计模式——观察者模式。\n\n---\n\n- ### 举例\n\n说实在话，观察者模式只是比较直观的手段——“注册—通知—注销”，响应某个对象变化的手段并不止如此。并且，我对该模式的某个小细节一直存在疑惑，下面会说到。\n\n先给出一个模版。\n``` java\n//主题消息实体\nclass SubjectEntity {\n\tprivate String code;\n\tprivate String name;\n\tprivate String observerName;\n\tpublic SubjectEntity(String code, String name) {\n\t\tsuper();\n\t\tthis.code = code;\n\t\tthis.name = name;\n\t}\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getObserverName() {\n\t\treturn observerName;\n\t}\n\tpublic void setObserverName(String observerName) {\n\t\tthis.observerName = observerName;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubjectEntity [code=\" + code + \", name=\" + name + \", observerName=\" + observerName + \"]\";\n\t}\n}\n//被观察者\nabstract class Subject {\n\n\tprivate List<Observer> observers = new ArrayList<Observer>();\n\n\tpublic void addObserver(Observer observer) {\n\t\tobservers.add(observer);\n\t}\n\n\tpublic void removeObserver(Observer observer) {\n\t\tobservers.remove(observer);\n\t}\n\n\tpublic void notifyObserver(SubjectEntity entity) {\n\t\tfor(Observer observer : observers) {\n\t\t\tobserver.update(entity);\n\t\t}\n\t}\n\n}\n\nclass SimpleSubject extends Subject {\n\tpublic void action(SubjectEntity entity) {\n\t\tentity.setName(\"fuck dick!!!\");\n\t\tnotifyObserver(entity);\n\t}\n}\n//观察者\ninterface Observer {\n\tpublic void update(SubjectEntity entity);\n}\n\nclass SimpleObserver implements Observer {\n\n\t@Override\n\tpublic void update(SubjectEntity entity) {\n\t\tSystem.out.println(entity);\n\t}\n\n}\n```\n\n我这里把`SubjectEntity`类作为消息的全部，最后也是把该对象传递到`notifyObserver(SubjectEntity entity)`方法。\n\n``` java\npublic class ObserverPattern {\n\tpublic static void main(String[] args) {\n\t\tSimpleSubject subject = new SimpleSubject();\n\t\tsubject.addObserver(new SimpleObserver());\n\t\tsubject.addObserver(new SimpleObserver());\n\t\tsubject.action(new SubjectEntity(\"001\", \"001\"));\n\t\tsubject.action(new SubjectEntity(\"002\", \"001\"));\n\t}\n}\n```\n\n- ### 我的疑惑\n\n假设我传递消息是被观察者本身的话，又如何？即\n``` java\ninterface Observer {\n\tpublic void update(Subject subject);\n}\n```\n\n`Subject`类的通知方法当然要更改\n``` java\npublic void notifyObserver(Subject subject) {\n\tfor(Observer observer : observers) {\n\t\tobserver.update(subject);\n\t}\n}\n```\n\n于是乎，当我们实现`update(Subject subject)`时，就有可能出现这种情况。\n``` java\n@Override\npublic void update(Subject subject) {\n\tsubject.notifyObserver(subject);\n}\n```\n👿👿👿👿👿这让我情何以堪？？？？\n","source":"_posts/20160512-设计模式－观察者模式.md","raw":"---\ntitle: 设计模式－观察者模式\ndate: 2016-05-12 00:34:55\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n\n业务总会有环环相扣的联动，一环变化会引发后续环的变动。一个对象的变化，可能会引发一个或多个对象的变化，今天我就要说的能引用此种场景的设计模式——观察者模式。\n\n---\n\n- ### 举例\n\n说实在话，观察者模式只是比较直观的手段——“注册—通知—注销”，响应某个对象变化的手段并不止如此。并且，我对该模式的某个小细节一直存在疑惑，下面会说到。\n\n先给出一个模版。\n``` java\n//主题消息实体\nclass SubjectEntity {\n\tprivate String code;\n\tprivate String name;\n\tprivate String observerName;\n\tpublic SubjectEntity(String code, String name) {\n\t\tsuper();\n\t\tthis.code = code;\n\t\tthis.name = name;\n\t}\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getObserverName() {\n\t\treturn observerName;\n\t}\n\tpublic void setObserverName(String observerName) {\n\t\tthis.observerName = observerName;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"SubjectEntity [code=\" + code + \", name=\" + name + \", observerName=\" + observerName + \"]\";\n\t}\n}\n//被观察者\nabstract class Subject {\n\n\tprivate List<Observer> observers = new ArrayList<Observer>();\n\n\tpublic void addObserver(Observer observer) {\n\t\tobservers.add(observer);\n\t}\n\n\tpublic void removeObserver(Observer observer) {\n\t\tobservers.remove(observer);\n\t}\n\n\tpublic void notifyObserver(SubjectEntity entity) {\n\t\tfor(Observer observer : observers) {\n\t\t\tobserver.update(entity);\n\t\t}\n\t}\n\n}\n\nclass SimpleSubject extends Subject {\n\tpublic void action(SubjectEntity entity) {\n\t\tentity.setName(\"fuck dick!!!\");\n\t\tnotifyObserver(entity);\n\t}\n}\n//观察者\ninterface Observer {\n\tpublic void update(SubjectEntity entity);\n}\n\nclass SimpleObserver implements Observer {\n\n\t@Override\n\tpublic void update(SubjectEntity entity) {\n\t\tSystem.out.println(entity);\n\t}\n\n}\n```\n\n我这里把`SubjectEntity`类作为消息的全部，最后也是把该对象传递到`notifyObserver(SubjectEntity entity)`方法。\n\n``` java\npublic class ObserverPattern {\n\tpublic static void main(String[] args) {\n\t\tSimpleSubject subject = new SimpleSubject();\n\t\tsubject.addObserver(new SimpleObserver());\n\t\tsubject.addObserver(new SimpleObserver());\n\t\tsubject.action(new SubjectEntity(\"001\", \"001\"));\n\t\tsubject.action(new SubjectEntity(\"002\", \"001\"));\n\t}\n}\n```\n\n- ### 我的疑惑\n\n假设我传递消息是被观察者本身的话，又如何？即\n``` java\ninterface Observer {\n\tpublic void update(Subject subject);\n}\n```\n\n`Subject`类的通知方法当然要更改\n``` java\npublic void notifyObserver(Subject subject) {\n\tfor(Observer observer : observers) {\n\t\tobserver.update(subject);\n\t}\n}\n```\n\n于是乎，当我们实现`update(Subject subject)`时，就有可能出现这种情况。\n``` java\n@Override\npublic void update(Subject subject) {\n\tsubject.notifyObserver(subject);\n}\n```\n👿👿👿👿👿这让我情何以堪？？？？\n","slug":"20160512-设计模式－观察者模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sa00114ejd6osx9dmq","content":"<p>业务总会有环环相扣的联动，一环变化会引发后续环的变动。一个对象的变化，可能会引发一个或多个对象的变化，今天我就要说的能引用此种场景的设计模式——观察者模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>说实在话，观察者模式只是比较直观的手段——“注册—通知—注销”，响应某个对象变化的手段并不止如此。并且，我对该模式的某个小细节一直存在疑惑，下面会说到。</p>\n<p>先给出一个模版。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主题消息实体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectEntity</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String code;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String observerName;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SubjectEntity</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> code;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCode</span><span class=\"params\">(String code)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getObserverName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> observerName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObserverName</span><span class=\"params\">(String observerName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.observerName = observerName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"SubjectEntity [code=\"</span> + code + <span class=\"string\">\", name=\"</span> + name + <span class=\"string\">\", observerName=\"</span> + observerName + <span class=\"string\">\"]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被观察者</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.add(observer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.remove(observer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">\t\t\tobserver.update(entity);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleSubject</span> <span class=\"keyword\">extends</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\tentity.setName(<span class=\"string\">\"fuck dick!!!\"</span>);</span><br><span class=\"line\">\t\tnotifyObserver(entity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//观察者</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(SubjectEntity entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(entity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这里把<code>SubjectEntity</code>类作为消息的全部，最后也是把该对象传递到<code>notifyObserver(SubjectEntity entity)</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverPattern</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSimpleSubject subject = <span class=\"keyword\">new</span> SimpleSubject();</span><br><span class=\"line\">\t\tsubject.addObserver(<span class=\"keyword\">new</span> SimpleObserver());</span><br><span class=\"line\">\t\tsubject.addObserver(<span class=\"keyword\">new</span> SimpleObserver());</span><br><span class=\"line\">\t\tsubject.action(<span class=\"keyword\">new</span> SubjectEntity(<span class=\"string\">\"001\"</span>, <span class=\"string\">\"001\"</span>));</span><br><span class=\"line\">\t\tsubject.action(<span class=\"keyword\">new</span> SubjectEntity(<span class=\"string\">\"002\"</span>, <span class=\"string\">\"001\"</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"我的疑惑\"><a href=\"#我的疑惑\" class=\"headerlink\" title=\"我的疑惑\"></a>我的疑惑</h3></li>\n</ul>\n<p>假设我传递消息是被观察者本身的话，又如何？即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Subject subject)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Subject</code>类的通知方法当然要更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(Subject subject)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">\t\tobserver.update(subject);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是乎，当我们实现<code>update(Subject subject)</code>时，就有可能出现这种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Subject subject)</span> </span>&#123;</span><br><span class=\"line\">\tsubject.notifyObserver(subject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👿👿👿👿👿这让我情何以堪？？？？</p>\n","site":{"data":{}},"excerpt":"","more":"<p>业务总会有环环相扣的联动，一环变化会引发后续环的变动。一个对象的变化，可能会引发一个或多个对象的变化，今天我就要说的能引用此种场景的设计模式——观察者模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>说实在话，观察者模式只是比较直观的手段——“注册—通知—注销”，响应某个对象变化的手段并不止如此。并且，我对该模式的某个小细节一直存在疑惑，下面会说到。</p>\n<p>先给出一个模版。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//主题消息实体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubjectEntity</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String code;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String observerName;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SubjectEntity</span><span class=\"params\">(String code, String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> code;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setCode</span><span class=\"params\">(String code)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.code = code;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getObserverName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> observerName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setObserverName</span><span class=\"params\">(String observerName)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.observerName = observerName;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"SubjectEntity [code=\"</span> + code + <span class=\"string\">\", name=\"</span> + name + <span class=\"string\">\", observerName=\"</span> + observerName + <span class=\"string\">\"]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//被观察者</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;Observer&gt; observers = <span class=\"keyword\">new</span> ArrayList&lt;Observer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.add(observer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer observer)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.remove(observer);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">\t\t\tobserver.update(entity);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleSubject</span> <span class=\"keyword\">extends</span> <span class=\"title\">Subject</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">action</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\tentity.setName(<span class=\"string\">\"fuck dick!!!\"</span>);</span><br><span class=\"line\">\t\tnotifyObserver(entity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//观察者</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(SubjectEntity entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleObserver</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(SubjectEntity entity)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(entity);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我这里把<code>SubjectEntity</code>类作为消息的全部，最后也是把该对象传递到<code>notifyObserver(SubjectEntity entity)</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserverPattern</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSimpleSubject subject = <span class=\"keyword\">new</span> SimpleSubject();</span><br><span class=\"line\">\t\tsubject.addObserver(<span class=\"keyword\">new</span> SimpleObserver());</span><br><span class=\"line\">\t\tsubject.addObserver(<span class=\"keyword\">new</span> SimpleObserver());</span><br><span class=\"line\">\t\tsubject.action(<span class=\"keyword\">new</span> SubjectEntity(<span class=\"string\">\"001\"</span>, <span class=\"string\">\"001\"</span>));</span><br><span class=\"line\">\t\tsubject.action(<span class=\"keyword\">new</span> SubjectEntity(<span class=\"string\">\"002\"</span>, <span class=\"string\">\"001\"</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"我的疑惑\"><a href=\"#我的疑惑\" class=\"headerlink\" title=\"我的疑惑\"></a>我的疑惑</h3></li>\n</ul>\n<p>假设我传递消息是被观察者本身的话，又如何？即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Subject subject)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Subject</code>类的通知方法当然要更改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">(Subject subject)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Observer observer : observers) &#123;</span><br><span class=\"line\">\t\tobserver.update(subject);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>于是乎，当我们实现<code>update(Subject subject)</code>时，就有可能出现这种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(Subject subject)</span> </span>&#123;</span><br><span class=\"line\">\tsubject.notifyObserver(subject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>👿👿👿👿👿这让我情何以堪？？？？</p>\n"},{"title":"设计模式－职责链模式","date":"2016-05-14T18:30:45.000Z","_content":"\n我们总有请假的时候，每个单位可能制度都不一样，但都对请假时间长短有规定不同流程。例如0.5-1天假向经理报告，2-3天假向hr报告，3以上的假期需总经理或老板签字等等。既然有这种状况，程序也务必会遇到此类情况，要说的就是处理此类问题时可能用到的设计模式——职责链模式。\n\n---\n\n- ### 举例\n\n示例，当前我有个请假的请求发送至上司，≤5天由`SimpleRequestHandler`处理，反之，`SpecialRequestHandler`处理。\n\n``` java\n//请求\nclass Request {\n\tprivate String name;\n\tprivate int day;\n\tpublic Request(String name, int day) {\n\t\tthis.name = name;\n\t\tthis.day = day;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getDay() {\n\t\treturn day;\n\t}\n\tpublic void setDay(int day) {\n\t\tthis.day = day;\n\t}\n}\n\n//处理器抽象类\nabstract class Handler {\n\tprivate Handler successor;\n\tpublic Handler getSuccessor() {\n\t\treturn successor;\n\t}\n\tpublic void setSuccessor(Handler successor) {\n\t\tthis.successor = successor;\n\t}\n\tabstract String handle(Request request);\n}\n\n//简易请求处理器\nclass SimpleRequestHandler extends Handler {\n\t@Override\n\tpublic String handle(Request request) {\n    //加强健壮性，防止没有后续处理器而报空指针\n\t\tif(request.getDay() < 5 && getSuccessor() != null) {\n\t\t\treturn getSuccessor().handle(request);\n\t\t}\n\t\treturn request.getName() + \"请≤5天假\t>>>>>\t批准\";\n\t}\n}\n\n//特殊请求处理器\nclass SpecialRequestHandler extends Handler {\n\t@Override\n\tpublic String handle(Request request) {\n\t\treturn request.getName() + \"请≥5天假\t>>>>>\t批准\";\n\t}\n}\n\npublic class ChainOfResponsibility {\n\tpublic static void main(String[] args) {\n    //TOM请≤5天假\t>>>>>\t批准\n\t\tRequest request = new Request(\"TOM\", 1);\n    //TIM请≥5天假\t>>>>>\t批准\n    Request request = new Request(\"TIM\", 11);\n\n\t\tHandler handler = new SimpleRequestHandler();\n\t\thandler.setSuccessor(new SpecialRequestHandler());\n\t\tSystem.out.println(handler.handle(request));\n\t}\n}\n```\n\n有上面main方法的三句代码可见的，对于每个请求来说，只需要面对一个处理器即可，大大的降低请求与处理的耦合。除此之外，也能让每个处理器有机会处理请求。\n``` java\nHandler handler = new SimpleRequestHandler();\nhandler.setSuccessor(new SpecialRequestHandler());\nhandler.handle(new Request(\"TOM\", 1));\n```\n\n- ### JDK中的职责链模式\n\n# doFilter没能完全看懂，看懂了再来补偿\n","source":"_posts/20160515-设计模式－职责链模式.md","raw":"---\ntitle: 设计模式－职责链模式\ndate: 2016-05-15 02:30:45\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n\n我们总有请假的时候，每个单位可能制度都不一样，但都对请假时间长短有规定不同流程。例如0.5-1天假向经理报告，2-3天假向hr报告，3以上的假期需总经理或老板签字等等。既然有这种状况，程序也务必会遇到此类情况，要说的就是处理此类问题时可能用到的设计模式——职责链模式。\n\n---\n\n- ### 举例\n\n示例，当前我有个请假的请求发送至上司，≤5天由`SimpleRequestHandler`处理，反之，`SpecialRequestHandler`处理。\n\n``` java\n//请求\nclass Request {\n\tprivate String name;\n\tprivate int day;\n\tpublic Request(String name, int day) {\n\t\tthis.name = name;\n\t\tthis.day = day;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getDay() {\n\t\treturn day;\n\t}\n\tpublic void setDay(int day) {\n\t\tthis.day = day;\n\t}\n}\n\n//处理器抽象类\nabstract class Handler {\n\tprivate Handler successor;\n\tpublic Handler getSuccessor() {\n\t\treturn successor;\n\t}\n\tpublic void setSuccessor(Handler successor) {\n\t\tthis.successor = successor;\n\t}\n\tabstract String handle(Request request);\n}\n\n//简易请求处理器\nclass SimpleRequestHandler extends Handler {\n\t@Override\n\tpublic String handle(Request request) {\n    //加强健壮性，防止没有后续处理器而报空指针\n\t\tif(request.getDay() < 5 && getSuccessor() != null) {\n\t\t\treturn getSuccessor().handle(request);\n\t\t}\n\t\treturn request.getName() + \"请≤5天假\t>>>>>\t批准\";\n\t}\n}\n\n//特殊请求处理器\nclass SpecialRequestHandler extends Handler {\n\t@Override\n\tpublic String handle(Request request) {\n\t\treturn request.getName() + \"请≥5天假\t>>>>>\t批准\";\n\t}\n}\n\npublic class ChainOfResponsibility {\n\tpublic static void main(String[] args) {\n    //TOM请≤5天假\t>>>>>\t批准\n\t\tRequest request = new Request(\"TOM\", 1);\n    //TIM请≥5天假\t>>>>>\t批准\n    Request request = new Request(\"TIM\", 11);\n\n\t\tHandler handler = new SimpleRequestHandler();\n\t\thandler.setSuccessor(new SpecialRequestHandler());\n\t\tSystem.out.println(handler.handle(request));\n\t}\n}\n```\n\n有上面main方法的三句代码可见的，对于每个请求来说，只需要面对一个处理器即可，大大的降低请求与处理的耦合。除此之外，也能让每个处理器有机会处理请求。\n``` java\nHandler handler = new SimpleRequestHandler();\nhandler.setSuccessor(new SpecialRequestHandler());\nhandler.handle(new Request(\"TOM\", 1));\n```\n\n- ### JDK中的职责链模式\n\n# doFilter没能完全看懂，看懂了再来补偿\n","slug":"20160515-设计模式－职责链模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sb00154ejdfrdpfn7u","content":"<p>我们总有请假的时候，每个单位可能制度都不一样，但都对请假时间长短有规定不同流程。例如0.5-1天假向经理报告，2-3天假向hr报告，3以上的假期需总经理或老板签字等等。既然有这种状况，程序也务必会遇到此类情况，要说的就是处理此类问题时可能用到的设计模式——职责链模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>示例，当前我有个请假的请求发送至上司，≤5天由<code>SimpleRequestHandler</code>处理，反之，<code>SpecialRequestHandler</code>处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Request</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> day;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> day)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.day = day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDay</span><span class=\"params\">(<span class=\"keyword\">int</span> day)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.day = day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//处理器抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Handler successor;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Handler <span class=\"title\">getSuccessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> successor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSuccessor</span><span class=\"params\">(Handler successor)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.successor = successor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">abstract</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//简易请求处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRequestHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加强健壮性，防止没有后续处理器而报空指针</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(request.getDay() &lt; <span class=\"number\">5</span> &amp;&amp; getSuccessor() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getSuccessor().handle(request);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> request.getName() + <span class=\"string\">\"请≤5天假\t&gt;&gt;&gt;&gt;&gt;\t批准\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//特殊请求处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpecialRequestHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> request.getName() + <span class=\"string\">\"请≥5天假\t&gt;&gt;&gt;&gt;&gt;\t批准\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChainOfResponsibility</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TOM请≤5天假\t&gt;&gt;&gt;&gt;&gt;\t批准</span></span><br><span class=\"line\">\t\tRequest request = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"TOM\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//TIM请≥5天假\t&gt;&gt;&gt;&gt;&gt;\t批准</span></span><br><span class=\"line\">    Request request = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"TIM\"</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHandler handler = <span class=\"keyword\">new</span> SimpleRequestHandler();</span><br><span class=\"line\">\t\thandler.setSuccessor(<span class=\"keyword\">new</span> SpecialRequestHandler());</span><br><span class=\"line\">\t\tSystem.out.println(handler.handle(request));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有上面main方法的三句代码可见的，对于每个请求来说，只需要面对一个处理器即可，大大的降低请求与处理的耦合。除此之外，也能让每个处理器有机会处理请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler handler = <span class=\"keyword\">new</span> SimpleRequestHandler();</span><br><span class=\"line\">handler.setSuccessor(<span class=\"keyword\">new</span> SpecialRequestHandler());</span><br><span class=\"line\">handler.handle(<span class=\"keyword\">new</span> Request(<span class=\"string\">\"TOM\"</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的职责链模式\"><a href=\"#JDK中的职责链模式\" class=\"headerlink\" title=\"JDK中的职责链模式\"></a>JDK中的职责链模式</h3></li>\n</ul>\n<h1 id=\"doFilter没能完全看懂，看懂了再来补偿\"><a href=\"#doFilter没能完全看懂，看懂了再来补偿\" class=\"headerlink\" title=\"doFilter没能完全看懂，看懂了再来补偿\"></a>doFilter没能完全看懂，看懂了再来补偿</h1>","site":{"data":{}},"excerpt":"","more":"<p>我们总有请假的时候，每个单位可能制度都不一样，但都对请假时间长短有规定不同流程。例如0.5-1天假向经理报告，2-3天假向hr报告，3以上的假期需总经理或老板签字等等。既然有这种状况，程序也务必会遇到此类情况，要说的就是处理此类问题时可能用到的设计模式——职责链模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>示例，当前我有个请假的请求发送至上司，≤5天由<code>SimpleRequestHandler</code>处理，反之，<code>SpecialRequestHandler</code>处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//请求</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Request</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> day;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Request</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> day)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.day = day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getDay</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDay</span><span class=\"params\">(<span class=\"keyword\">int</span> day)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.day = day;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//处理器抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Handler successor;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Handler <span class=\"title\">getSuccessor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> successor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSuccessor</span><span class=\"params\">(Handler successor)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.successor = successor;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">abstract</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//简易请求处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleRequestHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//加强健壮性，防止没有后续处理器而报空指针</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(request.getDay() &lt; <span class=\"number\">5</span> &amp;&amp; getSuccessor() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getSuccessor().handle(request);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> request.getName() + <span class=\"string\">\"请≤5天假\t&gt;&gt;&gt;&gt;&gt;\t批准\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//特殊请求处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpecialRequestHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Handler</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handle</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> request.getName() + <span class=\"string\">\"请≥5天假\t&gt;&gt;&gt;&gt;&gt;\t批准\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChainOfResponsibility</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TOM请≤5天假\t&gt;&gt;&gt;&gt;&gt;\t批准</span></span><br><span class=\"line\">\t\tRequest request = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"TOM\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//TIM请≥5天假\t&gt;&gt;&gt;&gt;&gt;\t批准</span></span><br><span class=\"line\">    Request request = <span class=\"keyword\">new</span> Request(<span class=\"string\">\"TIM\"</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tHandler handler = <span class=\"keyword\">new</span> SimpleRequestHandler();</span><br><span class=\"line\">\t\thandler.setSuccessor(<span class=\"keyword\">new</span> SpecialRequestHandler());</span><br><span class=\"line\">\t\tSystem.out.println(handler.handle(request));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有上面main方法的三句代码可见的，对于每个请求来说，只需要面对一个处理器即可，大大的降低请求与处理的耦合。除此之外，也能让每个处理器有机会处理请求。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Handler handler = <span class=\"keyword\">new</span> SimpleRequestHandler();</span><br><span class=\"line\">handler.setSuccessor(<span class=\"keyword\">new</span> SpecialRequestHandler());</span><br><span class=\"line\">handler.handle(<span class=\"keyword\">new</span> Request(<span class=\"string\">\"TOM\"</span>, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的职责链模式\"><a href=\"#JDK中的职责链模式\" class=\"headerlink\" title=\"JDK中的职责链模式\"></a>JDK中的职责链模式</h3></li>\n</ul>\n<h1 id=\"doFilter没能完全看懂，看懂了再来补偿\"><a href=\"#doFilter没能完全看懂，看懂了再来补偿\" class=\"headerlink\" title=\"doFilter没能完全看懂，看懂了再来补偿\"></a>doFilter没能完全看懂，看懂了再来补偿</h1>"},{"title":"设计模式－状态模式","date":"2016-05-20T06:18:28.000Z","_content":"现实生活中，操作某一固定事物，可能会触发不同状态，例如电灯的开关。代码中也用相类似的情况，调用某对象的同一方法或多个方法，会触发对象内部的某个状态，而这个状态会影响你下一步可能调用的方法。我们这一次就讲讲状态模式。\n\n---\n\n- ### 举例\n\n我们的上下文`Light`类有`click()`方法，可以通过该方法改变电灯的状态`State`类，分别由`On`类、`Off`类两种状态。\n\n``` java\nclass Light {\n private State state;\n //\n public Light(State state) {\n   this.state = state;\n }\n //通常客户端代码并不会对此方法感兴趣，这只是为了触发下面click方法时，能随即改变状态\n public void setState(State state) {\n   this.state = state;\n }\n //客户端代码感兴趣的方法\n public void switchLight() {\n   state.printAndChange(this);\n }\n //还可能有更复杂的形式\n //public void click1() {state.printAndChange1(this);}\n //上下文提供多个方法调用，同时也多可更多对状态间的变换。下面再举个例子\n}\n\ninterface State {\n void printAndChange(Light context);\n}\nclass On implements State {\n @Override\n public void printAndChange(Light context) {\n   System.out.println(\"灯关了！\");\n   //改变与之相反的状态\n   context.setState(new Off());\n }\n}\nclass Off implements State {\n @Override\n public void printAndChange(Light context) {\n   System.out.println(\"灯开着呢！\");\n   //同上\n   context.setState(new On());\n }\n}\n\npublic class StatePattern {\n public static void main(String[] args) {\n   Light light = new Light(new Off());\n   light.switchLight();\n   light.switchLight();\n   light.switchLight();\n }\n}\n```\n\n我们再来个稍微复杂一点的例子，假如电灯有两档亮度，那又如何？\n\n``` java\nclass Light {\n\tprivate State state;\n\tpublic Light(State state) {\n\t\tthis.state = state;\n\t}\n\tpublic void setState(State state) {\n\t\tthis.state = state;\n\t}\n\tpublic State getState() {\n\t\treturn this.state;\n\t}\n  //下一档\n\tpublic void shiftNextGear() {\n\t\tstate.forward(this);\n\t}\n  //上一档\n\tpublic void shiftPrevGrear() {\n\t\tstate.reverse(this);\n\t}\n}\n\ninterface State {\n\tvoid reverse(Light context);\n\tvoid forward(Light context);\n}\nclass Off implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n    //判断是否已经关闭，若是则无法拨打上一档\n\t\tif(context.getState() instanceof Off) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n\t\tSystem.out.println(\"电灯一档亮度！\");\n\t\tcontext.setState(new FirGear());\n\t}\n}\nclass FirGear implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n\t\tSystem.out.println(\"电灯关了！\");\n\t\tcontext.setState(new Off());\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n\t\tSystem.out.println(\"电灯二档亮度！\");\n\t\tcontext.setState(new SecGear());\n\t}\n}\nclass SecGear implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n\t\tSystem.out.println(\"电灯一档亮度！\");\n\t\tcontext.setState(new FirGear());\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n    //判断是否已经最高档，若是则无法拨打下一档\n\t\tif(context.getState() instanceof SecGear) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n}\n\npublic class StatePattern {\n\tpublic static void main(String[] args) {\n\t\tLight light = new Light(new Off());\n\t\tlight.shiftNextGear();\n\t\tlight.shiftNextGear();\n\t\tlight.shiftPrevGrear();\n\t\tlight.shiftPrevGrear();\n\t\tlight.shiftPrevGrear();\n\t}\n}\n```\n最后打印出来的结果如下：\n```\n电灯一档亮度！\n电灯二档亮度！\n电灯一档亮度！\n电灯关了！\nException in thread \"main\" java.lang.RuntimeException\n\tat Off.reverse(StatePattern.java:41)\n\tat Light.shiftPrevGrear(StatePattern.java:28)\n\tat StatePattern.main(StatePattern.java:9)\n```\n","source":"_posts/20160520-设计模式－状态模式.md","raw":"---\ntitle: 设计模式－状态模式\ndate: 2016-05-20 14:18:28\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n现实生活中，操作某一固定事物，可能会触发不同状态，例如电灯的开关。代码中也用相类似的情况，调用某对象的同一方法或多个方法，会触发对象内部的某个状态，而这个状态会影响你下一步可能调用的方法。我们这一次就讲讲状态模式。\n\n---\n\n- ### 举例\n\n我们的上下文`Light`类有`click()`方法，可以通过该方法改变电灯的状态`State`类，分别由`On`类、`Off`类两种状态。\n\n``` java\nclass Light {\n private State state;\n //\n public Light(State state) {\n   this.state = state;\n }\n //通常客户端代码并不会对此方法感兴趣，这只是为了触发下面click方法时，能随即改变状态\n public void setState(State state) {\n   this.state = state;\n }\n //客户端代码感兴趣的方法\n public void switchLight() {\n   state.printAndChange(this);\n }\n //还可能有更复杂的形式\n //public void click1() {state.printAndChange1(this);}\n //上下文提供多个方法调用，同时也多可更多对状态间的变换。下面再举个例子\n}\n\ninterface State {\n void printAndChange(Light context);\n}\nclass On implements State {\n @Override\n public void printAndChange(Light context) {\n   System.out.println(\"灯关了！\");\n   //改变与之相反的状态\n   context.setState(new Off());\n }\n}\nclass Off implements State {\n @Override\n public void printAndChange(Light context) {\n   System.out.println(\"灯开着呢！\");\n   //同上\n   context.setState(new On());\n }\n}\n\npublic class StatePattern {\n public static void main(String[] args) {\n   Light light = new Light(new Off());\n   light.switchLight();\n   light.switchLight();\n   light.switchLight();\n }\n}\n```\n\n我们再来个稍微复杂一点的例子，假如电灯有两档亮度，那又如何？\n\n``` java\nclass Light {\n\tprivate State state;\n\tpublic Light(State state) {\n\t\tthis.state = state;\n\t}\n\tpublic void setState(State state) {\n\t\tthis.state = state;\n\t}\n\tpublic State getState() {\n\t\treturn this.state;\n\t}\n  //下一档\n\tpublic void shiftNextGear() {\n\t\tstate.forward(this);\n\t}\n  //上一档\n\tpublic void shiftPrevGrear() {\n\t\tstate.reverse(this);\n\t}\n}\n\ninterface State {\n\tvoid reverse(Light context);\n\tvoid forward(Light context);\n}\nclass Off implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n    //判断是否已经关闭，若是则无法拨打上一档\n\t\tif(context.getState() instanceof Off) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n\t\tSystem.out.println(\"电灯一档亮度！\");\n\t\tcontext.setState(new FirGear());\n\t}\n}\nclass FirGear implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n\t\tSystem.out.println(\"电灯关了！\");\n\t\tcontext.setState(new Off());\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n\t\tSystem.out.println(\"电灯二档亮度！\");\n\t\tcontext.setState(new SecGear());\n\t}\n}\nclass SecGear implements State {\n\t@Override\n\tpublic void reverse(Light context) {\n\t\tSystem.out.println(\"电灯一档亮度！\");\n\t\tcontext.setState(new FirGear());\n\t}\n\t@Override\n\tpublic void forward(Light context) {\n    //判断是否已经最高档，若是则无法拨打下一档\n\t\tif(context.getState() instanceof SecGear) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n}\n\npublic class StatePattern {\n\tpublic static void main(String[] args) {\n\t\tLight light = new Light(new Off());\n\t\tlight.shiftNextGear();\n\t\tlight.shiftNextGear();\n\t\tlight.shiftPrevGrear();\n\t\tlight.shiftPrevGrear();\n\t\tlight.shiftPrevGrear();\n\t}\n}\n```\n最后打印出来的结果如下：\n```\n电灯一档亮度！\n电灯二档亮度！\n电灯一档亮度！\n电灯关了！\nException in thread \"main\" java.lang.RuntimeException\n\tat Off.reverse(StatePattern.java:41)\n\tat Light.shiftPrevGrear(StatePattern.java:28)\n\tat StatePattern.main(StatePattern.java:9)\n```\n","slug":"20160520-设计模式－状态模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sc00164ejdcov89f2a","content":"<p>现实生活中，操作某一固定事物，可能会触发不同状态，例如电灯的开关。代码中也用相类似的情况，调用某对象的同一方法或多个方法，会触发对象内部的某个状态，而这个状态会影响你下一步可能调用的方法。我们这一次就讲讲状态模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>我们的上下文<code>Light</code>类有<code>click()</code>方法，可以通过该方法改变电灯的状态<code>State</code>类，分别由<code>On</code>类、<code>Off</code>类两种状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> State state;</span><br><span class=\"line\"> <span class=\"comment\">//</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Light</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//通常客户端代码并不会对此方法感兴趣，这只是为了触发下面click方法时，能随即改变状态</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//客户端代码感兴趣的方法</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">switchLight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   state.printAndChange(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//还可能有更复杂的形式</span></span><br><span class=\"line\"> <span class=\"comment\">//public void click1() &#123;state.printAndChange1(this);&#125;</span></span><br><span class=\"line\"> <span class=\"comment\">//上下文提供多个方法调用，同时也多可更多对状态间的变换。下面再举个例子</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">On</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">\"灯关了！\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//改变与之相反的状态</span></span><br><span class=\"line\">   context.setState(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Off</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">\"灯开着呢！\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//同上</span></span><br><span class=\"line\">   context.setState(<span class=\"keyword\">new</span> On());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatePattern</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   Light light = <span class=\"keyword\">new</span> Light(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来个稍微复杂一点的例子，假如电灯有两档亮度，那又如何？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> State state;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Light</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">//下一档</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shiftNextGear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tstate.forward(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">//上一档</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shiftPrevGrear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tstate.reverse(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Off</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否已经关闭，若是则无法拨打上一档</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(context.getState() <span class=\"keyword\">instanceof</span> Off) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯一档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> FirGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirGear</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯关了！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯二档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> SecGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecGear</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯一档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> FirGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否已经最高档，若是则无法拨打下一档</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(context.getState() <span class=\"keyword\">instanceof</span> SecGear) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatePattern</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tLight light = <span class=\"keyword\">new</span> Light(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">\t\tlight.shiftNextGear();</span><br><span class=\"line\">\t\tlight.shiftNextGear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后打印出来的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">电灯一档亮度！</span><br><span class=\"line\">电灯二档亮度！</span><br><span class=\"line\">电灯一档亮度！</span><br><span class=\"line\">电灯关了！</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.RuntimeException</span><br><span class=\"line\">\tat Off.reverse(StatePattern.java:41)</span><br><span class=\"line\">\tat Light.shiftPrevGrear(StatePattern.java:28)</span><br><span class=\"line\">\tat StatePattern.main(StatePattern.java:9)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>现实生活中，操作某一固定事物，可能会触发不同状态，例如电灯的开关。代码中也用相类似的情况，调用某对象的同一方法或多个方法，会触发对象内部的某个状态，而这个状态会影响你下一步可能调用的方法。我们这一次就讲讲状态模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>我们的上下文<code>Light</code>类有<code>click()</code>方法，可以通过该方法改变电灯的状态<code>State</code>类，分别由<code>On</code>类、<code>Off</code>类两种状态。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">private</span> State state;</span><br><span class=\"line\"> <span class=\"comment\">//</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Light</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//通常客户端代码并不会对此方法感兴趣，这只是为了触发下面click方法时，能随即改变状态</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//客户端代码感兴趣的方法</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">switchLight</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   state.printAndChange(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//还可能有更复杂的形式</span></span><br><span class=\"line\"> <span class=\"comment\">//public void click1() &#123;state.printAndChange1(this);&#125;</span></span><br><span class=\"line\"> <span class=\"comment\">//上下文提供多个方法调用，同时也多可更多对状态间的变换。下面再举个例子</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">On</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">\"灯关了！\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//改变与之相反的状态</span></span><br><span class=\"line\">   context.setState(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Off</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"meta\">@Override</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">printAndChange</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">   System.out.println(<span class=\"string\">\"灯开着呢！\"</span>);</span><br><span class=\"line\">   <span class=\"comment\">//同上</span></span><br><span class=\"line\">   context.setState(<span class=\"keyword\">new</span> On());</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatePattern</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">   Light light = <span class=\"keyword\">new</span> Light(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\">   light.switchLight();</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来个稍微复杂一点的例子，假如电灯有两档亮度，那又如何？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Light</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> State state;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Light</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(State state)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.state = state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> State <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">//下一档</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shiftNextGear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tstate.forward(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"comment\">//上一档</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shiftPrevGrear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tstate.reverse(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Off</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否已经关闭，若是则无法拨打上一档</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(context.getState() <span class=\"keyword\">instanceof</span> Off) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯一档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> FirGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirGear</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯关了！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯二档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> SecGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecGear</span> <span class=\"keyword\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"电灯一档亮度！\"</span>);</span><br><span class=\"line\">\t\tcontext.setState(<span class=\"keyword\">new</span> FirGear());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">forward</span><span class=\"params\">(Light context)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否已经最高档，若是则无法拨打下一档</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(context.getState() <span class=\"keyword\">instanceof</span> SecGear) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatePattern</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tLight light = <span class=\"keyword\">new</span> Light(<span class=\"keyword\">new</span> Off());</span><br><span class=\"line\">\t\tlight.shiftNextGear();</span><br><span class=\"line\">\t\tlight.shiftNextGear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t\tlight.shiftPrevGrear();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后打印出来的结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">电灯一档亮度！</span><br><span class=\"line\">电灯二档亮度！</span><br><span class=\"line\">电灯一档亮度！</span><br><span class=\"line\">电灯关了！</span><br><span class=\"line\">Exception in thread &quot;main&quot; java.lang.RuntimeException</span><br><span class=\"line\">\tat Off.reverse(StatePattern.java:41)</span><br><span class=\"line\">\tat Light.shiftPrevGrear(StatePattern.java:28)</span><br><span class=\"line\">\tat StatePattern.main(StatePattern.java:9)</span><br></pre></td></tr></table></figure>\n"},{"title":"设计模式－策略模式","date":"2016-05-18T16:26:42.000Z","_content":"\n前面聊过模版方法，在一个算法中某步骤有多套实现时，可以很有效替换算法步骤。那如果在一套代码中有多种策略呢？更换策略是否还要更改原有的代码？这次说说策略模式。\n\n---\n\n- ### 举例\n\nOK，我们现在有个`ChooseStrategy`类要完成某个功能，只需调用`execute()`即可，该功能有用到两种策略分别是`SimpleStrategy`、`SpecialStrategy`类。\n\n``` java\npublic class ChooseStrategy {\n  private Strategy strategy = null;\n  public ChooseStrategy(Strategy strategy) {\n    this.strategy = strategy;\n  }\n  public void setStrategy(Strategy strategy) {\n    this.strategy = strategy;\n  }\n  public void execute() {\n    // ... code ...\n    if(this.strategy != null) {\n      this.strategy.fuck();\n    } else {\n      throw new Exception();\n    }\n    // ... code ...\n  }\n}\n\npublic interface Strategy {\n  void fuck();\n}\npublic class SimpleStrategy implements Strategy {\n  public void fuck() {\n    System.out.println(\"这是个简单的策略！\");\n  }\n}\npublic class SpecialStrategy implements Strategy {\n  public void fuck() {\n    System.out.println(\"这是个特殊的策略！\");\n  }\n}\n```\n\n在对每种策略都了如指掌的情况下，我们能根据不同情况设置不同的策略。\n``` java\npublic class StrategyPattern  {\n  public static void main(String[] args) {\n    ChooseStrategy choose = new ChooseStrategy(new SimpleStrategy());\n    choose.execute();\n    choose.setStrategy(new SpecialStrategy());\n    choose.execute();\n    choose.setStrategy(null);\n    choose.execute();\n  }\n}\n```\n\n- ### JDK中的策略模式\n\n`java.util.Collections`类的静态方法`sort(List<T> list, Comparator<? super T> c)`就是策略模式，实现`Comparator`接口即可。\n\n``` java\npublic static <T> void sort(List<T> list, Comparator<? super T> c) {\n  Object[] a = list.toArray();\n  Arrays.sort(a, (Comparator)c);\n  ListIterator i = list.listIterator();\n  for (int j=0; j<a.length; j++) {\n    i.next();\n    i.set(a[j]);\n  }\n}\npublic interface Comparator<T> {\n    int compare(T o1, T o2);\n    boolean equals(Object obj);\n}\n```\n\n实现`Comparator`接口，跟[模板方法](/2016/04/30/20160429-设计模式－模版方法/)很相似，示例：\n``` java\nclass SizeComparator implements Comparator<Dick> {\n\t@Override\n\tpublic int compare(Dick o1, Dick o2) {\n\t\treturn o2.getSize() - o1.getSize();\n\t}\n}\n\nclass Dick {\n\tprivate String name;\n\tprivate int size;\n\tpublic Dick(String name, int size) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.size = size;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Dick [name=\" + name + \", size=\" + size + \"cm]\";\n\t}\n}\npublic class TestComparator {\n\tpublic static void main(String[] args) {\n\t\tDick[] fuckers = {new Dick(\"张三\", 17),\n\t\t\t\t\t\t\tnew Dick(\"李四\", 14),\n\t\t\t\t\t\t\tnew Dick(\"王五\", 29),\n\t\t\t\t\t\t\tnew Dick(\"老六\", 22),\n\t\t\t\t\t\t\tnew Dick(\"赵七\", 11)};\n\t\tList<Dick> dicks = new ArrayList<Dick>();\n\t\tArrays.sort(fuckers);\n\t\tfor(Dick fucker : fuckers)\n\t\t\tdicks.add(fucker);\n\t\tCollections.sort(dicks, new SizeComparator());\n    // [Dick [name=王五, size=29cm], Dick [name=老六, size=22cm], Dick [name=张三, size=17cm], Dick [name=李四, size=14cm], Dick [name=赵七, size=11cm]]\n\t\tSystem.out.println(dicks);\n\t}\n}\n```\n","source":"_posts/20160519-设计模式－策略模式.md","raw":"---\ntitle: 设计模式－策略模式\ndate: 2016-05-19 00:26:42\ncategories:\n- 设计模式\ntags:\n- java\n- 设计模式\n---\n\n前面聊过模版方法，在一个算法中某步骤有多套实现时，可以很有效替换算法步骤。那如果在一套代码中有多种策略呢？更换策略是否还要更改原有的代码？这次说说策略模式。\n\n---\n\n- ### 举例\n\nOK，我们现在有个`ChooseStrategy`类要完成某个功能，只需调用`execute()`即可，该功能有用到两种策略分别是`SimpleStrategy`、`SpecialStrategy`类。\n\n``` java\npublic class ChooseStrategy {\n  private Strategy strategy = null;\n  public ChooseStrategy(Strategy strategy) {\n    this.strategy = strategy;\n  }\n  public void setStrategy(Strategy strategy) {\n    this.strategy = strategy;\n  }\n  public void execute() {\n    // ... code ...\n    if(this.strategy != null) {\n      this.strategy.fuck();\n    } else {\n      throw new Exception();\n    }\n    // ... code ...\n  }\n}\n\npublic interface Strategy {\n  void fuck();\n}\npublic class SimpleStrategy implements Strategy {\n  public void fuck() {\n    System.out.println(\"这是个简单的策略！\");\n  }\n}\npublic class SpecialStrategy implements Strategy {\n  public void fuck() {\n    System.out.println(\"这是个特殊的策略！\");\n  }\n}\n```\n\n在对每种策略都了如指掌的情况下，我们能根据不同情况设置不同的策略。\n``` java\npublic class StrategyPattern  {\n  public static void main(String[] args) {\n    ChooseStrategy choose = new ChooseStrategy(new SimpleStrategy());\n    choose.execute();\n    choose.setStrategy(new SpecialStrategy());\n    choose.execute();\n    choose.setStrategy(null);\n    choose.execute();\n  }\n}\n```\n\n- ### JDK中的策略模式\n\n`java.util.Collections`类的静态方法`sort(List<T> list, Comparator<? super T> c)`就是策略模式，实现`Comparator`接口即可。\n\n``` java\npublic static <T> void sort(List<T> list, Comparator<? super T> c) {\n  Object[] a = list.toArray();\n  Arrays.sort(a, (Comparator)c);\n  ListIterator i = list.listIterator();\n  for (int j=0; j<a.length; j++) {\n    i.next();\n    i.set(a[j]);\n  }\n}\npublic interface Comparator<T> {\n    int compare(T o1, T o2);\n    boolean equals(Object obj);\n}\n```\n\n实现`Comparator`接口，跟[模板方法](/2016/04/30/20160429-设计模式－模版方法/)很相似，示例：\n``` java\nclass SizeComparator implements Comparator<Dick> {\n\t@Override\n\tpublic int compare(Dick o1, Dick o2) {\n\t\treturn o2.getSize() - o1.getSize();\n\t}\n}\n\nclass Dick {\n\tprivate String name;\n\tprivate int size;\n\tpublic Dick(String name, int size) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.size = size;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getSize() {\n\t\treturn size;\n\t}\n\tpublic void setSize(int size) {\n\t\tthis.size = size;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Dick [name=\" + name + \", size=\" + size + \"cm]\";\n\t}\n}\npublic class TestComparator {\n\tpublic static void main(String[] args) {\n\t\tDick[] fuckers = {new Dick(\"张三\", 17),\n\t\t\t\t\t\t\tnew Dick(\"李四\", 14),\n\t\t\t\t\t\t\tnew Dick(\"王五\", 29),\n\t\t\t\t\t\t\tnew Dick(\"老六\", 22),\n\t\t\t\t\t\t\tnew Dick(\"赵七\", 11)};\n\t\tList<Dick> dicks = new ArrayList<Dick>();\n\t\tArrays.sort(fuckers);\n\t\tfor(Dick fucker : fuckers)\n\t\t\tdicks.add(fucker);\n\t\tCollections.sort(dicks, new SizeComparator());\n    // [Dick [name=王五, size=29cm], Dick [name=老六, size=22cm], Dick [name=张三, size=17cm], Dick [name=李四, size=14cm], Dick [name=赵七, size=11cm]]\n\t\tSystem.out.println(dicks);\n\t}\n}\n```\n","slug":"20160519-设计模式－策略模式","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sd001a4ejde5bd52ls","content":"<p>前面聊过模版方法，在一个算法中某步骤有多套实现时，可以很有效替换算法步骤。那如果在一套代码中有多种策略呢？更换策略是否还要更改原有的代码？这次说说策略模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>OK，我们现在有个<code>ChooseStrategy</code>类要完成某个功能，只需调用<code>execute()</code>即可，该功能有用到两种策略分别是<code>SimpleStrategy</code>、<code>SpecialStrategy</code>类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChooseStrategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Strategy strategy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChooseStrategy</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStrategy</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... code ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.strategy != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.strategy.fuck();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... code ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"这是个简单的策略！\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpecialStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"这是个特殊的策略！\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在对每种策略都了如指掌的情况下，我们能根据不同情况设置不同的策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyPattern</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ChooseStrategy choose = <span class=\"keyword\">new</span> ChooseStrategy(<span class=\"keyword\">new</span> SimpleStrategy());</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">    choose.setStrategy(<span class=\"keyword\">new</span> SpecialStrategy());</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">    choose.setStrategy(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的策略模式\"><a href=\"#JDK中的策略模式\" class=\"headerlink\" title=\"JDK中的策略模式\"></a>JDK中的策略模式</h3></li>\n</ul>\n<p><code>java.util.Collections</code>类的静态方法<code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>就是策略模式，实现<code>Comparator</code>接口即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List&lt;T&gt; list, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  Object[] a = list.toArray();</span><br><span class=\"line\">  Arrays.sort(a, (Comparator)c);</span><br><span class=\"line\">  ListIterator i = list.listIterator();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">    i.next();</span><br><span class=\"line\">    i.set(a[j]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>Comparator</code>接口，跟<a href=\"/2016/04/30/20160429-设计模式－模版方法/\">模板方法</a>很相似，示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SizeComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">Dick</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Dick o1, Dick o2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o2.getSize() - o1.getSize();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dick</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dick</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Dick [name=\"</span> + name + <span class=\"string\">\", size=\"</span> + size + <span class=\"string\">\"cm]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestComparator</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDick[] fuckers = &#123;<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"张三\"</span>, <span class=\"number\">17</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"李四\"</span>, <span class=\"number\">14</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"王五\"</span>, <span class=\"number\">29</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"老六\"</span>, <span class=\"number\">22</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"赵七\"</span>, <span class=\"number\">11</span>)&#125;;</span><br><span class=\"line\">\t\tList&lt;Dick&gt; dicks = <span class=\"keyword\">new</span> ArrayList&lt;Dick&gt;();</span><br><span class=\"line\">\t\tArrays.sort(fuckers);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Dick fucker : fuckers)</span><br><span class=\"line\">\t\t\tdicks.add(fucker);</span><br><span class=\"line\">\t\tCollections.sort(dicks, <span class=\"keyword\">new</span> SizeComparator());</span><br><span class=\"line\">    <span class=\"comment\">// [Dick [name=王五, size=29cm], Dick [name=老六, size=22cm], Dick [name=张三, size=17cm], Dick [name=李四, size=14cm], Dick [name=赵七, size=11cm]]</span></span><br><span class=\"line\">\t\tSystem.out.println(dicks);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>前面聊过模版方法，在一个算法中某步骤有多套实现时，可以很有效替换算法步骤。那如果在一套代码中有多种策略呢？更换策略是否还要更改原有的代码？这次说说策略模式。</p>\n<hr>\n<ul>\n<li><h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3></li>\n</ul>\n<p>OK，我们现在有个<code>ChooseStrategy</code>类要完成某个功能，只需调用<code>execute()</code>即可，该功能有用到两种策略分别是<code>SimpleStrategy</code>、<code>SpecialStrategy</code>类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChooseStrategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> Strategy strategy = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChooseStrategy</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStrategy</span><span class=\"params\">(Strategy strategy)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.strategy = strategy;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ... code ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.strategy != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.strategy.fuck();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ... code ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"这是个简单的策略！\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpecialStrategy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Strategy</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">fuck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"这是个特殊的策略！\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在对每种策略都了如指掌的情况下，我们能根据不同情况设置不同的策略。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrategyPattern</span>  </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ChooseStrategy choose = <span class=\"keyword\">new</span> ChooseStrategy(<span class=\"keyword\">new</span> SimpleStrategy());</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">    choose.setStrategy(<span class=\"keyword\">new</span> SpecialStrategy());</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">    choose.setStrategy(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    choose.execute();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"JDK中的策略模式\"><a href=\"#JDK中的策略模式\" class=\"headerlink\" title=\"JDK中的策略模式\"></a>JDK中的策略模式</h3></li>\n</ul>\n<p><code>java.util.Collections</code>类的静态方法<code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>就是策略模式，实现<code>Comparator</code>接口即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List&lt;T&gt; list, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  Object[] a = list.toArray();</span><br><span class=\"line\">  Arrays.sort(a, (Comparator)c);</span><br><span class=\"line\">  ListIterator i = list.listIterator();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;a.length; j++) &#123;</span><br><span class=\"line\">    i.next();</span><br><span class=\"line\">    i.set(a[j]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现<code>Comparator</code>接口，跟<a href=\"/2016/04/30/20160429-设计模式－模版方法/\">模板方法</a>很相似，示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SizeComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">Dick</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Dick o1, Dick o2)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> o2.getSize() - o1.getSize();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dick</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dick</span><span class=\"params\">(String name, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setSize</span><span class=\"params\">(<span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.size = size;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"Dick [name=\"</span> + name + <span class=\"string\">\", size=\"</span> + size + <span class=\"string\">\"cm]\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestComparator</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tDick[] fuckers = &#123;<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"张三\"</span>, <span class=\"number\">17</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"李四\"</span>, <span class=\"number\">14</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"王五\"</span>, <span class=\"number\">29</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"老六\"</span>, <span class=\"number\">22</span>),</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">new</span> Dick(<span class=\"string\">\"赵七\"</span>, <span class=\"number\">11</span>)&#125;;</span><br><span class=\"line\">\t\tList&lt;Dick&gt; dicks = <span class=\"keyword\">new</span> ArrayList&lt;Dick&gt;();</span><br><span class=\"line\">\t\tArrays.sort(fuckers);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Dick fucker : fuckers)</span><br><span class=\"line\">\t\t\tdicks.add(fucker);</span><br><span class=\"line\">\t\tCollections.sort(dicks, <span class=\"keyword\">new</span> SizeComparator());</span><br><span class=\"line\">    <span class=\"comment\">// [Dick [name=王五, size=29cm], Dick [name=老六, size=22cm], Dick [name=张三, size=17cm], Dick [name=李四, size=14cm], Dick [name=赵七, size=11cm]]</span></span><br><span class=\"line\">\t\tSystem.out.println(dicks);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅谈Java集合框架－比较HashMap与Hashtable","date":"2016-07-16T13:32:29.000Z","_content":"\nHashtable实际上就是一个线程安全的HashMap，不过它是个遗留下来的过气类，其性能也并比不少ConcurrentHashMap。\n\n---\n\n``` java\n//HashMap默认长度是1<<4 aka 16\npublic Hashtable() {\n  this(11, 0.75f);\n}\n//很明显，HashMap没有synchronized，并不线程安全。\npublic synchronized V put(K key, V value) {\n  // Make sure the value is not null\n  if (value == null) {\n    //HashMap的key允许一个null\n    //HashMap源码：return putForNullKey(value);\n    throw new NullPointerException();\n  }\n\n  // Makes sure the key is not already in the hashtable.\n  Entry tab[] = table;\n  int hash = hash(key);\n  int index = (hash & 0x7FFFFFFF) % tab.length;\n  for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {\n    if ((e.hash == hash) && e.key.equals(key)) {\n      V old = e.value;\n      e.value = value;\n      return old;\n    }\n  }\n\n  modCount++;\n  if (count >= threshold) {\n    // Rehash the table if the threshold is exceeded\n    rehash();\n    tab = table;\n    hash = hash(key);\n    index = (hash & 0x7FFFFFFF) % tab.length;\n  }\n\n  // Creates the new entry.\n  Entry<K,V> e = tab[index];\n  tab[index] = new Entry<>(hash, key, value, e);\n  count++;\n  return null;\n}\n\npublic synchronized V get(Object key) {\n  //if (key == null)\n  //  return getForNullKey();HashMap的key有null值\n  Entry tab[] = table;\n  int hash = hash(key);\n  int index = (hash & 0x7FFFFFFF) % tab.length;\n  for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {\n    if ((e.hash == hash) && e.key.equals(key)) {\n      return e.value;\n    }\n  }\n  return null;\n}\n```\n","source":"_posts/20160716-浅谈Java集合框架－比较HashMap与Hashtable.md","raw":"---\ntitle: 浅谈Java集合框架－比较HashMap与Hashtable\ndate: 2016-07-16 21:32:29\ncategories:\n- 集合框架\ntags:\n- java\n- Hashtable\n- HashMap\n---\n\nHashtable实际上就是一个线程安全的HashMap，不过它是个遗留下来的过气类，其性能也并比不少ConcurrentHashMap。\n\n---\n\n``` java\n//HashMap默认长度是1<<4 aka 16\npublic Hashtable() {\n  this(11, 0.75f);\n}\n//很明显，HashMap没有synchronized，并不线程安全。\npublic synchronized V put(K key, V value) {\n  // Make sure the value is not null\n  if (value == null) {\n    //HashMap的key允许一个null\n    //HashMap源码：return putForNullKey(value);\n    throw new NullPointerException();\n  }\n\n  // Makes sure the key is not already in the hashtable.\n  Entry tab[] = table;\n  int hash = hash(key);\n  int index = (hash & 0x7FFFFFFF) % tab.length;\n  for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {\n    if ((e.hash == hash) && e.key.equals(key)) {\n      V old = e.value;\n      e.value = value;\n      return old;\n    }\n  }\n\n  modCount++;\n  if (count >= threshold) {\n    // Rehash the table if the threshold is exceeded\n    rehash();\n    tab = table;\n    hash = hash(key);\n    index = (hash & 0x7FFFFFFF) % tab.length;\n  }\n\n  // Creates the new entry.\n  Entry<K,V> e = tab[index];\n  tab[index] = new Entry<>(hash, key, value, e);\n  count++;\n  return null;\n}\n\npublic synchronized V get(Object key) {\n  //if (key == null)\n  //  return getForNullKey();HashMap的key有null值\n  Entry tab[] = table;\n  int hash = hash(key);\n  int index = (hash & 0x7FFFFFFF) % tab.length;\n  for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {\n    if ((e.hash == hash) && e.key.equals(key)) {\n      return e.value;\n    }\n  }\n  return null;\n}\n```\n","slug":"20160716-浅谈Java集合框架－比较HashMap与Hashtable","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7se001b4ejd00vn11h7","content":"<p>Hashtable实际上就是一个线程安全的HashMap，不过它是个遗留下来的过气类，其性能也并比不少ConcurrentHashMap。</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashMap默认长度是1&lt;&lt;4 aka 16</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75f</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//很明显，HashMap没有synchronized，并不线程安全。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//HashMap的key允许一个null</span></span><br><span class=\"line\">    <span class=\"comment\">//HashMap源码：return putForNullKey(value);</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Makes sure the key is not already in the hashtable.</span></span><br><span class=\"line\">  Entry tab[] = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class=\"line\">      V old = e.value;</span><br><span class=\"line\">      e.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> old;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &gt;= threshold) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash the table if the threshold is exceeded</span></span><br><span class=\"line\">    rehash();</span><br><span class=\"line\">    tab = table;</span><br><span class=\"line\">    hash = hash(key);</span><br><span class=\"line\">    index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Creates the new entry.</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">  tab[index] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//if (key == null)</span></span><br><span class=\"line\">  <span class=\"comment\">//  return getForNullKey();HashMap的key有null值</span></span><br><span class=\"line\">  Entry tab[] = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Hashtable实际上就是一个线程安全的HashMap，不过它是个遗留下来的过气类，其性能也并比不少ConcurrentHashMap。</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashMap默认长度是1&lt;&lt;4 aka 16</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Hashtable</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>(<span class=\"number\">11</span>, <span class=\"number\">0.75f</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//很明显，HashMap没有synchronized，并不线程安全。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Make sure the value is not null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//HashMap的key允许一个null</span></span><br><span class=\"line\">    <span class=\"comment\">//HashMap源码：return putForNullKey(value);</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Makes sure the key is not already in the hashtable.</span></span><br><span class=\"line\">  Entry tab[] = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class=\"line\">      V old = e.value;</span><br><span class=\"line\">      e.value = value;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> old;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &gt;= threshold) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash the table if the threshold is exceeded</span></span><br><span class=\"line\">    rehash();</span><br><span class=\"line\">    tab = table;</span><br><span class=\"line\">    hash = hash(key);</span><br><span class=\"line\">    index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Creates the new entry.</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">  tab[index] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">  count++;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//if (key == null)</span></span><br><span class=\"line\">  <span class=\"comment\">//  return getForNullKey();HashMap的key有null值</span></span><br><span class=\"line\">  Entry tab[] = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> index = (hash &amp; <span class=\"number\">0x7FFFFFFF</span>) % tab.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class=\"keyword\">null</span> ; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅谈Java集合框架－看看HashMap源码，了解它是咋运作的?","date":"2016-06-28T06:33:49.000Z","_content":"\n初探HashMap源码，显然要理解它的运作并不难，只要基本掌握哈希桶这种数据结构。本文只在源码上对`get(K key)`和`put(K key, V value)`进行解读，并了解HashMap的原理。我看的是jdk1.7的源码！\n\n---\n\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n  this.loadFactor = loadFactor;\n  threshold = initialCapacity;\n\n  //在HashMap类中无用\n  init();\n}\n\n//初始化哈希槽\nprivate void inflateTable(int toSize) {\n  //threshold只是作为标准值，下面求一个略大于标准值的容量\n  int capacity = roundUpToPowerOf2(toSize);\n  //负载因子折算threshold\n  threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n  //注意Entry本身是链表结构（即桶），table只是桶的列表\n  table = new Entry[capacity];\n  //初始化hashseed\n  initHashSeedAsNeeded(capacity);\n}\n\nprivate static int roundUpToPowerOf2(int number) {\n  // assert number >= 0 : \"number must be non-negative\";\n  return number >= MAXIMUM_CAPACITY\n    ? MAXIMUM_CAPACITY\n      //number-1两倍，取最高位1的值\n      : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n}\n\npublic V put(K key, V value) {\n  if (table == EMPTY_TABLE) {\n    //\n    inflateTable(threshold);\n  }\n  //key为null时，hash为0，即table[0]\n  if (key == null)\n    //该方法的代码段与下面一致，i＝0\n    return putForNullKey(value);\n  int hash = hash(key);\n  //计算下标\n  int i = indexFor(hash, table.length);\n  //获取对于hash的桶，e!=null则下一个entry\n  for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n    Object k;\n    //比对key值，若key存在则体会value，并返回旧value\n    if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n      V oldValue = e.value;\n      e.value = value;\n      //貌似毫无用处\n      e.recordAccess(this);\n      return oldValue;\n    }\n  }\n\n  modCount++;\n  //key值不存在则插入\n  addEntry(hash, key, value, i);\n  return null;\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n  //entry数满标准值，且该槽点不为null。为什么这样判断？因为大于threshold，不代表bucket已经用完，size只是entry的数量\n  if ((size >= threshold) && (null != table[bucketIndex])) {\n    //重设标准值，扩容\n    resize(2 * table.length);\n    //重新计算hash\n    hash = (null != key) ? hash(key) : 0;\n    //重新计算下表\n    bucketIndex = indexFor(hash, table.length);\n  }\n\n  createEntry(hash, key, value, bucketIndex);\n}\n\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n  Entry<K,V> e = table[bucketIndex];\n  //把新entry插入链表头\n  table[bucketIndex] = new Entry<>(hash, key, value, e);\n  size++;\n}\n\npublic V get(Object key) {\n  if (key == null)\n    return getForNullKey();\n  Entry<K,V> entry = getEntry(key);\n\n  return null == entry ? null : entry.getValue();\n}\n\nprivate V getForNullKey() {\n  if (size == 0) {\n    return null;\n  }\n  //前面说过key为null时，hash为0\n  for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n    if (e.key == null)\n      return e.value;\n  }\n  return null;\n}\n\nfinal Entry<K,V> getEntry(Object key) {\n  if (size == 0) {\n    return null;\n  }\n\n  int hash = (key == null) ? 0 : hash(key);\n  //获取hash对应的bucket，遍历Entry\n  for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {\n      Object k;\n      if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n          return e;\n  }\n  return null;\n}\n\nvoid resize(int newCapacity) {\n\n  Entry[] oldTable = table;\n  int oldCapacity = oldTable.length;\n  if (oldCapacity == MAXIMUM_CAPACITY) {\n    threshold = Integer.MAX_VALUE;\n    return;\n  }\n\n  Entry[] newTable = new Entry[newCapacity];\n  transfer(newTable, initHashSeedAsNeeded(newCapacity));\n  table = newTable;\n  threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n","source":"_posts/20160628－浅谈Java集合框架－看看HashMap源码，了解它是咋运作的.md","raw":"---\ntitle: 浅谈Java集合框架－看看HashMap源码，了解它是咋运作的?\ndate: 2016-06-28 14:33:49\ncategories:\n- 集合框架\ntags:\n- java\n- hashmap\n---\n\n初探HashMap源码，显然要理解它的运作并不难，只要基本掌握哈希桶这种数据结构。本文只在源码上对`get(K key)`和`put(K key, V value)`进行解读，并了解HashMap的原理。我看的是jdk1.7的源码！\n\n---\n\n``` java\npublic HashMap(int initialCapacity, float loadFactor) {\n  this.loadFactor = loadFactor;\n  threshold = initialCapacity;\n\n  //在HashMap类中无用\n  init();\n}\n\n//初始化哈希槽\nprivate void inflateTable(int toSize) {\n  //threshold只是作为标准值，下面求一个略大于标准值的容量\n  int capacity = roundUpToPowerOf2(toSize);\n  //负载因子折算threshold\n  threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);\n  //注意Entry本身是链表结构（即桶），table只是桶的列表\n  table = new Entry[capacity];\n  //初始化hashseed\n  initHashSeedAsNeeded(capacity);\n}\n\nprivate static int roundUpToPowerOf2(int number) {\n  // assert number >= 0 : \"number must be non-negative\";\n  return number >= MAXIMUM_CAPACITY\n    ? MAXIMUM_CAPACITY\n      //number-1两倍，取最高位1的值\n      : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;\n}\n\npublic V put(K key, V value) {\n  if (table == EMPTY_TABLE) {\n    //\n    inflateTable(threshold);\n  }\n  //key为null时，hash为0，即table[0]\n  if (key == null)\n    //该方法的代码段与下面一致，i＝0\n    return putForNullKey(value);\n  int hash = hash(key);\n  //计算下标\n  int i = indexFor(hash, table.length);\n  //获取对于hash的桶，e!=null则下一个entry\n  for (Entry<K,V> e = table[i]; e != null; e = e.next) {\n    Object k;\n    //比对key值，若key存在则体会value，并返回旧value\n    if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {\n      V oldValue = e.value;\n      e.value = value;\n      //貌似毫无用处\n      e.recordAccess(this);\n      return oldValue;\n    }\n  }\n\n  modCount++;\n  //key值不存在则插入\n  addEntry(hash, key, value, i);\n  return null;\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n  //entry数满标准值，且该槽点不为null。为什么这样判断？因为大于threshold，不代表bucket已经用完，size只是entry的数量\n  if ((size >= threshold) && (null != table[bucketIndex])) {\n    //重设标准值，扩容\n    resize(2 * table.length);\n    //重新计算hash\n    hash = (null != key) ? hash(key) : 0;\n    //重新计算下表\n    bucketIndex = indexFor(hash, table.length);\n  }\n\n  createEntry(hash, key, value, bucketIndex);\n}\n\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n  Entry<K,V> e = table[bucketIndex];\n  //把新entry插入链表头\n  table[bucketIndex] = new Entry<>(hash, key, value, e);\n  size++;\n}\n\npublic V get(Object key) {\n  if (key == null)\n    return getForNullKey();\n  Entry<K,V> entry = getEntry(key);\n\n  return null == entry ? null : entry.getValue();\n}\n\nprivate V getForNullKey() {\n  if (size == 0) {\n    return null;\n  }\n  //前面说过key为null时，hash为0\n  for (Entry<K,V> e = table[0]; e != null; e = e.next) {\n    if (e.key == null)\n      return e.value;\n  }\n  return null;\n}\n\nfinal Entry<K,V> getEntry(Object key) {\n  if (size == 0) {\n    return null;\n  }\n\n  int hash = (key == null) ? 0 : hash(key);\n  //获取hash对应的bucket，遍历Entry\n  for (Entry<K,V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {\n      Object k;\n      if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n          return e;\n  }\n  return null;\n}\n\nvoid resize(int newCapacity) {\n\n  Entry[] oldTable = table;\n  int oldCapacity = oldTable.length;\n  if (oldCapacity == MAXIMUM_CAPACITY) {\n    threshold = Integer.MAX_VALUE;\n    return;\n  }\n\n  Entry[] newTable = new Entry[newCapacity];\n  transfer(newTable, initHashSeedAsNeeded(newCapacity));\n  table = newTable;\n  threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n```\n","slug":"20160628－浅谈Java集合框架－看看HashMap源码，了解它是咋运作的","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sf001e4ejddlnxe9sv","content":"<p>初探HashMap源码，显然要理解它的运作并不难，只要基本掌握哈希桶这种数据结构。本文只在源码上对<code>get(K key)</code>和<code>put(K key, V value)</code>进行解读，并了解HashMap的原理。我看的是jdk1.7的源码！</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">  threshold = initialCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//在HashMap类中无用</span></span><br><span class=\"line\">  init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化哈希槽</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inflateTable</span><span class=\"params\">(<span class=\"keyword\">int</span> toSize)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//threshold只是作为标准值，下面求一个略大于标准值的容量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class=\"line\">  <span class=\"comment\">//负载因子折算threshold</span></span><br><span class=\"line\">  threshold = (<span class=\"keyword\">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//注意Entry本身是链表结构（即桶），table只是桶的列表</span></span><br><span class=\"line\">  table = <span class=\"keyword\">new</span> Entry[capacity];</span><br><span class=\"line\">  <span class=\"comment\">//初始化hashseed</span></span><br><span class=\"line\">  initHashSeedAsNeeded(capacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">roundUpToPowerOf2</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert number &gt;= 0 : \"number must be non-negative\";</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class=\"line\">    ? MAXIMUM_CAPACITY</span><br><span class=\"line\">      <span class=\"comment\">//number-1两倍，取最高位1的值</span></span><br><span class=\"line\">      : (number &gt; <span class=\"number\">1</span>) ? Integer.highestOneBit((number - <span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">1</span>) : <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    inflateTable(threshold);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//key为null时，hash为0，即table[0]</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//该方法的代码段与下面一致，i＝0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"comment\">//计算下标</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">  <span class=\"comment\">//获取对于hash的桶，e!=null则下一个entry</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    Object k;</span><br><span class=\"line\">    <span class=\"comment\">//比对key值，若key存在则体会value，并返回旧value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      e.value = value;</span><br><span class=\"line\">      <span class=\"comment\">//貌似毫无用处</span></span><br><span class=\"line\">      e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"comment\">//key值不存在则插入</span></span><br><span class=\"line\">  addEntry(hash, key, value, i);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//entry数满标准值，且该槽点不为null。为什么这样判断？因为大于threshold，不代表bucket已经用完，size只是entry的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//重设标准值，扩容</span></span><br><span class=\"line\">    resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">    <span class=\"comment\">//重新计算hash</span></span><br><span class=\"line\">    hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//重新计算下表</span></span><br><span class=\"line\">    bucketIndex = indexFor(hash, table.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  createEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">  <span class=\"comment\">//把新entry插入链表头</span></span><br><span class=\"line\">  table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getForNullKey();</span><br><span class=\"line\">  Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span> == entry ? <span class=\"keyword\">null</span> : entry.getValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">getForNullKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//前面说过key为null时，hash为0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">  <span class=\"comment\">//获取hash对应的bucket，遍历Entry</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">      Object k;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry[] oldTable = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">    threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</span><br><span class=\"line\">  transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class=\"line\">  table = newTable;</span><br><span class=\"line\">  threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>初探HashMap源码，显然要理解它的运作并不难，只要基本掌握哈希桶这种数据结构。本文只在源码上对<code>get(K key)</code>和<code>put(K key, V value)</code>进行解读，并了解HashMap的原理。我看的是jdk1.7的源码！</p>\n<hr>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">  threshold = initialCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//在HashMap类中无用</span></span><br><span class=\"line\">  init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//初始化哈希槽</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inflateTable</span><span class=\"params\">(<span class=\"keyword\">int</span> toSize)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//threshold只是作为标准值，下面求一个略大于标准值的容量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class=\"line\">  <span class=\"comment\">//负载因子折算threshold</span></span><br><span class=\"line\">  threshold = (<span class=\"keyword\">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//注意Entry本身是链表结构（即桶），table只是桶的列表</span></span><br><span class=\"line\">  table = <span class=\"keyword\">new</span> Entry[capacity];</span><br><span class=\"line\">  <span class=\"comment\">//初始化hashseed</span></span><br><span class=\"line\">  initHashSeedAsNeeded(capacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">roundUpToPowerOf2</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert number &gt;= 0 : \"number must be non-negative\";</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class=\"line\">    ? MAXIMUM_CAPACITY</span><br><span class=\"line\">      <span class=\"comment\">//number-1两倍，取最高位1的值</span></span><br><span class=\"line\">      : (number &gt; <span class=\"number\">1</span>) ? Integer.highestOneBit((number - <span class=\"number\">1</span>) &lt;&lt; <span class=\"number\">1</span>) : <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    inflateTable(threshold);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//key为null时，hash为0，即table[0]</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"comment\">//该方法的代码段与下面一致，i＝0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> putForNullKey(value);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = hash(key);</span><br><span class=\"line\">  <span class=\"comment\">//计算下标</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = indexFor(hash, table.length);</span><br><span class=\"line\">  <span class=\"comment\">//获取对于hash的桶，e!=null则下一个entry</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    Object k;</span><br><span class=\"line\">    <span class=\"comment\">//比对key值，若key存在则体会value，并返回旧value</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class=\"line\">      V oldValue = e.value;</span><br><span class=\"line\">      e.value = value;</span><br><span class=\"line\">      <span class=\"comment\">//貌似毫无用处</span></span><br><span class=\"line\">      e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">  <span class=\"comment\">//key值不存在则插入</span></span><br><span class=\"line\">  addEntry(hash, key, value, i);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//entry数满标准值，且该槽点不为null。为什么这样判断？因为大于threshold，不代表bucket已经用完，size只是entry的数量</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"keyword\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//重设标准值，扩容</span></span><br><span class=\"line\">    resize(<span class=\"number\">2</span> * table.length);</span><br><span class=\"line\">    <span class=\"comment\">//重新计算hash</span></span><br><span class=\"line\">    hash = (<span class=\"keyword\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//重新计算下表</span></span><br><span class=\"line\">    bucketIndex = indexFor(hash, table.length);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  createEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">  <span class=\"comment\">//把新entry插入链表头</span></span><br><span class=\"line\">  table[bucketIndex] = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getForNullKey();</span><br><span class=\"line\">  Entry&lt;K,V&gt; entry = getEntry(key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span> == entry ? <span class=\"keyword\">null</span> : entry.getValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">getForNullKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//前面说过key为null时，hash为0</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[<span class=\"number\">0</span>]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title\">getEntry</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> hash = (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">  <span class=\"comment\">//获取hash对应的bucket，遍历Entry</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">      Object k;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class=\"keyword\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">          <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry[] oldTable = table;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = oldTable.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class=\"line\">    threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry[] newTable = <span class=\"keyword\">new</span> Entry[newCapacity];</span><br><span class=\"line\">  transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class=\"line\">  table = newTable;</span><br><span class=\"line\">  threshold = (<span class=\"keyword\">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？","date":"2016-06-28T15:22:01.000Z","_content":"\n平时用惯ArrayList插入查询，无视性能而忽略了LinkedArray，今日也反省反省，研究了一下\nLinkedArray和ArrayList源码。其实理解两者原理和区别并不难，都是简单数据结构的应用。\n\n---\n\n## LinkedArray源码\n\n双链表的好处就是有前后指针，插入只需要更新指针指向，随机查询则需要遍历。\n\n``` java\npublic boolean add(E e) {\n  linkLast(e);\n  return true;\n}\n\n//这个很好理解了，往列表尾端添加元素\nvoid linkLast(E e) {\n  //现最后一个元素\n  final Node<E> l = last;\n  //即将添加的元素\n  final Node<E> newNode = new Node<>(l, e, null);\n  //last指针向后移\n  last = newNode;\n  //没有尾元素\n  if (l == null)\n    first = newNode;\n  else\n    //原尾元素next指向新下一个元素\n    l.next = newNode;\n  size++;\n  modCount++;\n}\n\npublic void add(int index, E element) {\n  //检查index是否越界，是则抛出运行时异常IndexOutOfBoundsException\n  checkPositionIndex(index);\n  //同add(E element)\n  if (index == size)\n    linkLast(element);\n  else\n    linkBefore(element, node(index));\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n  //succ元素的前任prev\n  final Node<E> pred = succ.prev;\n  //新元素成功插入succ与其前任prev中间\n  final Node<E> newNode = new Node<>(pred, e, succ);\n  //于是succ的现任prev是新元素e\n  succ.prev = newNode;\n  if (pred == null)\n    first = newNode;\n  else\n    pred.next = newNode;\n  size++;\n  modCount++;\n}\n\nNode<E> node(int index) {\n  // assert isElementIndex(index);\n  //类似二分法遍历，没什么好说的，size >> 1 aka size/2\n  if (index < (size >> 1)) {\n    Node<E> x = first;\n    for (int i = 0; i < index; i++)\n      x = x.next;\n    return x;\n  } else {\n    Node<E> x = last;\n    for (int i = size - 1; i > index; i--)\n      x = x.prev;\n    return x;\n  }\n}\n\npublic E get(int index) {\n  checkElementIndex(index);\n  return node(index).item;\n}\n```\n\n## ArrayList源码\n\n往数组末尾插入元素当然快，但随机插入可就不一定了，需要将子数组往后移且或扩容（LinkedArray不\n需要扩容）。\n\n``` java\npublic boolean add(E e) {\n  //主要功能是扩容\n  ensureCapacityInternal(size + 1);\n  elementData[size++] = e;\n  return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n  //就是说，即使你在ArrayList(int initialCapacity)传小于10的值，elementData最小长度依然是10\n  if (elementData == EMPTY_ELEMENTDATA) {\n    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n  }\n\n  ensureExplicitCapacity(minCapacity);\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n  modCount++;\n\n  if (minCapacity - elementData.length > 0)\n    grow(minCapacity);\n}\n\n//扩容！！！\nprivate void grow(int minCapacity) {\n  int oldCapacity = elementData.length;\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\npublic void add(int index, E element) {\n  rangeCheckForAdd(index);\n\n  ensureCapacityInternal(size + 1);\n  //这是ArrayList插入操作性能差的罪魁祸首\n  System.arraycopy(elementData, index, elementData, index + 1,\n    size - index);\n  elementData[index] = element;\n  size++;\n}\n```\n\n## 稍微总结一下\n\n``` java\n//ArrayList需要随机插入时，可以转为new LinkedList(new ArrayList());\npublic LinkedList(Collection<? extends E> c) {\n  this();\n  addAll(c);\n}\n\n//LinkedList需要随机查询时，可以转为new ArrayList(new LinkedList());\npublic ArrayList(Collection<? extends E> c) {\n  elementData = c.toArray();\n  size = elementData.length;\n  if (elementData.getClass() != Object[].class)\n  elementData = Arrays.copyOf(elementData, size, Object[].class);\n}\n```\n","source":"_posts/20160628－浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？.md","raw":"---\ntitle: 浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？\ndate: 2016-06-28 23:22:01\ncategories:\n- 集合框架\ntags:\n- java\n- LinkedArray\n---\n\n平时用惯ArrayList插入查询，无视性能而忽略了LinkedArray，今日也反省反省，研究了一下\nLinkedArray和ArrayList源码。其实理解两者原理和区别并不难，都是简单数据结构的应用。\n\n---\n\n## LinkedArray源码\n\n双链表的好处就是有前后指针，插入只需要更新指针指向，随机查询则需要遍历。\n\n``` java\npublic boolean add(E e) {\n  linkLast(e);\n  return true;\n}\n\n//这个很好理解了，往列表尾端添加元素\nvoid linkLast(E e) {\n  //现最后一个元素\n  final Node<E> l = last;\n  //即将添加的元素\n  final Node<E> newNode = new Node<>(l, e, null);\n  //last指针向后移\n  last = newNode;\n  //没有尾元素\n  if (l == null)\n    first = newNode;\n  else\n    //原尾元素next指向新下一个元素\n    l.next = newNode;\n  size++;\n  modCount++;\n}\n\npublic void add(int index, E element) {\n  //检查index是否越界，是则抛出运行时异常IndexOutOfBoundsException\n  checkPositionIndex(index);\n  //同add(E element)\n  if (index == size)\n    linkLast(element);\n  else\n    linkBefore(element, node(index));\n}\n\nvoid linkBefore(E e, Node<E> succ) {\n  //succ元素的前任prev\n  final Node<E> pred = succ.prev;\n  //新元素成功插入succ与其前任prev中间\n  final Node<E> newNode = new Node<>(pred, e, succ);\n  //于是succ的现任prev是新元素e\n  succ.prev = newNode;\n  if (pred == null)\n    first = newNode;\n  else\n    pred.next = newNode;\n  size++;\n  modCount++;\n}\n\nNode<E> node(int index) {\n  // assert isElementIndex(index);\n  //类似二分法遍历，没什么好说的，size >> 1 aka size/2\n  if (index < (size >> 1)) {\n    Node<E> x = first;\n    for (int i = 0; i < index; i++)\n      x = x.next;\n    return x;\n  } else {\n    Node<E> x = last;\n    for (int i = size - 1; i > index; i--)\n      x = x.prev;\n    return x;\n  }\n}\n\npublic E get(int index) {\n  checkElementIndex(index);\n  return node(index).item;\n}\n```\n\n## ArrayList源码\n\n往数组末尾插入元素当然快，但随机插入可就不一定了，需要将子数组往后移且或扩容（LinkedArray不\n需要扩容）。\n\n``` java\npublic boolean add(E e) {\n  //主要功能是扩容\n  ensureCapacityInternal(size + 1);\n  elementData[size++] = e;\n  return true;\n}\n\nprivate void ensureCapacityInternal(int minCapacity) {\n  //就是说，即使你在ArrayList(int initialCapacity)传小于10的值，elementData最小长度依然是10\n  if (elementData == EMPTY_ELEMENTDATA) {\n    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);\n  }\n\n  ensureExplicitCapacity(minCapacity);\n}\n\nprivate void ensureExplicitCapacity(int minCapacity) {\n  modCount++;\n\n  if (minCapacity - elementData.length > 0)\n    grow(minCapacity);\n}\n\n//扩容！！！\nprivate void grow(int minCapacity) {\n  int oldCapacity = elementData.length;\n  int newCapacity = oldCapacity + (oldCapacity >> 1);\n  if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n  if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n  elementData = Arrays.copyOf(elementData, newCapacity);\n}\n\npublic void add(int index, E element) {\n  rangeCheckForAdd(index);\n\n  ensureCapacityInternal(size + 1);\n  //这是ArrayList插入操作性能差的罪魁祸首\n  System.arraycopy(elementData, index, elementData, index + 1,\n    size - index);\n  elementData[index] = element;\n  size++;\n}\n```\n\n## 稍微总结一下\n\n``` java\n//ArrayList需要随机插入时，可以转为new LinkedList(new ArrayList());\npublic LinkedList(Collection<? extends E> c) {\n  this();\n  addAll(c);\n}\n\n//LinkedList需要随机查询时，可以转为new ArrayList(new LinkedList());\npublic ArrayList(Collection<? extends E> c) {\n  elementData = c.toArray();\n  size = elementData.length;\n  if (elementData.getClass() != Object[].class)\n  elementData = Arrays.copyOf(elementData, size, Object[].class);\n}\n```\n","slug":"20160628－浅谈Java集合框架－瞧瞧LinkedArray源码，查询效率为何如此低下？","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sh001h4ejddiau7c4b","content":"<p>平时用惯ArrayList插入查询，无视性能而忽略了LinkedArray，今日也反省反省，研究了一下<br>LinkedArray和ArrayList源码。其实理解两者原理和区别并不难，都是简单数据结构的应用。</p>\n<hr>\n<h2 id=\"LinkedArray源码\"><a href=\"#LinkedArray源码\" class=\"headerlink\" title=\"LinkedArray源码\"></a>LinkedArray源码</h2><p>双链表的好处就是有前后指针，插入只需要更新指针指向，随机查询则需要遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkLast(e);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个很好理解了，往列表尾端添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//现最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"comment\">//即将添加的元素</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">//last指针向后移</span></span><br><span class=\"line\">  last = newNode;</span><br><span class=\"line\">  <span class=\"comment\">//没有尾元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"comment\">//原尾元素next指向新下一个元素</span></span><br><span class=\"line\">    l.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//检查index是否越界，是则抛出运行时异常IndexOutOfBoundsException</span></span><br><span class=\"line\">  checkPositionIndex(index);</span><br><span class=\"line\">  <span class=\"comment\">//同add(E element)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">    linkLast(element);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//succ元素的前任prev</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">  <span class=\"comment\">//新元素成功插入succ与其前任prev中间</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">  <span class=\"comment\">//于是succ的现任prev是新元素e</span></span><br><span class=\"line\">  succ.prev = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    pred.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\">  <span class=\"comment\">//类似二分法遍历，没什么好说的，size &gt;&gt; 1 aka size/2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = first;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">      x = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = last;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">      x = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  checkElementIndex(index);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayList源码\"><a href=\"#ArrayList源码\" class=\"headerlink\" title=\"ArrayList源码\"></a>ArrayList源码</h2><p>往数组末尾插入元素当然快，但随机插入可就不一定了，需要将子数组往后移且或扩容（LinkedArray不<br>需要扩容）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//主要功能是扩容</span></span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">  elementData[size++] = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//就是说，即使你在ArrayList(int initialCapacity)传小于10的值，elementData最小长度依然是10</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩容！！！</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//这是ArrayList插入操作性能差的罪魁祸首</span></span><br><span class=\"line\">  System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">    size - index);</span><br><span class=\"line\">  elementData[index] = element;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"稍微总结一下\"><a href=\"#稍微总结一下\" class=\"headerlink\" title=\"稍微总结一下\"></a>稍微总结一下</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ArrayList需要随机插入时，可以转为new LinkedList(new ArrayList());</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>();</span><br><span class=\"line\">  addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LinkedList需要随机查询时，可以转为new ArrayList(new LinkedList());</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  elementData = c.toArray();</span><br><span class=\"line\">  size = elementData.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData.getClass() != Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>平时用惯ArrayList插入查询，无视性能而忽略了LinkedArray，今日也反省反省，研究了一下<br>LinkedArray和ArrayList源码。其实理解两者原理和区别并不难，都是简单数据结构的应用。</p>\n<hr>\n<h2 id=\"LinkedArray源码\"><a href=\"#LinkedArray源码\" class=\"headerlink\" title=\"LinkedArray源码\"></a>LinkedArray源码</h2><p>双链表的好处就是有前后指针，插入只需要更新指针指向，随机查询则需要遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  linkLast(e);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这个很好理解了，往列表尾端添加元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkLast</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//现最后一个元素</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; l = last;</span><br><span class=\"line\">  <span class=\"comment\">//即将添加的元素</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(l, e, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">  <span class=\"comment\">//last指针向后移</span></span><br><span class=\"line\">  last = newNode;</span><br><span class=\"line\">  <span class=\"comment\">//没有尾元素</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"comment\">//原尾元素next指向新下一个元素</span></span><br><span class=\"line\">    l.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//检查index是否越界，是则抛出运行时异常IndexOutOfBoundsException</span></span><br><span class=\"line\">  checkPositionIndex(index);</span><br><span class=\"line\">  <span class=\"comment\">//同add(E element)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index == size)</span><br><span class=\"line\">    linkLast(element);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    linkBefore(element, node(index));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">linkBefore</span><span class=\"params\">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//succ元素的前任prev</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class=\"line\">  <span class=\"comment\">//新元素成功插入succ与其前任prev中间</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> Node&lt;E&gt; newNode = <span class=\"keyword\">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class=\"line\">  <span class=\"comment\">//于是succ的现任prev是新元素e</span></span><br><span class=\"line\">  succ.prev = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    first = newNode;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    pred.next = newNode;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Node&lt;E&gt; <span class=\"title\">node</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// assert isElementIndex(index);</span></span><br><span class=\"line\">  <span class=\"comment\">//类似二分法遍历，没什么好说的，size &gt;&gt; 1 aka size/2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (index &lt; (size &gt;&gt; <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = first;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; index; i++)</span><br><span class=\"line\">      x = x.next;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    Node&lt;E&gt; x = last;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = size - <span class=\"number\">1</span>; i &gt; index; i--)</span><br><span class=\"line\">      x = x.prev;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">  checkElementIndex(index);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node(index).item;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayList源码\"><a href=\"#ArrayList源码\" class=\"headerlink\" title=\"ArrayList源码\"></a>ArrayList源码</h2><p>往数组末尾插入元素当然快，但随机插入可就不一定了，需要将子数组往后移且或扩容（LinkedArray不<br>需要扩容）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//主要功能是扩容</span></span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">  elementData[size++] = e;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureCapacityInternal</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//就是说，即使你在ArrayList(int initialCapacity)传小于10的值，elementData最小长度依然是10</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class=\"line\">    minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ensureExplicitCapacity(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">ensureExplicitCapacity</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  modCount++;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (minCapacity - elementData.length &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    grow(minCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//扩容！！！</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">grow</span><span class=\"params\">(<span class=\"keyword\">int</span> minCapacity)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> oldCapacity = elementData.length;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">  elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span> </span>&#123;</span><br><span class=\"line\">  rangeCheckForAdd(index);</span><br><span class=\"line\"></span><br><span class=\"line\">  ensureCapacityInternal(size + <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">//这是ArrayList插入操作性能差的罪魁祸首</span></span><br><span class=\"line\">  System.arraycopy(elementData, index, elementData, index + <span class=\"number\">1</span>,</span><br><span class=\"line\">    size - index);</span><br><span class=\"line\">  elementData[index] = element;</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"稍微总结一下\"><a href=\"#稍微总结一下\" class=\"headerlink\" title=\"稍微总结一下\"></a>稍微总结一下</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ArrayList需要随机插入时，可以转为new LinkedList(new ArrayList());</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>();</span><br><span class=\"line\">  addAll(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LinkedList需要随机查询时，可以转为new ArrayList(new LinkedList());</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ArrayList</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">  elementData = c.toArray();</span><br><span class=\"line\">  size = elementData.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (elementData.getClass() != Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"title\">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"浅谈Java集合框架-来看看LinkedHashMap是啥!","date":"2016-10-02T17:55:32.000Z","_content":"\n跳槽后，就没怎么看jdk，趁着十一看回点集合框架。我们知道HashMap是无序的，jdk也给我们提供了算是有序的HashMap，即LinkedHashMap。然而它只保留了操作的相对有序，而非TreeMap的Key自然有序。\n\n---\n\nLinkedHashMap显然继承了HashMap的绝大部分特性，新Entry则添加了`before`和`after`两个指针，以及维护Entry链表的方法。需要说明的是，HashMap.Entry的单链表无关，那只是用于解决hash冲突而已。\n\n``` java\n/**\n * LinkedHashMap entry.\n */\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n  //提供了双链表的指针\n  Entry<K,V> before, after;\n\n  Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n    super(hash, key, value, next);\n  }\n\n  //删除元素，改变头尾指针\n  private void remove() {\n      before.after = after;\n      after.before = before;\n  }\n\n  //链表头追加元素\n  private void addBefore(Entry<K,V> existingEntry) {\n      after  = existingEntry;\n      before = existingEntry.before;\n      before.after = this;\n      after.before = this;\n  }\n\n  /**\n   * 记录访问，即使将最新一次访问放在链表头部\n   */\n  void recordAccess(HashMap<K,V> m) {\n      LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n      //构造方法能够设置该值\n      if (lm.accessOrder) {\n          lm.modCount++;\n          remove();\n          addBefore(lm.header);\n      }\n  }\n\n  void recordRemoval(HashMap<K,V> m) {\n      remove();\n  }\n}\n\n//重写了get方法\npublic V get(Object key) {\n  Entry<K,V> e = (Entry<K,V>)getEntry(key);\n  if (e == null)\n      return null;\n  //访问记录\n  e.recordAccess(this);\n  return e.value;\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n  super.addEntry(hash, key, value, bucketIndex);\n\n  //移除最近且使用次数最少的元素\n  Entry<K,V> eldest = header.after;\n  if (removeEldestEntry(eldest)) {\n      removeEntryForKey(eldest.key);\n  }\n}\n\n//多了将Entry添加到双链表头\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n  HashMap.Entry<K,V> old = table[bucketIndex];\n  Entry<K,V> e = new Entry<>(hash, key, value, old);\n  table[bucketIndex] = e;\n  //在此\n  e.addBefore(header);\n  size++;\n}\n\n//重写该方法，可以实现lru，可以参考ehcache的SpoolingLinkedHashMap\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n  return false;\n}\n\n//判断value是否存在显然方便好多，直接遍历双链表\npublic boolean containsValue(Object value) {\n  if (value==null) {\n      for (Entry e = header.after; e != header; e = e.after)\n          if (e.value==null)\n              return true;\n  } else {\n      for (Entry e = header.after; e != header; e = e.after)\n          if (value.equals(e.value))\n              return true;\n  }\n  return false;\n}\n```\n","source":"_posts/20161003-浅谈Java集合框架-来看看LinkHashMap是啥.md","raw":"---\ntitle: 浅谈Java集合框架-来看看LinkedHashMap是啥!\ndate: 2016-10-03 01:55:32\ncategories:\n- 集合框架\ntags:\n- java\n- LinkedHashMap\n---\n\n跳槽后，就没怎么看jdk，趁着十一看回点集合框架。我们知道HashMap是无序的，jdk也给我们提供了算是有序的HashMap，即LinkedHashMap。然而它只保留了操作的相对有序，而非TreeMap的Key自然有序。\n\n---\n\nLinkedHashMap显然继承了HashMap的绝大部分特性，新Entry则添加了`before`和`after`两个指针，以及维护Entry链表的方法。需要说明的是，HashMap.Entry的单链表无关，那只是用于解决hash冲突而已。\n\n``` java\n/**\n * LinkedHashMap entry.\n */\nprivate static class Entry<K,V> extends HashMap.Entry<K,V> {\n  //提供了双链表的指针\n  Entry<K,V> before, after;\n\n  Entry(int hash, K key, V value, HashMap.Entry<K,V> next) {\n    super(hash, key, value, next);\n  }\n\n  //删除元素，改变头尾指针\n  private void remove() {\n      before.after = after;\n      after.before = before;\n  }\n\n  //链表头追加元素\n  private void addBefore(Entry<K,V> existingEntry) {\n      after  = existingEntry;\n      before = existingEntry.before;\n      before.after = this;\n      after.before = this;\n  }\n\n  /**\n   * 记录访问，即使将最新一次访问放在链表头部\n   */\n  void recordAccess(HashMap<K,V> m) {\n      LinkedHashMap<K,V> lm = (LinkedHashMap<K,V>)m;\n      //构造方法能够设置该值\n      if (lm.accessOrder) {\n          lm.modCount++;\n          remove();\n          addBefore(lm.header);\n      }\n  }\n\n  void recordRemoval(HashMap<K,V> m) {\n      remove();\n  }\n}\n\n//重写了get方法\npublic V get(Object key) {\n  Entry<K,V> e = (Entry<K,V>)getEntry(key);\n  if (e == null)\n      return null;\n  //访问记录\n  e.recordAccess(this);\n  return e.value;\n}\n\nvoid addEntry(int hash, K key, V value, int bucketIndex) {\n  super.addEntry(hash, key, value, bucketIndex);\n\n  //移除最近且使用次数最少的元素\n  Entry<K,V> eldest = header.after;\n  if (removeEldestEntry(eldest)) {\n      removeEntryForKey(eldest.key);\n  }\n}\n\n//多了将Entry添加到双链表头\nvoid createEntry(int hash, K key, V value, int bucketIndex) {\n  HashMap.Entry<K,V> old = table[bucketIndex];\n  Entry<K,V> e = new Entry<>(hash, key, value, old);\n  table[bucketIndex] = e;\n  //在此\n  e.addBefore(header);\n  size++;\n}\n\n//重写该方法，可以实现lru，可以参考ehcache的SpoolingLinkedHashMap\nprotected boolean removeEldestEntry(Map.Entry<K,V> eldest) {\n  return false;\n}\n\n//判断value是否存在显然方便好多，直接遍历双链表\npublic boolean containsValue(Object value) {\n  if (value==null) {\n      for (Entry e = header.after; e != header; e = e.after)\n          if (e.value==null)\n              return true;\n  } else {\n      for (Entry e = header.after; e != header; e = e.after)\n          if (value.equals(e.value))\n              return true;\n  }\n  return false;\n}\n```\n","slug":"20161003-浅谈Java集合框架-来看看LinkHashMap是啥","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sj001k4ejd59qw5m53","content":"<p>跳槽后，就没怎么看jdk，趁着十一看回点集合框架。我们知道HashMap是无序的，jdk也给我们提供了算是有序的HashMap，即LinkedHashMap。然而它只保留了操作的相对有序，而非TreeMap的Key自然有序。</p>\n<hr>\n<p>LinkedHashMap显然继承了HashMap的绝大部分特性，新Entry则添加了<code>before</code>和<code>after</code>两个指针，以及维护Entry链表的方法。需要说明的是，HashMap.Entry的单链表无关，那只是用于解决hash冲突而已。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedHashMap entry.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//提供了双链表的指针</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(<span class=\"keyword\">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(hash, key, value, next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//删除元素，改变头尾指针</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      before.after = after;</span><br><span class=\"line\">      after.before = before;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//链表头追加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addBefore</span><span class=\"params\">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class=\"line\">      after  = existingEntry;</span><br><span class=\"line\">      before = existingEntry.before;</span><br><span class=\"line\">      before.after = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      after.before = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 记录访问，即使将最新一次访问放在链表头部</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">      LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class=\"line\">      <span class=\"comment\">//构造方法能够设置该值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lm.accessOrder) &#123;</span><br><span class=\"line\">          lm.modCount++;</span><br><span class=\"line\">          remove();</span><br><span class=\"line\">          addBefore(lm.header);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordRemoval</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">      remove();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重写了get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//访问记录</span></span><br><span class=\"line\">  e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//移除最近且使用次数最少的元素</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; eldest = header.after;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class=\"line\">      removeEntryForKey(eldest.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了将Entry添加到双链表头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class=\"line\">  table[bucketIndex] = e;</span><br><span class=\"line\">  <span class=\"comment\">//在此</span></span><br><span class=\"line\">  e.addBefore(header);</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重写该方法，可以实现lru，可以参考ehcache的SpoolingLinkedHashMap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断value是否存在显然方便好多，直接遍历双链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.value==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (value.equals(e.value))</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>跳槽后，就没怎么看jdk，趁着十一看回点集合框架。我们知道HashMap是无序的，jdk也给我们提供了算是有序的HashMap，即LinkedHashMap。然而它只保留了操作的相对有序，而非TreeMap的Key自然有序。</p>\n<hr>\n<p>LinkedHashMap显然继承了HashMap的绝大部分特性，新Entry则添加了<code>before</code>和<code>after</code>两个指针，以及维护Entry链表的方法。需要说明的是，HashMap.Entry的单链表无关，那只是用于解决hash冲突而已。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * LinkedHashMap entry.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">HashMap</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//提供了双链表的指针</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\"></span><br><span class=\"line\">  Entry(<span class=\"keyword\">int</span> hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(hash, key, value, next);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//删除元素，改变头尾指针</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      before.after = after;</span><br><span class=\"line\">      after.before = before;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//链表头追加元素</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addBefore</span><span class=\"params\">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class=\"line\">      after  = existingEntry;</span><br><span class=\"line\">      before = existingEntry.before;</span><br><span class=\"line\">      before.after = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      after.before = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 记录访问，即使将最新一次访问放在链表头部</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordAccess</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">      LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class=\"line\">      <span class=\"comment\">//构造方法能够设置该值</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (lm.accessOrder) &#123;</span><br><span class=\"line\">          lm.modCount++;</span><br><span class=\"line\">          remove();</span><br><span class=\"line\">          addBefore(lm.header);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">recordRemoval</span><span class=\"params\">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">      remove();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重写了get方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//访问记录</span></span><br><span class=\"line\">  e.recordAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.addEntry(hash, key, value, bucketIndex);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//移除最近且使用次数最少的元素</span></span><br><span class=\"line\">  Entry&lt;K,V&gt; eldest = header.after;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (removeEldestEntry(eldest)) &#123;</span><br><span class=\"line\">      removeEntryForKey(eldest.key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//多了将Entry添加到双链表头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">int</span> bucketIndex)</span> </span>&#123;</span><br><span class=\"line\">  HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class=\"line\">  Entry&lt;K,V&gt; e = <span class=\"keyword\">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class=\"line\">  table[bucketIndex] = e;</span><br><span class=\"line\">  <span class=\"comment\">//在此</span></span><br><span class=\"line\">  e.addBefore(header);</span><br><span class=\"line\">  size++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//重写该方法，可以实现lru，可以参考ehcache的SpoolingLinkedHashMap</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//判断value是否存在显然方便好多，直接遍历双链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.value==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Entry e = header.after; e != header; e = e.after)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (value.equals(e.value))</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Linux－awk编程","date":"2016-07-28T03:23:32.000Z","_content":"\nawk是个刁到不行的文本处理命令，查看生产环境日志时，简直就是神操！\n新增：awk的数组\n\n---\n\n- ### awk命令\n\n基本格式就这两种\n``` bash\nawk -F'<默认是空格，这里可正则表达式也可字符>' 'commands' file(s)\n\n# 也可以用管道，\nll -t | awk -F':' '{print $2}'\n```\n\n通常awk做文本处理前还需要做一次过滤。\n``` bash\nawk -F':' '/<正则表达式or普通字符串>/{print $1}' /ect/passwd\n\n# 例如，我先用SQL为关键字做一次过滤\nawk -F':' '/SQL/{print $1, $5}' /etc/passwd\n#_mysql MySQL Server\n#_postgres PostgreSQL Server\n\n# 现在匹配有zF字符的文本\nawk -F':' '/[zF]/{print $1, $5}' /etc/passwd\n#_ftp FTP Daemon\n#_timezone AutoTimeZoneDaemon\n#_krbfast Kerberos FAST Account\n```\n\n- ### awk编程\n\nawk同样支持编程的形式来处理文本，以便在shell脚本中使用。\n\n关于awk的BEGIN与END\n``` bash\n# BEGIN后面的表达式，在awk扫描时运行，END后面的表达式在awk扫描后运行，例子在后面\nawk 'BEGIN{commands预处理} {commands开始扫描}; END{commands扫描后}' file(s)\n```\n\nawk也支持条件语句和循环语句，语法与C相近。\n``` bash\n# 条件语句\nif(command) {\n  //commands\n}\nelse if(command) {\n  //commands\n}\nelse {\n  //commands\n}\n\n# 循环语句\n# while、do/while、for、break、continue等关键字，都与C相同！\nfor(commands; commands; commands) {\n  //commands\n}\n```\n\n``` bash\nawk -F':' 'BEGIN{\n  count = 0\n}\n{\n  name[count] = $1; count++;\n}; END {\n  for(i = 0; i < NR; i++) {\n    if(name[i] != \"root\")\n      print \"编号\", i, \"名字\", name[i];\n  }\n}' /ect/passwd\n```\n","source":"_posts/20160728-Linux－awk编程.md","raw":"---\ntitle: Linux－awk编程\ndate: 2016-07-28 11:23:32\ncategories:\n- Linux\ntags:\n- awk\n- linux\n- 文本处理\n---\n\nawk是个刁到不行的文本处理命令，查看生产环境日志时，简直就是神操！\n新增：awk的数组\n\n---\n\n- ### awk命令\n\n基本格式就这两种\n``` bash\nawk -F'<默认是空格，这里可正则表达式也可字符>' 'commands' file(s)\n\n# 也可以用管道，\nll -t | awk -F':' '{print $2}'\n```\n\n通常awk做文本处理前还需要做一次过滤。\n``` bash\nawk -F':' '/<正则表达式or普通字符串>/{print $1}' /ect/passwd\n\n# 例如，我先用SQL为关键字做一次过滤\nawk -F':' '/SQL/{print $1, $5}' /etc/passwd\n#_mysql MySQL Server\n#_postgres PostgreSQL Server\n\n# 现在匹配有zF字符的文本\nawk -F':' '/[zF]/{print $1, $5}' /etc/passwd\n#_ftp FTP Daemon\n#_timezone AutoTimeZoneDaemon\n#_krbfast Kerberos FAST Account\n```\n\n- ### awk编程\n\nawk同样支持编程的形式来处理文本，以便在shell脚本中使用。\n\n关于awk的BEGIN与END\n``` bash\n# BEGIN后面的表达式，在awk扫描时运行，END后面的表达式在awk扫描后运行，例子在后面\nawk 'BEGIN{commands预处理} {commands开始扫描}; END{commands扫描后}' file(s)\n```\n\nawk也支持条件语句和循环语句，语法与C相近。\n``` bash\n# 条件语句\nif(command) {\n  //commands\n}\nelse if(command) {\n  //commands\n}\nelse {\n  //commands\n}\n\n# 循环语句\n# while、do/while、for、break、continue等关键字，都与C相同！\nfor(commands; commands; commands) {\n  //commands\n}\n```\n\n``` bash\nawk -F':' 'BEGIN{\n  count = 0\n}\n{\n  name[count] = $1; count++;\n}; END {\n  for(i = 0; i < NR; i++) {\n    if(name[i] != \"root\")\n      print \"编号\", i, \"名字\", name[i];\n  }\n}' /ect/passwd\n```\n","slug":"20160728-Linux－awk编程","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sk001n4ejd8iut9i5u","content":"<p>awk是个刁到不行的文本处理命令，查看生产环境日志时，简直就是神操！<br>新增：awk的数组</p>\n<hr>\n<ul>\n<li><h3 id=\"awk命令\"><a href=\"#awk命令\" class=\"headerlink\" title=\"awk命令\"></a>awk命令</h3></li>\n</ul>\n<p>基本格式就这两种</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">'&lt;默认是空格，这里可正则表达式也可字符&gt;'</span> <span class=\"string\">'commands'</span> file(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以用管道，</span></span><br><span class=\"line\">ll -t | awk -F<span class=\"string\">':'</span> <span class=\"string\">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>\n\n<p>通常awk做文本处理前还需要做一次过滤。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/&lt;正则表达式or普通字符串&gt;/&#123;print $1&#125;'</span> /ect/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如，我先用SQL为关键字做一次过滤</span></span><br><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/SQL/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\">#_mysql MySQL Server</span></span><br><span class=\"line\"><span class=\"comment\">#_postgres PostgreSQL Server</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 现在匹配有zF字符的文本</span></span><br><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/[zF]/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\">#_ftp FTP Daemon</span></span><br><span class=\"line\"><span class=\"comment\">#_timezone AutoTimeZoneDaemon</span></span><br><span class=\"line\"><span class=\"comment\">#_krbfast Kerberos FAST Account</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"awk编程\"><a href=\"#awk编程\" class=\"headerlink\" title=\"awk编程\"></a>awk编程</h3></li>\n</ul>\n<p>awk同样支持编程的形式来处理文本，以便在shell脚本中使用。</p>\n<p>关于awk的BEGIN与END</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># BEGIN后面的表达式，在awk扫描时运行，END后面的表达式在awk扫描后运行，例子在后面</span></span><br><span class=\"line\">awk <span class=\"string\">'BEGIN&#123;commands预处理&#125; &#123;commands开始扫描&#125;; END&#123;commands扫描后&#125;'</span> file(s)</span><br></pre></td></tr></table></figure>\n\n<p>awk也支持条件语句和循环语句，语法与C相近。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 条件语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">command</span>) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">command</span>) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 循环语句</span></span><br><span class=\"line\"><span class=\"comment\"># while、do/while、for、break、continue等关键字，都与C相同！</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(commands; commands; commands) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">  count = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  name[count] = $1; count++;</span></span><br><span class=\"line\"><span class=\"string\">&#125;; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">  for(i = 0; i &lt; NR; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if(name[i] != \"root\")</span></span><br><span class=\"line\"><span class=\"string\">      print \"编号\", i, \"名字\", name[i];</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> /ect/passwd</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>awk是个刁到不行的文本处理命令，查看生产环境日志时，简直就是神操！<br>新增：awk的数组</p>\n<hr>\n<ul>\n<li><h3 id=\"awk命令\"><a href=\"#awk命令\" class=\"headerlink\" title=\"awk命令\"></a>awk命令</h3></li>\n</ul>\n<p>基本格式就这两种</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">'&lt;默认是空格，这里可正则表达式也可字符&gt;'</span> <span class=\"string\">'commands'</span> file(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 也可以用管道，</span></span><br><span class=\"line\">ll -t | awk -F<span class=\"string\">':'</span> <span class=\"string\">'&#123;print $2&#125;'</span></span><br></pre></td></tr></table></figure>\n\n<p>通常awk做文本处理前还需要做一次过滤。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/&lt;正则表达式or普通字符串&gt;/&#123;print $1&#125;'</span> /ect/passwd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 例如，我先用SQL为关键字做一次过滤</span></span><br><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/SQL/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\">#_mysql MySQL Server</span></span><br><span class=\"line\"><span class=\"comment\">#_postgres PostgreSQL Server</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 现在匹配有zF字符的文本</span></span><br><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'/[zF]/&#123;print $1, $5&#125;'</span> /etc/passwd</span><br><span class=\"line\"><span class=\"comment\">#_ftp FTP Daemon</span></span><br><span class=\"line\"><span class=\"comment\">#_timezone AutoTimeZoneDaemon</span></span><br><span class=\"line\"><span class=\"comment\">#_krbfast Kerberos FAST Account</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"awk编程\"><a href=\"#awk编程\" class=\"headerlink\" title=\"awk编程\"></a>awk编程</h3></li>\n</ul>\n<p>awk同样支持编程的形式来处理文本，以便在shell脚本中使用。</p>\n<p>关于awk的BEGIN与END</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># BEGIN后面的表达式，在awk扫描时运行，END后面的表达式在awk扫描后运行，例子在后面</span></span><br><span class=\"line\">awk <span class=\"string\">'BEGIN&#123;commands预处理&#125; &#123;commands开始扫描&#125;; END&#123;commands扫描后&#125;'</span> file(s)</span><br></pre></td></tr></table></figure>\n\n<p>awk也支持条件语句和循环语句，语法与C相近。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 条件语句</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"built_in\">command</span>) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"built_in\">command</span>) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 循环语句</span></span><br><span class=\"line\"><span class=\"comment\"># while、do/while、for、break、continue等关键字，都与C相同！</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(commands; commands; commands) &#123;</span><br><span class=\"line\">  //commands</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">awk -F<span class=\"string\">':'</span> <span class=\"string\">'BEGIN&#123;</span></span><br><span class=\"line\"><span class=\"string\">  count = 0</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\">  name[count] = $1; count++;</span></span><br><span class=\"line\"><span class=\"string\">&#125;; END &#123;</span></span><br><span class=\"line\"><span class=\"string\">  for(i = 0; i &lt; NR; i++) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    if(name[i] != \"root\")</span></span><br><span class=\"line\"><span class=\"string\">      print \"编号\", i, \"名字\", name[i];</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;'</span> /ect/passwd</span><br></pre></td></tr></table></figure>\n"},{"title":"LinkedIn的Parseq + ning.httpclient异步请求框架的使用","date":"2016-12-02T11:44:58.000Z","_content":"\nParseq是Linkedin的一个异步框架，目前来说是个封装的较好而且易用的异步框架。除了普通的数据处理外，还支持网络请求、消息队列等。\n\n---\n\n## 1. Maven配置\n``` xml\n<dependency>\n    <groupId>com.linkedin.parseq</groupId>\n    <artifactId>parseq</artifactId>\n    <version>2.6.3</version>\n</dependency>\n<dependency>\n    <groupId>com.linkedin.parseq</groupId>\n    <artifactId>parseq-http-client</artifactId>\n    <version>2.6.3</version>\n</dependency>\n```\n\n## 2. 创建以及关闭线程池引擎Engine\n\n``` java\nprivate static ExecutorService taskService;\nprivate static ScheduledExecutorService timerService;\nprivate static Engine engine;\nprivate static JsonMapper mapper = new JsonMapper();\n\nstatic {\n    int numCores = Runtime.getRuntime().availableProcessors();\n    //可伸缩的线程池\n    taskService = new ThreadPoolExecutor(numCores, numCores * 2, 30, TimeUnit.SECONDS,\n    new ArrayBlockingQueue<Runnable>(100), new CallerRunsPolicy());\n\n    timerService = Executors.newScheduledThreadPool(numCores);\n    engine = new EngineBuilder().setTaskExecutor(taskService).setTimerScheduler(timerService).build();\n}\n\npublic static void shutdown() {\n    try {\n        if (engine != null) {\n            log.info(\"shutdown engine\");\n                engine.shutdown();\n                    engine.awaitTermination(3, TimeUnit.SECONDS);\n        }\n        if (taskService != null) {\n            log.info(\"shutdown taskService\");\n            taskService.shutdown();\n        }\n        if (timerService != null) {\n            log.info(\"shutdown timerService\");\n            timerService.shutdown();\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n## 3. 创建简单请求任务Task\n``` java\n  /**\n\t * 创建Post任务\n\t *\n\t * @param taskName\n\t *            任务名称\n\t * @param url\n\t *            目标链接\n\t * @param params\n\t *            查询参数\n\t * @param headers\n\t *            报头\n\t * @param body\n\t *            报文\n\t * @return\n\t */\npublic static Task<String> createPostTask(String taskName, String url, List<Param> params, Map<String, String> headers, String body) {\n                                    //设置重试机制\n    Task<String> reusableTask = Task.withRetryPolicy(createRetryPolicy(), () -> {\n        //final WrappedRequestBuilder builder = HttpClient.get(url); //Get请求\n        final WrappedRequestBuilder builder = HttpClient.post(url);\n        if (body != null)\n            builder.setBody(body);\n        if (headers != null)\n            headers.entrySet().forEach(entry -> builder.addHeader(entry.getKey(), entry.getValue()));\n        if (params != null)\n            builder.addQueryParams(params);\n        return builder.task().map(taskName, Response::getResponseBody)\n                //超时会抛出java.util.concurrent.TimeoutException\n                .withTimeout(5, TimeUnit.SECONDS);\n    })\n    //错误处理，出现异常错误，则默认输出\n    .recover(e -> \"{\\\"success:\\\":false}\");\n    return reusableTask;\n}\n```\n\n## 4.合并简单任务，以及任务结果处理\n\n回调接口，用以合并处理请求结果\n\n``` java\npublic interface TaskResultHandler {\n                        //SpringMvc异步请求\n    default void setResult(DeferredResult<GwResult> deferredResult, String result) {\n        deferredResult.setResult(result);\n    }\n}\n//函数式接口注释\n@FunctionalInterface\npublic interface TaskResultHandler1 extends TaskResultHandler {\n    String handle(String result);\n}\n@FunctionalInterface\npublic interface TaskResultHandler2 extends TaskResultHandler {\n    String handle(String result1, String result2);\n}\n\n// ..................n个TaskResultHandler.................\n```\n\n任务的合并\n\n``` java\n       /**\n\t * 合并任务\n\t *\n\t * @param taskName\n\t *            任务名称\n\t * @param task1\n\t * @param task2\n\t * @param handler\n\t *            任务结果处理\n\t * @return\n\t */\npublic static Task<String> merge(String taskName, Task<String> task1, Task<String> task2, TaskResultHandler2 handler) {\n    return Task.par(task1, task2)\n        //合并处理两个任务结果\n        .map(taskName, (result1, result2) -> handler.handle(result1, result2));\n}\n\npublic static Task<String> merge(String taskName, Task<String> task1, Task<String> task2, Task<String> task3,\n\t\t\tTaskResultHandler3 handler) {\n    return Task.par(task1, task2, task3)\n         //合并处理三个任务结果\n        .map(taskName,(result1, result2, result3) -> handler.handle(result1, result2, result3));\n}\n\n// ..................n个merge方法.................\n```\n\n任务开跑！\n\n``` java\npublic static void run(Task<String> task, TaskResultHandler1 handler, DeferredResult<GwResult> deferredResult) {\n    engine.run(task.map(\"runTask1\", (result) -> handler.handle(result))\n            .andThen(result -> {\n                if (deferredResult != null)\n                    handler.setResult(deferredResult, result);\n                else\n                    log.info(result);\n             }).recover(e -> {\n                    //输出系统错误结果\n                    deferredResult.setResult(gwResult);\n                    return mapper.toJson(gwResult);\n            }));\n}\n\npublic static void run(Task<String> task1, Task<String> task2, TaskResultHandler2 handler,\n\t\t\tDeferredResult<GwResult> deferredResult) {\n    Task<String> tasks = merge(\"runTask2\", task1, task2, handler)\n        //setResultElsePrintLog与上面的方法相同\n        .andThen(setResultElsePrintLog(handler, deferredResult))\n        ////recoverHandle与上面的方法相同\n        .recover(recoverHandle(deferredResult));\n    engine.run(tasks);\n}\n\n// ..................n个run方法.................\n```\n\n## 5.异常处理以及重试机制\n\n``` java\nprivate static RetryPolicy createRetryPolicy() {\n    return new RetryPolicyBuilder().setTerminationPolicy(TerminationPolicy.limitAttempts(3))\n        // .setErrorClassifier(null)\n        .build();\n}\n```\n","source":"_posts/20161202-LinkedIn的Parseq-ning-httpclient异步请求框架的使用.md","raw":"---\ntitle: LinkedIn的Parseq + ning.httpclient异步请求框架的使用\ndate: 2016-12-02 19:44:58\ncategories:\n- 开源框架\ntags:\n- java\n- 异步框架\n- parseq\n---\n\nParseq是Linkedin的一个异步框架，目前来说是个封装的较好而且易用的异步框架。除了普通的数据处理外，还支持网络请求、消息队列等。\n\n---\n\n## 1. Maven配置\n``` xml\n<dependency>\n    <groupId>com.linkedin.parseq</groupId>\n    <artifactId>parseq</artifactId>\n    <version>2.6.3</version>\n</dependency>\n<dependency>\n    <groupId>com.linkedin.parseq</groupId>\n    <artifactId>parseq-http-client</artifactId>\n    <version>2.6.3</version>\n</dependency>\n```\n\n## 2. 创建以及关闭线程池引擎Engine\n\n``` java\nprivate static ExecutorService taskService;\nprivate static ScheduledExecutorService timerService;\nprivate static Engine engine;\nprivate static JsonMapper mapper = new JsonMapper();\n\nstatic {\n    int numCores = Runtime.getRuntime().availableProcessors();\n    //可伸缩的线程池\n    taskService = new ThreadPoolExecutor(numCores, numCores * 2, 30, TimeUnit.SECONDS,\n    new ArrayBlockingQueue<Runnable>(100), new CallerRunsPolicy());\n\n    timerService = Executors.newScheduledThreadPool(numCores);\n    engine = new EngineBuilder().setTaskExecutor(taskService).setTimerScheduler(timerService).build();\n}\n\npublic static void shutdown() {\n    try {\n        if (engine != null) {\n            log.info(\"shutdown engine\");\n                engine.shutdown();\n                    engine.awaitTermination(3, TimeUnit.SECONDS);\n        }\n        if (taskService != null) {\n            log.info(\"shutdown taskService\");\n            taskService.shutdown();\n        }\n        if (timerService != null) {\n            log.info(\"shutdown timerService\");\n            timerService.shutdown();\n        }\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n## 3. 创建简单请求任务Task\n``` java\n  /**\n\t * 创建Post任务\n\t *\n\t * @param taskName\n\t *            任务名称\n\t * @param url\n\t *            目标链接\n\t * @param params\n\t *            查询参数\n\t * @param headers\n\t *            报头\n\t * @param body\n\t *            报文\n\t * @return\n\t */\npublic static Task<String> createPostTask(String taskName, String url, List<Param> params, Map<String, String> headers, String body) {\n                                    //设置重试机制\n    Task<String> reusableTask = Task.withRetryPolicy(createRetryPolicy(), () -> {\n        //final WrappedRequestBuilder builder = HttpClient.get(url); //Get请求\n        final WrappedRequestBuilder builder = HttpClient.post(url);\n        if (body != null)\n            builder.setBody(body);\n        if (headers != null)\n            headers.entrySet().forEach(entry -> builder.addHeader(entry.getKey(), entry.getValue()));\n        if (params != null)\n            builder.addQueryParams(params);\n        return builder.task().map(taskName, Response::getResponseBody)\n                //超时会抛出java.util.concurrent.TimeoutException\n                .withTimeout(5, TimeUnit.SECONDS);\n    })\n    //错误处理，出现异常错误，则默认输出\n    .recover(e -> \"{\\\"success:\\\":false}\");\n    return reusableTask;\n}\n```\n\n## 4.合并简单任务，以及任务结果处理\n\n回调接口，用以合并处理请求结果\n\n``` java\npublic interface TaskResultHandler {\n                        //SpringMvc异步请求\n    default void setResult(DeferredResult<GwResult> deferredResult, String result) {\n        deferredResult.setResult(result);\n    }\n}\n//函数式接口注释\n@FunctionalInterface\npublic interface TaskResultHandler1 extends TaskResultHandler {\n    String handle(String result);\n}\n@FunctionalInterface\npublic interface TaskResultHandler2 extends TaskResultHandler {\n    String handle(String result1, String result2);\n}\n\n// ..................n个TaskResultHandler.................\n```\n\n任务的合并\n\n``` java\n       /**\n\t * 合并任务\n\t *\n\t * @param taskName\n\t *            任务名称\n\t * @param task1\n\t * @param task2\n\t * @param handler\n\t *            任务结果处理\n\t * @return\n\t */\npublic static Task<String> merge(String taskName, Task<String> task1, Task<String> task2, TaskResultHandler2 handler) {\n    return Task.par(task1, task2)\n        //合并处理两个任务结果\n        .map(taskName, (result1, result2) -> handler.handle(result1, result2));\n}\n\npublic static Task<String> merge(String taskName, Task<String> task1, Task<String> task2, Task<String> task3,\n\t\t\tTaskResultHandler3 handler) {\n    return Task.par(task1, task2, task3)\n         //合并处理三个任务结果\n        .map(taskName,(result1, result2, result3) -> handler.handle(result1, result2, result3));\n}\n\n// ..................n个merge方法.................\n```\n\n任务开跑！\n\n``` java\npublic static void run(Task<String> task, TaskResultHandler1 handler, DeferredResult<GwResult> deferredResult) {\n    engine.run(task.map(\"runTask1\", (result) -> handler.handle(result))\n            .andThen(result -> {\n                if (deferredResult != null)\n                    handler.setResult(deferredResult, result);\n                else\n                    log.info(result);\n             }).recover(e -> {\n                    //输出系统错误结果\n                    deferredResult.setResult(gwResult);\n                    return mapper.toJson(gwResult);\n            }));\n}\n\npublic static void run(Task<String> task1, Task<String> task2, TaskResultHandler2 handler,\n\t\t\tDeferredResult<GwResult> deferredResult) {\n    Task<String> tasks = merge(\"runTask2\", task1, task2, handler)\n        //setResultElsePrintLog与上面的方法相同\n        .andThen(setResultElsePrintLog(handler, deferredResult))\n        ////recoverHandle与上面的方法相同\n        .recover(recoverHandle(deferredResult));\n    engine.run(tasks);\n}\n\n// ..................n个run方法.................\n```\n\n## 5.异常处理以及重试机制\n\n``` java\nprivate static RetryPolicy createRetryPolicy() {\n    return new RetryPolicyBuilder().setTerminationPolicy(TerminationPolicy.limitAttempts(3))\n        // .setErrorClassifier(null)\n        .build();\n}\n```\n","slug":"20161202-LinkedIn的Parseq-ning-httpclient异步请求框架的使用","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sl001r4ejd3vt56rk3","content":"<p>Parseq是Linkedin的一个异步框架，目前来说是个封装的较好而且易用的异步框架。除了普通的数据处理外，还支持网络请求、消息队列等。</p>\n<hr>\n<h2 id=\"1-Maven配置\"><a href=\"#1-Maven配置\" class=\"headerlink\" title=\"1. Maven配置\"></a>1. Maven配置</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.linkedin.parseq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parseq<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.linkedin.parseq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parseq-http-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-创建以及关闭线程池引擎Engine\"><a href=\"#2-创建以及关闭线程池引擎Engine\" class=\"headerlink\" title=\"2. 创建以及关闭线程池引擎Engine\"></a>2. 创建以及关闭线程池引擎Engine</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService taskService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ScheduledExecutorService timerService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Engine engine;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JsonMapper mapper = <span class=\"keyword\">new</span> JsonMapper();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numCores = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">    <span class=\"comment\">//可伸缩的线程池</span></span><br><span class=\"line\">    taskService = <span class=\"keyword\">new</span> ThreadPoolExecutor(numCores, numCores * <span class=\"number\">2</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class=\"number\">100</span>), <span class=\"keyword\">new</span> CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">    timerService = Executors.newScheduledThreadPool(numCores);</span><br><span class=\"line\">    engine = <span class=\"keyword\">new</span> EngineBuilder().setTaskExecutor(taskService).setTimerScheduler(timerService).build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (engine != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown engine\"</span>);</span><br><span class=\"line\">                engine.shutdown();</span><br><span class=\"line\">                    engine.awaitTermination(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (taskService != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown taskService\"</span>);</span><br><span class=\"line\">            taskService.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timerService != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown timerService\"</span>);</span><br><span class=\"line\">            timerService.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-创建简单请求任务Task\"><a href=\"#3-创建简单请求任务Task\" class=\"headerlink\" title=\"3. 创建简单请求任务Task\"></a>3. 创建简单请求任务Task</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建Post任务</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> taskName</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">\t *            目标链接</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> params</span></span><br><span class=\"line\"><span class=\"comment\">\t *            查询参数</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> headers</span></span><br><span class=\"line\"><span class=\"comment\">\t *            报头</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> body</span></span><br><span class=\"line\"><span class=\"comment\">\t *            报文</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">createPostTask</span><span class=\"params\">(String taskName, String url, List&lt;Param&gt; params, Map&lt;String, String&gt; headers, String body)</span> </span>&#123;</span><br><span class=\"line\">                                    <span class=\"comment\">//设置重试机制</span></span><br><span class=\"line\">    Task&lt;String&gt; reusableTask = Task.withRetryPolicy(createRetryPolicy(), () -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//final WrappedRequestBuilder builder = HttpClient.get(url); //Get请求</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WrappedRequestBuilder builder = HttpClient.post(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (body != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            builder.setBody(body);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headers != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            headers.entrySet().forEach(entry -&gt; builder.addHeader(entry.getKey(), entry.getValue()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (params != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            builder.addQueryParams(params);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder.task().map(taskName, Response::getResponseBody)</span><br><span class=\"line\">                <span class=\"comment\">//超时会抛出java.util.concurrent.TimeoutException</span></span><br><span class=\"line\">                .withTimeout(<span class=\"number\">5</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//错误处理，出现异常错误，则默认输出</span></span><br><span class=\"line\">    .recover(e -&gt; <span class=\"string\">\"&#123;\\\"success:\\\":false&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reusableTask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-合并简单任务，以及任务结果处理\"><a href=\"#4-合并简单任务，以及任务结果处理\" class=\"headerlink\" title=\"4.合并简单任务，以及任务结果处理\"></a>4.合并简单任务，以及任务结果处理</h2><p>回调接口，用以合并处理请求结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//SpringMvc异步请求</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">setResult</span><span class=\"params\">(DeferredResult&lt;GwResult&gt; deferredResult, String result)</span> </span>&#123;</span><br><span class=\"line\">        deferredResult.setResult(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//函数式接口注释</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler1</span> <span class=\"keyword\">extends</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">handle</span><span class=\"params\">(String result)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler2</span> <span class=\"keyword\">extends</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">handle</span><span class=\"params\">(String result1, String result2)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个TaskResultHandler.................</span></span><br></pre></td></tr></table></figure>\n\n<p>任务的合并</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 合并任务</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> taskName</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> task1</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> task2</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务结果处理</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">merge</span><span class=\"params\">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Task.par(task1, task2)</span><br><span class=\"line\">        <span class=\"comment\">//合并处理两个任务结果</span></span><br><span class=\"line\">        .map(taskName, (result1, result2) -&gt; handler.handle(result1, result2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">merge</span><span class=\"params\">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, Task&lt;String&gt; task3,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tTaskResultHandler3 handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Task.par(task1, task2, task3)</span><br><span class=\"line\">         <span class=\"comment\">//合并处理三个任务结果</span></span><br><span class=\"line\">        .map(taskName,(result1, result2, result3) -&gt; handler.handle(result1, result2, result3));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个merge方法.................</span></span><br></pre></td></tr></table></figure>\n\n<p>任务开跑！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task&lt;String&gt; task, TaskResultHandler1 handler, DeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class=\"line\">    engine.run(task.map(<span class=\"string\">\"runTask1\"</span>, (result) -&gt; handler.handle(result))</span><br><span class=\"line\">            .andThen(result -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (deferredResult != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    handler.setResult(deferredResult, result);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    log.info(result);</span><br><span class=\"line\">             &#125;).recover(e -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//输出系统错误结果</span></span><br><span class=\"line\">                    deferredResult.setResult(gwResult);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mapper.toJson(gwResult);</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tDeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class=\"line\">    Task&lt;String&gt; tasks = merge(<span class=\"string\">\"runTask2\"</span>, task1, task2, handler)</span><br><span class=\"line\">        <span class=\"comment\">//setResultElsePrintLog与上面的方法相同</span></span><br><span class=\"line\">        .andThen(setResultElsePrintLog(handler, deferredResult))</span><br><span class=\"line\">        <span class=\"comment\">////recoverHandle与上面的方法相同</span></span><br><span class=\"line\">        .recover(recoverHandle(deferredResult));</span><br><span class=\"line\">    engine.run(tasks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个run方法.................</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-异常处理以及重试机制\"><a href=\"#5-异常处理以及重试机制\" class=\"headerlink\" title=\"5.异常处理以及重试机制\"></a>5.异常处理以及重试机制</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> RetryPolicy <span class=\"title\">createRetryPolicy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RetryPolicyBuilder().setTerminationPolicy(TerminationPolicy.limitAttempts(<span class=\"number\">3</span>))</span><br><span class=\"line\">        <span class=\"comment\">// .setErrorClassifier(null)</span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Parseq是Linkedin的一个异步框架，目前来说是个封装的较好而且易用的异步框架。除了普通的数据处理外，还支持网络请求、消息队列等。</p>\n<hr>\n<h2 id=\"1-Maven配置\"><a href=\"#1-Maven配置\" class=\"headerlink\" title=\"1. Maven配置\"></a>1. Maven配置</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.linkedin.parseq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parseq<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.linkedin.parseq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parseq-http-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-创建以及关闭线程池引擎Engine\"><a href=\"#2-创建以及关闭线程池引擎Engine\" class=\"headerlink\" title=\"2. 创建以及关闭线程池引擎Engine\"></a>2. 创建以及关闭线程池引擎Engine</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ExecutorService taskService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ScheduledExecutorService timerService;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Engine engine;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> JsonMapper mapper = <span class=\"keyword\">new</span> JsonMapper();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numCores = Runtime.getRuntime().availableProcessors();</span><br><span class=\"line\">    <span class=\"comment\">//可伸缩的线程池</span></span><br><span class=\"line\">    taskService = <span class=\"keyword\">new</span> ThreadPoolExecutor(numCores, numCores * <span class=\"number\">2</span>, <span class=\"number\">30</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">    <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class=\"number\">100</span>), <span class=\"keyword\">new</span> CallerRunsPolicy());</span><br><span class=\"line\"></span><br><span class=\"line\">    timerService = Executors.newScheduledThreadPool(numCores);</span><br><span class=\"line\">    engine = <span class=\"keyword\">new</span> EngineBuilder().setTaskExecutor(taskService).setTimerScheduler(timerService).build();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (engine != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown engine\"</span>);</span><br><span class=\"line\">                engine.shutdown();</span><br><span class=\"line\">                    engine.awaitTermination(<span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (taskService != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown taskService\"</span>);</span><br><span class=\"line\">            taskService.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (timerService != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"shutdown timerService\"</span>);</span><br><span class=\"line\">            timerService.shutdown();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-创建简单请求任务Task\"><a href=\"#3-创建简单请求任务Task\" class=\"headerlink\" title=\"3. 创建简单请求任务Task\"></a>3. 创建简单请求任务Task</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 创建Post任务</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> taskName</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> url</span></span><br><span class=\"line\"><span class=\"comment\">\t *            目标链接</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> params</span></span><br><span class=\"line\"><span class=\"comment\">\t *            查询参数</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> headers</span></span><br><span class=\"line\"><span class=\"comment\">\t *            报头</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> body</span></span><br><span class=\"line\"><span class=\"comment\">\t *            报文</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">createPostTask</span><span class=\"params\">(String taskName, String url, List&lt;Param&gt; params, Map&lt;String, String&gt; headers, String body)</span> </span>&#123;</span><br><span class=\"line\">                                    <span class=\"comment\">//设置重试机制</span></span><br><span class=\"line\">    Task&lt;String&gt; reusableTask = Task.withRetryPolicy(createRetryPolicy(), () -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//final WrappedRequestBuilder builder = HttpClient.get(url); //Get请求</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WrappedRequestBuilder builder = HttpClient.post(url);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (body != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            builder.setBody(body);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (headers != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            headers.entrySet().forEach(entry -&gt; builder.addHeader(entry.getKey(), entry.getValue()));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (params != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            builder.addQueryParams(params);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder.task().map(taskName, Response::getResponseBody)</span><br><span class=\"line\">                <span class=\"comment\">//超时会抛出java.util.concurrent.TimeoutException</span></span><br><span class=\"line\">                .withTimeout(<span class=\"number\">5</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">//错误处理，出现异常错误，则默认输出</span></span><br><span class=\"line\">    .recover(e -&gt; <span class=\"string\">\"&#123;\\\"success:\\\":false&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reusableTask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-合并简单任务，以及任务结果处理\"><a href=\"#4-合并简单任务，以及任务结果处理\" class=\"headerlink\" title=\"4.合并简单任务，以及任务结果处理\"></a>4.合并简单任务，以及任务结果处理</h2><p>回调接口，用以合并处理请求结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"comment\">//SpringMvc异步请求</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">setResult</span><span class=\"params\">(DeferredResult&lt;GwResult&gt; deferredResult, String result)</span> </span>&#123;</span><br><span class=\"line\">        deferredResult.setResult(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//函数式接口注释</span></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler1</span> <span class=\"keyword\">extends</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">handle</span><span class=\"params\">(String result)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TaskResultHandler2</span> <span class=\"keyword\">extends</span> <span class=\"title\">TaskResultHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">handle</span><span class=\"params\">(String result1, String result2)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个TaskResultHandler.................</span></span><br></pre></td></tr></table></figure>\n\n<p>任务的合并</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 合并任务</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> taskName</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务名称</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> task1</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> task2</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\">\t *            任务结果处理</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">merge</span><span class=\"params\">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Task.par(task1, task2)</span><br><span class=\"line\">        <span class=\"comment\">//合并处理两个任务结果</span></span><br><span class=\"line\">        .map(taskName, (result1, result2) -&gt; handler.handle(result1, result2));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Task&lt;String&gt; <span class=\"title\">merge</span><span class=\"params\">(String taskName, Task&lt;String&gt; task1, Task&lt;String&gt; task2, Task&lt;String&gt; task3,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tTaskResultHandler3 handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Task.par(task1, task2, task3)</span><br><span class=\"line\">         <span class=\"comment\">//合并处理三个任务结果</span></span><br><span class=\"line\">        .map(taskName,(result1, result2, result3) -&gt; handler.handle(result1, result2, result3));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个merge方法.................</span></span><br></pre></td></tr></table></figure>\n\n<p>任务开跑！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task&lt;String&gt; task, TaskResultHandler1 handler, DeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class=\"line\">    engine.run(task.map(<span class=\"string\">\"runTask1\"</span>, (result) -&gt; handler.handle(result))</span><br><span class=\"line\">            .andThen(result -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (deferredResult != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    handler.setResult(deferredResult, result);</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                    log.info(result);</span><br><span class=\"line\">             &#125;).recover(e -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//输出系统错误结果</span></span><br><span class=\"line\">                    deferredResult.setResult(gwResult);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> mapper.toJson(gwResult);</span><br><span class=\"line\">            &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Task&lt;String&gt; task1, Task&lt;String&gt; task2, TaskResultHandler2 handler,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\tDeferredResult&lt;GwResult&gt; deferredResult)</span> </span>&#123;</span><br><span class=\"line\">    Task&lt;String&gt; tasks = merge(<span class=\"string\">\"runTask2\"</span>, task1, task2, handler)</span><br><span class=\"line\">        <span class=\"comment\">//setResultElsePrintLog与上面的方法相同</span></span><br><span class=\"line\">        .andThen(setResultElsePrintLog(handler, deferredResult))</span><br><span class=\"line\">        <span class=\"comment\">////recoverHandle与上面的方法相同</span></span><br><span class=\"line\">        .recover(recoverHandle(deferredResult));</span><br><span class=\"line\">    engine.run(tasks);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ..................n个run方法.................</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-异常处理以及重试机制\"><a href=\"#5-异常处理以及重试机制\" class=\"headerlink\" title=\"5.异常处理以及重试机制\"></a>5.异常处理以及重试机制</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> RetryPolicy <span class=\"title\">createRetryPolicy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> RetryPolicyBuilder().setTerminationPolicy(TerminationPolicy.limitAttempts(<span class=\"number\">3</span>))</span><br><span class=\"line\">        <span class=\"comment\">// .setErrorClassifier(null)</span></span><br><span class=\"line\">        .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"初学Clojure—循环与尾递归","date":"2017-01-19T14:53:37.000Z","_content":"\nLisp语言中，循环不像Java提供`for`、`while`等语法，经典用法还是使用递归，clojure也有提供loop循环。在clojure中，递归、循环息息相关的工具`recur`，它的存在跟clojure实现在jvm之上有所关系，其原因也跟Java为什么有`for`、`while`等语法相关。\n\n---\n\n- ### <font color=#0099ff>recur是什么？怎么用？</font>\n\n`recur`相对于clojure的宏和函数来说，是个十分底层的程序控制操作，用于循环或递归。可以在不消耗堆栈的情况下，回到函数或循环体的最顶端。\n\n例如在函数中使用`recur`实现递归：\n``` clojure\n;实至名归的尾递归！\n(defn my_dec [x]\n  (if (< x 0)\n    x\n    ;如果大于0，则回到my_dec，重新进入\n    (recur (dec x))))\n```\n又或者是loop循环：\n``` clojure\n;看起来还不如上面的递归呢！～\n(loop [x 100]\n  (if (< x 0)\n    x\n    (recur (dec x))))\n```\n\n<font color=#f28080>`recur`一定要放在结尾位置！不然clojure编译时会报错！比如我在`my_dec [x]`的`if`包多一层`int`会怎样？</font>\n\n``` clojure\n(defn my_dec [x]\n  (int (if (< x 0)\n         x\n         (recur (dec x)))))\n;CompilerException java.lang.UnsupportedOperationException: Can only recur from tail position\n```\n<font color=#f28080>显然编译不了，异常信息告诉你，你的`recur`不是放在结束位置，因为`if`返回值之后还有其他动作。</font>\n\n\n- ### <font color=#0099ff>为什么尾递归不是真正的尾递归？</font>\n\n上面的递归递减的例子才是真正的尾递归！为啥？\n\nok！在[定义函数](http://huangzehong.me/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/)有个计算阶乘的例子。\n``` clojure\n(letfn [(factorial [x]\n          (factorial_2 (- x 1) x))\n        (factorial_2 [x y]\n          (if (< x 1)\n            y\n            (factorial_2 (- x 1) (* x y))))]\n  #(factorial %))\n```\n\n如果在Java中实现“尾递归”，我可以这样写：\n``` Java\npublic  int factorial(int x, int sum) {\n  if (x < 2)\n    return sum;\n  return factorial(x - 1, sum * x);\n}\n```\n如果用Java的循环，可以这样写：\n``` Java\n//jvm没有实现尾递归优化支持，一大半原因是有了for等循环体，就觉得没必要吧。\npublic int factorial(int x) {\n  int y = 1;\n  for(;x > 1; x--)\n    y = y * x;\n  return y;\n}\n```\n需要先知道的是，jvm不知道为毛，一直不想实现尾调用优化；所以`int factorial(x, sum)`虽然代码是尾递归格式，但并没什么卵用，这对于运行在它上面的函数式编程语言也是个坑！\n\n正因为如此，在jvm上运行的clojure自然支持不了`factorial[x y]`这样的隐式尾递归，但提供了`recur`这个十分底层的工具（类似于goto），让我们显示地表示出尾递归。顺便说一句，同样运行在jvm的scala实现了尾递归，虽然十分有限，只支持严格尾递归，不明白clojure为啥也不搞一个。\n\n- ### <font color=#0099ff>clojure还有其他循环</font>\n\n尽管`recur`能帮你实现高效的尾递归，但依然需要谨慎，适当时候才使用。并不是因为有副作用，而是clojure提供了支持某些循环的宏，例如`dotimes`、`doseq`、`while`（他们底层也是`recur`），这已经能够满足大多时候的需求了。\n\n``` clojure\n(dotimes [i 10]\n  (println \"number:\" i))\n\n(def j 10)\n(while (> j 0)\n  (println \"number:\" j)\n  (def j (dec j)))\n```\n","source":"_posts/20170119-初学Clojure—循环与尾递归.md","raw":"---\ntitle: 初学Clojure—循环与尾递归\ndate: 2017-01-19 22:53:37\ncategories:\n- 函数编程\ntags:\n- clojure\n- 教程\n- 并发编程语言\n---\n\nLisp语言中，循环不像Java提供`for`、`while`等语法，经典用法还是使用递归，clojure也有提供loop循环。在clojure中，递归、循环息息相关的工具`recur`，它的存在跟clojure实现在jvm之上有所关系，其原因也跟Java为什么有`for`、`while`等语法相关。\n\n---\n\n- ### <font color=#0099ff>recur是什么？怎么用？</font>\n\n`recur`相对于clojure的宏和函数来说，是个十分底层的程序控制操作，用于循环或递归。可以在不消耗堆栈的情况下，回到函数或循环体的最顶端。\n\n例如在函数中使用`recur`实现递归：\n``` clojure\n;实至名归的尾递归！\n(defn my_dec [x]\n  (if (< x 0)\n    x\n    ;如果大于0，则回到my_dec，重新进入\n    (recur (dec x))))\n```\n又或者是loop循环：\n``` clojure\n;看起来还不如上面的递归呢！～\n(loop [x 100]\n  (if (< x 0)\n    x\n    (recur (dec x))))\n```\n\n<font color=#f28080>`recur`一定要放在结尾位置！不然clojure编译时会报错！比如我在`my_dec [x]`的`if`包多一层`int`会怎样？</font>\n\n``` clojure\n(defn my_dec [x]\n  (int (if (< x 0)\n         x\n         (recur (dec x)))))\n;CompilerException java.lang.UnsupportedOperationException: Can only recur from tail position\n```\n<font color=#f28080>显然编译不了，异常信息告诉你，你的`recur`不是放在结束位置，因为`if`返回值之后还有其他动作。</font>\n\n\n- ### <font color=#0099ff>为什么尾递归不是真正的尾递归？</font>\n\n上面的递归递减的例子才是真正的尾递归！为啥？\n\nok！在[定义函数](http://huangzehong.me/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/)有个计算阶乘的例子。\n``` clojure\n(letfn [(factorial [x]\n          (factorial_2 (- x 1) x))\n        (factorial_2 [x y]\n          (if (< x 1)\n            y\n            (factorial_2 (- x 1) (* x y))))]\n  #(factorial %))\n```\n\n如果在Java中实现“尾递归”，我可以这样写：\n``` Java\npublic  int factorial(int x, int sum) {\n  if (x < 2)\n    return sum;\n  return factorial(x - 1, sum * x);\n}\n```\n如果用Java的循环，可以这样写：\n``` Java\n//jvm没有实现尾递归优化支持，一大半原因是有了for等循环体，就觉得没必要吧。\npublic int factorial(int x) {\n  int y = 1;\n  for(;x > 1; x--)\n    y = y * x;\n  return y;\n}\n```\n需要先知道的是，jvm不知道为毛，一直不想实现尾调用优化；所以`int factorial(x, sum)`虽然代码是尾递归格式，但并没什么卵用，这对于运行在它上面的函数式编程语言也是个坑！\n\n正因为如此，在jvm上运行的clojure自然支持不了`factorial[x y]`这样的隐式尾递归，但提供了`recur`这个十分底层的工具（类似于goto），让我们显示地表示出尾递归。顺便说一句，同样运行在jvm的scala实现了尾递归，虽然十分有限，只支持严格尾递归，不明白clojure为啥也不搞一个。\n\n- ### <font color=#0099ff>clojure还有其他循环</font>\n\n尽管`recur`能帮你实现高效的尾递归，但依然需要谨慎，适当时候才使用。并不是因为有副作用，而是clojure提供了支持某些循环的宏，例如`dotimes`、`doseq`、`while`（他们底层也是`recur`），这已经能够满足大多时候的需求了。\n\n``` clojure\n(dotimes [i 10]\n  (println \"number:\" i))\n\n(def j 10)\n(while (> j 0)\n  (println \"number:\" j)\n  (def j (dec j)))\n```\n","slug":"20170119-初学Clojure—循环与尾递归","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sn001v4ejdb02m2m7g","content":"<p>Lisp语言中，循环不像Java提供<code>for</code>、<code>while</code>等语法，经典用法还是使用递归，clojure也有提供loop循环。在clojure中，递归、循环息息相关的工具<code>recur</code>，它的存在跟clojure实现在jvm之上有所关系，其原因也跟Java为什么有<code>for</code>、<code>while</code>等语法相关。</p>\n<hr>\n<ul>\n<li><h3 id=\"recur是什么？怎么用？\"><a href=\"#recur是什么？怎么用？\" class=\"headerlink\" title=\"recur是什么？怎么用？\"></a><font color=#0099ff>recur是什么？怎么用？</font></h3></li>\n</ul>\n<p><code>recur</code>相对于clojure的宏和函数来说，是个十分底层的程序控制操作，用于循环或递归。可以在不消耗堆栈的情况下，回到函数或循环体的最顶端。</p>\n<p>例如在函数中使用<code>recur</code>实现递归：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;实至名归的尾递归！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> my_dec [x]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">    x</span><br><span class=\"line\">    <span class=\"comment\">;如果大于0，则回到my_dec，重新进入</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x))))</span><br></pre></td></tr></table></figure>\n<p>又或者是loop循环：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;看起来还不如上面的递归呢！～</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">loop</span></span> [x <span class=\"number\">100</span>]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">    x</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x))))</span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080><code>recur</code>一定要放在结尾位置！不然clojure编译时会报错！比如我在<code>my_dec [x]</code>的<code>if</code>包多一层<code>int</code>会怎样？</font></p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> my_dec [x]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">int</span></span> (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">         x</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x)))))</span><br><span class=\"line\"><span class=\"comment\">;CompilerException java.lang.UnsupportedOperationException: Can only recur from tail position</span></span><br></pre></td></tr></table></figure>\n<p><font color=#f28080>显然编译不了，异常信息告诉你，你的<code>recur</code>不是放在结束位置，因为<code>if</code>返回值之后还有其他动作。</font></p>\n<ul>\n<li><h3 id=\"为什么尾递归不是真正的尾递归？\"><a href=\"#为什么尾递归不是真正的尾递归？\" class=\"headerlink\" title=\"为什么尾递归不是真正的尾递归？\"></a><font color=#0099ff>为什么尾递归不是真正的尾递归？</font></h3></li>\n</ul>\n<p>上面的递归递减的例子才是真正的尾递归！为啥？</p>\n<p>ok！在<a href=\"http://huangzehong.me/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">定义函数</a>有个计算阶乘的例子。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letfn</span></span> [(<span class=\"name\">factorial</span> [x]</span><br><span class=\"line\">          (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">        (<span class=\"name\">factorial_2</span> [x y]</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">            y</span><br><span class=\"line\">            (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))))]</span><br><span class=\"line\">  #(<span class=\"name\">factorial</span> %))</span><br></pre></td></tr></table></figure>\n\n<p>如果在Java中实现“尾递归”，我可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> factorial(x - <span class=\"number\">1</span>, sum * x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果用Java的循环，可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jvm没有实现尾递归优化支持，一大半原因是有了for等循环体，就觉得没必要吧。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> y = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;x &gt; <span class=\"number\">1</span>; x--)</span><br><span class=\"line\">    y = y * x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要先知道的是，jvm不知道为毛，一直不想实现尾调用优化；所以<code>int factorial(x, sum)</code>虽然代码是尾递归格式，但并没什么卵用，这对于运行在它上面的函数式编程语言也是个坑！</p>\n<p>正因为如此，在jvm上运行的clojure自然支持不了<code>factorial[x y]</code>这样的隐式尾递归，但提供了<code>recur</code>这个十分底层的工具（类似于goto），让我们显示地表示出尾递归。顺便说一句，同样运行在jvm的scala实现了尾递归，虽然十分有限，只支持严格尾递归，不明白clojure为啥也不搞一个。</p>\n<ul>\n<li><h3 id=\"clojure还有其他循环\"><a href=\"#clojure还有其他循环\" class=\"headerlink\" title=\"clojure还有其他循环\"></a><font color=#0099ff>clojure还有其他循环</font></h3></li>\n</ul>\n<p>尽管<code>recur</code>能帮你实现高效的尾递归，但依然需要谨慎，适当时候才使用。并不是因为有副作用，而是clojure提供了支持某些循环的宏，例如<code>dotimes</code>、<code>doseq</code>、<code>while</code>（他们底层也是<code>recur</code>），这已经能够满足大多时候的需求了。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">dotimes</span></span> [i <span class=\"number\">10</span>]</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"number:\"</span> i))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> j <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">while</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> j <span class=\"number\">0</span>)</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"number:\"</span> j)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">def</span></span> j (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> j)))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Lisp语言中，循环不像Java提供<code>for</code>、<code>while</code>等语法，经典用法还是使用递归，clojure也有提供loop循环。在clojure中，递归、循环息息相关的工具<code>recur</code>，它的存在跟clojure实现在jvm之上有所关系，其原因也跟Java为什么有<code>for</code>、<code>while</code>等语法相关。</p>\n<hr>\n<ul>\n<li><h3 id=\"recur是什么？怎么用？\"><a href=\"#recur是什么？怎么用？\" class=\"headerlink\" title=\"recur是什么？怎么用？\"></a><font color=#0099ff>recur是什么？怎么用？</font></h3></li>\n</ul>\n<p><code>recur</code>相对于clojure的宏和函数来说，是个十分底层的程序控制操作，用于循环或递归。可以在不消耗堆栈的情况下，回到函数或循环体的最顶端。</p>\n<p>例如在函数中使用<code>recur</code>实现递归：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;实至名归的尾递归！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> my_dec [x]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">    x</span><br><span class=\"line\">    <span class=\"comment\">;如果大于0，则回到my_dec，重新进入</span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x))))</span><br></pre></td></tr></table></figure>\n<p>又或者是loop循环：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;看起来还不如上面的递归呢！～</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">loop</span></span> [x <span class=\"number\">100</span>]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">    x</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x))))</span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080><code>recur</code>一定要放在结尾位置！不然clojure编译时会报错！比如我在<code>my_dec [x]</code>的<code>if</code>包多一层<code>int</code>会怎样？</font></p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> my_dec [x]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">int</span></span> (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">0</span>)</span><br><span class=\"line\">         x</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">recur</span></span> (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> x)))))</span><br><span class=\"line\"><span class=\"comment\">;CompilerException java.lang.UnsupportedOperationException: Can only recur from tail position</span></span><br></pre></td></tr></table></figure>\n<p><font color=#f28080>显然编译不了，异常信息告诉你，你的<code>recur</code>不是放在结束位置，因为<code>if</code>返回值之后还有其他动作。</font></p>\n<ul>\n<li><h3 id=\"为什么尾递归不是真正的尾递归？\"><a href=\"#为什么尾递归不是真正的尾递归？\" class=\"headerlink\" title=\"为什么尾递归不是真正的尾递归？\"></a><font color=#0099ff>为什么尾递归不是真正的尾递归？</font></h3></li>\n</ul>\n<p>上面的递归递减的例子才是真正的尾递归！为啥？</p>\n<p>ok！在<a href=\"http://huangzehong.me/2017/01/17/20170117-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"noopener\">定义函数</a>有个计算阶乘的例子。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letfn</span></span> [(<span class=\"name\">factorial</span> [x]</span><br><span class=\"line\">          (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">        (<span class=\"name\">factorial_2</span> [x y]</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">            y</span><br><span class=\"line\">            (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))))]</span><br><span class=\"line\">  #(<span class=\"name\">factorial</span> %))</span><br></pre></td></tr></table></figure>\n\n<p>如果在Java中实现“尾递归”，我可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span>  <span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> factorial(x - <span class=\"number\">1</span>, sum * x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果用Java的循环，可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//jvm没有实现尾递归优化支持，一大半原因是有了for等循环体，就觉得没必要吧。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> y = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(;x &gt; <span class=\"number\">1</span>; x--)</span><br><span class=\"line\">    y = y * x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要先知道的是，jvm不知道为毛，一直不想实现尾调用优化；所以<code>int factorial(x, sum)</code>虽然代码是尾递归格式，但并没什么卵用，这对于运行在它上面的函数式编程语言也是个坑！</p>\n<p>正因为如此，在jvm上运行的clojure自然支持不了<code>factorial[x y]</code>这样的隐式尾递归，但提供了<code>recur</code>这个十分底层的工具（类似于goto），让我们显示地表示出尾递归。顺便说一句，同样运行在jvm的scala实现了尾递归，虽然十分有限，只支持严格尾递归，不明白clojure为啥也不搞一个。</p>\n<ul>\n<li><h3 id=\"clojure还有其他循环\"><a href=\"#clojure还有其他循环\" class=\"headerlink\" title=\"clojure还有其他循环\"></a><font color=#0099ff>clojure还有其他循环</font></h3></li>\n</ul>\n<p>尽管<code>recur</code>能帮你实现高效的尾递归，但依然需要谨慎，适当时候才使用。并不是因为有副作用，而是clojure提供了支持某些循环的宏，例如<code>dotimes</code>、<code>doseq</code>、<code>while</code>（他们底层也是<code>recur</code>），这已经能够满足大多时候的需求了。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">dotimes</span></span> [i <span class=\"number\">10</span>]</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"number:\"</span> i))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> j <span class=\"number\">10</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">while</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> j <span class=\"number\">0</span>)</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"number:\"</span> j)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">def</span></span> j (<span class=\"name\"><span class=\"builtin-name\">dec</span></span> j)))</span><br></pre></td></tr></table></figure>\n"},{"title":"初学Clojure—定义函数","date":"2017-01-17T13:23:53.000Z","_content":"\n严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。\n\n---\n\n- ### <font color=#0099ff>定义有名字的函数</font>\n\n定义函数可以`defn`声明有名字的函数，最后一条表达式的结果作为返回值，`defn`后面是函数名，`[]`则是参数。\n``` clojure\n(defn i_am_fn [x y]\n  (* x y))\n\n;clojure的函数重载，只更参数个数有关，与参数类型无关。\n(defn i_am_fn [x y z]\n  (println x \"+\" y \"+\" z \"=\")\n  (* x y z)\n  (+ x y z))\n\n;或者可以这样写\n(defn i_am_fn\n  ([x y]\n    (* x y))\n  ([x y z]\n    (println x \"+\" y \"+\" z \"=\")\n    (* x y z)\n    (+ x y z)))\n```\n\n- ### <font color=#0099ff>定义‘没有’名字的函数—匿名函数</font>\n\n定义匿名函数则用`fn`，同样最后一条表达式的结果作为返回值，`fn`后面也可以有函数名（可选），`[]`里是参数列表。\n``` clojure\n(fn [x y]\n  (println \"i don't kown!!!\")\n  (+ x y))\n```\n\n匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。\n``` clojure\n;方式一：\n;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。\n;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]\n;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可\n(fn factorial\n  ([x]\n    (factorial (- x 1) x))\n  ([x y]\n    (if (< x 1)\n      y\n      (factorial (- x 1) (* x y)))))\n\n;方式二：\n;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。\n;#是函数的字面量\n(#((fn factorial [x y]\n     (if (< x 1)\n       y\n       (factorial (- x 1) (* y x)))) % 1) 10)\n\n;方式三：\n;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。\n;形式上于第一种方式相似，但又有很大不同。\n;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可\n;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化\n(letfn [(factorial [x]\n          (factorial_2 (- x 1) x))\n        (factorial_2 [x y]\n          (if (< x 1)\n            y\n            (factorial_2 (- x 1) (* x y))))]\n  #(factorial %))\n```\n<font size=2 color=#f28080>上面有个细节需要注意，就是factorial的尾递归，在jvm上不是真正的尾递归，因为虚拟机并没有提供尾调用优化，与普通递归并无二样，以后会说到`recur`实现尾递归。</font>\n\n三种不同形式的匿名函数递归，显然第一种是最不可取的！论灵活性的话，我自己比较喜欢第三种，用`letfn`实现，递归中如果有其他独立的算法模块，可以单独作为一个私有方法，提高可读性。不过，若非必要，还是声明普通函数吧！\n\n- ### <font color=#0099ff>函数参数的解构</font>\n\n参数列表的解构，与`let`大同小异，可以参考[基本语法](http://huangzehong.me/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/)。\n\n先来看看函数可变参数，`&`字符后跟随的是除去前面参数所剩余的参数列表。\n``` clojure\n(defn i_am_fn [x & rest]\n  (apply str rest))\n;rest则表示除第一个参数1，剩余的[2 3 4 5 6]\n(i_am_fn 1 2 3 4 5 6);=\"23456\"\n\n;也可以表示可变参数\n(defn i_am_fn_2 [& rest] ;也可以[& [rest]]，这样函数至多接受一个参数\n  {:user-id (or rest\n              (java.util.UUID/randomUUID))})\n(i_am_fn_2 \"string\" :keyname 123);={:user-id (\"string\" :keyname 123)}\n(i_am_fn_2);={:user-id #uuid\"d38aaef2-d5d2-4e86-850e-b29c18b870b5\"}\n```\n\n有时候，函数的一些参数并非必要传入，clojure允许我们为参数设置默认值，而这些能被设置\b默认值的参数叫做关键字参数。\n```clojure\n(defn a_man [username & {:keys [email times]\n                                    ;设置默认值，如果没有传入值的话，传nil是有效的。\n                                    :or {times (java.util.Date.) email \"740762239@qq.com\"}}]\n  {:username username :email email :time times})\n;没有被设为关键字参数的参数，则必须要传入！例如username。\n(a_man \"i am man\")\n;={:username \"i am man\", :email \"740762239@qq.com\", :time #inst\"2017-01-19T14:25:41.806-00:00\"}\n(a_man \"i am man\" :email \"777@qq.com\" :times \"2017-01-17 21:23:53\")\n;={:username \"i am man\", :email \"777@qq.com\", :time \"2017-01-17 21:23:53\"}\n\n;可能会有点不明白上面关键字参数，其实它就是map的解构\n;等同于\n;只不过，源于优雅，建议用:keys罢了\n(defn a_man [username & {email :email\n                         times :times\n                         :or {times (java.util.Date.) email \"740762239@qq.com\"}}]\n  {:username username :email email :time times})\n```\n","source":"_posts/20170117-初学Clojure—定义函数.md","raw":"---\ntitle: 初学Clojure—定义函数\ndate: 2017-01-17 21:23:53\ncategories:\n- 函数编程\ntags:\n- clojure\n- 教程\n- 并发编程语言\n---\n\n严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。\n\n---\n\n- ### <font color=#0099ff>定义有名字的函数</font>\n\n定义函数可以`defn`声明有名字的函数，最后一条表达式的结果作为返回值，`defn`后面是函数名，`[]`则是参数。\n``` clojure\n(defn i_am_fn [x y]\n  (* x y))\n\n;clojure的函数重载，只更参数个数有关，与参数类型无关。\n(defn i_am_fn [x y z]\n  (println x \"+\" y \"+\" z \"=\")\n  (* x y z)\n  (+ x y z))\n\n;或者可以这样写\n(defn i_am_fn\n  ([x y]\n    (* x y))\n  ([x y z]\n    (println x \"+\" y \"+\" z \"=\")\n    (* x y z)\n    (+ x y z)))\n```\n\n- ### <font color=#0099ff>定义‘没有’名字的函数—匿名函数</font>\n\n定义匿名函数则用`fn`，同样最后一条表达式的结果作为返回值，`fn`后面也可以有函数名（可选），`[]`里是参数列表。\n``` clojure\n(fn [x y]\n  (println \"i don't kown!!!\")\n  (+ x y))\n```\n\n匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。\n``` clojure\n;方式一：\n;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。\n;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]\n;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可\n(fn factorial\n  ([x]\n    (factorial (- x 1) x))\n  ([x y]\n    (if (< x 1)\n      y\n      (factorial (- x 1) (* x y)))))\n\n;方式二：\n;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。\n;#是函数的字面量\n(#((fn factorial [x y]\n     (if (< x 1)\n       y\n       (factorial (- x 1) (* y x)))) % 1) 10)\n\n;方式三：\n;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。\n;形式上于第一种方式相似，但又有很大不同。\n;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可\n;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化\n(letfn [(factorial [x]\n          (factorial_2 (- x 1) x))\n        (factorial_2 [x y]\n          (if (< x 1)\n            y\n            (factorial_2 (- x 1) (* x y))))]\n  #(factorial %))\n```\n<font size=2 color=#f28080>上面有个细节需要注意，就是factorial的尾递归，在jvm上不是真正的尾递归，因为虚拟机并没有提供尾调用优化，与普通递归并无二样，以后会说到`recur`实现尾递归。</font>\n\n三种不同形式的匿名函数递归，显然第一种是最不可取的！论灵活性的话，我自己比较喜欢第三种，用`letfn`实现，递归中如果有其他独立的算法模块，可以单独作为一个私有方法，提高可读性。不过，若非必要，还是声明普通函数吧！\n\n- ### <font color=#0099ff>函数参数的解构</font>\n\n参数列表的解构，与`let`大同小异，可以参考[基本语法](http://huangzehong.me/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/)。\n\n先来看看函数可变参数，`&`字符后跟随的是除去前面参数所剩余的参数列表。\n``` clojure\n(defn i_am_fn [x & rest]\n  (apply str rest))\n;rest则表示除第一个参数1，剩余的[2 3 4 5 6]\n(i_am_fn 1 2 3 4 5 6);=\"23456\"\n\n;也可以表示可变参数\n(defn i_am_fn_2 [& rest] ;也可以[& [rest]]，这样函数至多接受一个参数\n  {:user-id (or rest\n              (java.util.UUID/randomUUID))})\n(i_am_fn_2 \"string\" :keyname 123);={:user-id (\"string\" :keyname 123)}\n(i_am_fn_2);={:user-id #uuid\"d38aaef2-d5d2-4e86-850e-b29c18b870b5\"}\n```\n\n有时候，函数的一些参数并非必要传入，clojure允许我们为参数设置默认值，而这些能被设置\b默认值的参数叫做关键字参数。\n```clojure\n(defn a_man [username & {:keys [email times]\n                                    ;设置默认值，如果没有传入值的话，传nil是有效的。\n                                    :or {times (java.util.Date.) email \"740762239@qq.com\"}}]\n  {:username username :email email :time times})\n;没有被设为关键字参数的参数，则必须要传入！例如username。\n(a_man \"i am man\")\n;={:username \"i am man\", :email \"740762239@qq.com\", :time #inst\"2017-01-19T14:25:41.806-00:00\"}\n(a_man \"i am man\" :email \"777@qq.com\" :times \"2017-01-17 21:23:53\")\n;={:username \"i am man\", :email \"777@qq.com\", :time \"2017-01-17 21:23:53\"}\n\n;可能会有点不明白上面关键字参数，其实它就是map的解构\n;等同于\n;只不过，源于优雅，建议用:keys罢了\n(defn a_man [username & {email :email\n                         times :times\n                         :or {times (java.util.Date.) email \"740762239@qq.com\"}}]\n  {:username username :email email :time times})\n```\n","slug":"20170117-初学Clojure—定义函数","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7so001z4ejddd1sg5xb","content":"<p>严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。</p>\n<hr>\n<ul>\n<li><h3 id=\"定义有名字的函数\"><a href=\"#定义有名字的函数\" class=\"headerlink\" title=\"定义有名字的函数\"></a><font color=#0099ff>定义有名字的函数</font></h3></li>\n</ul>\n<p>定义函数可以<code>defn</code>声明有名字的函数，最后一条表达式的结果作为返回值，<code>defn</code>后面是函数名，<code>[]</code>则是参数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x y]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;clojure的函数重载，只更参数个数有关，与参数类型无关。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x y z]</span><br><span class=\"line\">  (<span class=\"name\">println</span> x <span class=\"string\">\"+\"</span> y <span class=\"string\">\"+\"</span> z <span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;或者可以这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn</span><br><span class=\"line\">  ([x y]</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))</span><br><span class=\"line\">  ([x y z]</span><br><span class=\"line\">    (<span class=\"name\">println</span> x <span class=\"string\">\"+\"</span> y <span class=\"string\">\"+\"</span> z <span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y z)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z)))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"定义‘没有’名字的函数—匿名函数\"><a href=\"#定义‘没有’名字的函数—匿名函数\" class=\"headerlink\" title=\"定义‘没有’名字的函数—匿名函数\"></a><font color=#0099ff>定义‘没有’名字的函数—匿名函数</font></h3></li>\n</ul>\n<p>定义匿名函数则用<code>fn</code>，同样最后一条表达式的结果作为返回值，<code>fn</code>后面也可以有函数名（可选），<code>[]</code>里是参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [x y]</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"i don't kown!!!\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y))</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;方式一：</span></span><br><span class=\"line\"><span class=\"comment\">;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。</span></span><br><span class=\"line\"><span class=\"comment\">;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]</span></span><br><span class=\"line\"><span class=\"comment\">;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">fn</span></span> factorial</span><br><span class=\"line\">  ([x]</span><br><span class=\"line\">    (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">  ([x y]</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">      y</span><br><span class=\"line\">      (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y)))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;方式二：</span></span><br><span class=\"line\"><span class=\"comment\">;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。</span></span><br><span class=\"line\"><span class=\"comment\">;#是函数的字面量</span></span><br><span class=\"line\">(<span class=\"name\">#</span>((<span class=\"name\"><span class=\"builtin-name\">fn</span></span> factorial [x y]</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">       y</span><br><span class=\"line\">       (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> y x)))) % <span class=\"number\">1</span>) <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;方式三：</span></span><br><span class=\"line\"><span class=\"comment\">;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。</span></span><br><span class=\"line\"><span class=\"comment\">;形式上于第一种方式相似，但又有很大不同。</span></span><br><span class=\"line\"><span class=\"comment\">;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可</span></span><br><span class=\"line\"><span class=\"comment\">;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letfn</span></span> [(<span class=\"name\">factorial</span> [x]</span><br><span class=\"line\">          (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">        (<span class=\"name\">factorial_2</span> [x y]</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">            y</span><br><span class=\"line\">            (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))))]</span><br><span class=\"line\">  #(<span class=\"name\">factorial</span> %))</span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080>上面有个细节需要注意，就是factorial的尾递归，在jvm上不是真正的尾递归，因为虚拟机并没有提供尾调用优化，与普通递归并无二样，以后会说到<code>recur</code>实现尾递归。</font></p>\n<p>三种不同形式的匿名函数递归，显然第一种是最不可取的！论灵活性的话，我自己比较喜欢第三种，用<code>letfn</code>实现，递归中如果有其他独立的算法模块，可以单独作为一个私有方法，提高可读性。不过，若非必要，还是声明普通函数吧！</p>\n<ul>\n<li><h3 id=\"函数参数的解构\"><a href=\"#函数参数的解构\" class=\"headerlink\" title=\"函数参数的解构\"></a><font color=#0099ff>函数参数的解构</font></h3></li>\n</ul>\n<p>参数列表的解构，与<code>let</code>大同小异，可以参考<a href=\"http://huangzehong.me/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">基本语法</a>。</p>\n<p>先来看看函数可变参数，<code>&amp;</code>字符后跟随的是除去前面参数所剩余的参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x &amp; rest]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> str rest))</span><br><span class=\"line\"><span class=\"comment\">;rest则表示除第一个参数1，剩余的[2 3 4 5 6]</span></span><br><span class=\"line\">(<span class=\"name\">i_am_fn</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>)<span class=\"comment\">;=\"23456\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;也可以表示可变参数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn_2 [&amp; rest] <span class=\"comment\">;也可以[&amp; [rest]]，这样函数至多接受一个参数</span></span><br><span class=\"line\">  &#123;<span class=\"symbol\">:user-id</span> (<span class=\"name\"><span class=\"builtin-name\">or</span></span> rest</span><br><span class=\"line\">              (<span class=\"name\">java.util.UUID/randomUUID</span>))&#125;)</span><br><span class=\"line\">(<span class=\"name\">i_am_fn_2</span> <span class=\"string\">\"string\"</span> <span class=\"symbol\">:keyname</span> <span class=\"number\">123</span>)<span class=\"comment\">;=&#123;:user-id (\"string\" :keyname 123)&#125;</span></span><br><span class=\"line\">(<span class=\"name\">i_am_fn_2</span>)<span class=\"comment\">;=&#123;:user-id #uuid\"d38aaef2-d5d2-4e86-850e-b29c18b870b5\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>有时候，函数的一些参数并非必要传入，clojure允许我们为参数设置默认值，而这些能被设置\b默认值的参数叫做关键字参数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_man [username &amp; &#123;<span class=\"symbol\">:keys</span> [email times]</span><br><span class=\"line\">                                    <span class=\"comment\">;设置默认值，如果没有传入值的话，传nil是有效的。</span></span><br><span class=\"line\">                                    <span class=\"symbol\">:or</span> &#123;times (<span class=\"name\">java.util.Date.</span>) email <span class=\"string\">\"740762239@qq.com\"</span>&#125;&#125;]</span><br><span class=\"line\">  &#123;<span class=\"symbol\">:username</span> username <span class=\"symbol\">:email</span> email <span class=\"symbol\">:time</span> times&#125;)</span><br><span class=\"line\"><span class=\"comment\">;没有被设为关键字参数的参数，则必须要传入！例如username。</span></span><br><span class=\"line\">(<span class=\"name\">a_man</span> <span class=\"string\">\"i am man\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;=&#123;:username \"i am man\", :email \"740762239@qq.com\", :time #inst\"2017-01-19T14:25:41.806-00:00\"&#125;</span></span><br><span class=\"line\">(<span class=\"name\">a_man</span> <span class=\"string\">\"i am man\"</span> <span class=\"symbol\">:email</span> <span class=\"string\">\"777@qq.com\"</span> <span class=\"symbol\">:times</span> <span class=\"string\">\"2017-01-17 21:23:53\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;=&#123;:username \"i am man\", :email \"777@qq.com\", :time \"2017-01-17 21:23:53\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;可能会有点不明白上面关键字参数，其实它就是map的解构</span></span><br><span class=\"line\"><span class=\"comment\">;等同于</span></span><br><span class=\"line\"><span class=\"comment\">;只不过，源于优雅，建议用:keys罢了</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_man [username &amp; &#123;email <span class=\"symbol\">:email</span></span><br><span class=\"line\">                         times <span class=\"symbol\">:times</span></span><br><span class=\"line\">                         <span class=\"symbol\">:or</span> &#123;times (<span class=\"name\">java.util.Date.</span>) email <span class=\"string\">\"740762239@qq.com\"</span>&#125;&#125;]</span><br><span class=\"line\">  &#123;<span class=\"symbol\">:username</span> username <span class=\"symbol\">:email</span> email <span class=\"symbol\">:time</span> times&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。</p>\n<hr>\n<ul>\n<li><h3 id=\"定义有名字的函数\"><a href=\"#定义有名字的函数\" class=\"headerlink\" title=\"定义有名字的函数\"></a><font color=#0099ff>定义有名字的函数</font></h3></li>\n</ul>\n<p>定义函数可以<code>defn</code>声明有名字的函数，最后一条表达式的结果作为返回值，<code>defn</code>后面是函数名，<code>[]</code>则是参数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x y]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;clojure的函数重载，只更参数个数有关，与参数类型无关。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x y z]</span><br><span class=\"line\">  (<span class=\"name\">println</span> x <span class=\"string\">\"+\"</span> y <span class=\"string\">\"+\"</span> z <span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y z)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;或者可以这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn</span><br><span class=\"line\">  ([x y]</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))</span><br><span class=\"line\">  ([x y z]</span><br><span class=\"line\">    (<span class=\"name\">println</span> x <span class=\"string\">\"+\"</span> y <span class=\"string\">\"+\"</span> z <span class=\"string\">\"=\"</span>)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y z)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z)))</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"定义‘没有’名字的函数—匿名函数\"><a href=\"#定义‘没有’名字的函数—匿名函数\" class=\"headerlink\" title=\"定义‘没有’名字的函数—匿名函数\"></a><font color=#0099ff>定义‘没有’名字的函数—匿名函数</font></h3></li>\n</ul>\n<p>定义匿名函数则用<code>fn</code>，同样最后一条表达式的结果作为返回值，<code>fn</code>后面也可以有函数名（可选），<code>[]</code>里是参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [x y]</span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"i don't kown!!!\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y))</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;方式一：</span></span><br><span class=\"line\"><span class=\"comment\">;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。</span></span><br><span class=\"line\"><span class=\"comment\">;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]</span></span><br><span class=\"line\"><span class=\"comment\">;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">fn</span></span> factorial</span><br><span class=\"line\">  ([x]</span><br><span class=\"line\">    (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">  ([x y]</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">      y</span><br><span class=\"line\">      (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y)))))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;方式二：</span></span><br><span class=\"line\"><span class=\"comment\">;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。</span></span><br><span class=\"line\"><span class=\"comment\">;#是函数的字面量</span></span><br><span class=\"line\">(<span class=\"name\">#</span>((<span class=\"name\"><span class=\"builtin-name\">fn</span></span> factorial [x y]</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">       y</span><br><span class=\"line\">       (<span class=\"name\">factorial</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> y x)))) % <span class=\"number\">1</span>) <span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;方式三：</span></span><br><span class=\"line\"><span class=\"comment\">;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。</span></span><br><span class=\"line\"><span class=\"comment\">;形式上于第一种方式相似，但又有很大不同。</span></span><br><span class=\"line\"><span class=\"comment\">;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可</span></span><br><span class=\"line\"><span class=\"comment\">;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">letfn</span></span> [(<span class=\"name\">factorial</span> [x]</span><br><span class=\"line\">          (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) x))</span><br><span class=\"line\">        (<span class=\"name\">factorial_2</span> [x y]</span><br><span class=\"line\">          (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> x <span class=\"number\">1</span>)</span><br><span class=\"line\">            y</span><br><span class=\"line\">            (<span class=\"name\">factorial_2</span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> x <span class=\"number\">1</span>) (<span class=\"name\"><span class=\"builtin-name\">*</span></span> x y))))]</span><br><span class=\"line\">  #(<span class=\"name\">factorial</span> %))</span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080>上面有个细节需要注意，就是factorial的尾递归，在jvm上不是真正的尾递归，因为虚拟机并没有提供尾调用优化，与普通递归并无二样，以后会说到<code>recur</code>实现尾递归。</font></p>\n<p>三种不同形式的匿名函数递归，显然第一种是最不可取的！论灵活性的话，我自己比较喜欢第三种，用<code>letfn</code>实现，递归中如果有其他独立的算法模块，可以单独作为一个私有方法，提高可读性。不过，若非必要，还是声明普通函数吧！</p>\n<ul>\n<li><h3 id=\"函数参数的解构\"><a href=\"#函数参数的解构\" class=\"headerlink\" title=\"函数参数的解构\"></a><font color=#0099ff>函数参数的解构</font></h3></li>\n</ul>\n<p>参数列表的解构，与<code>let</code>大同小异，可以参考<a href=\"http://huangzehong.me/2017/01/15/20170115-%E5%88%9D%E5%AD%A6Clojure%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/\" target=\"_blank\" rel=\"noopener\">基本语法</a>。</p>\n<p>先来看看函数可变参数，<code>&amp;</code>字符后跟随的是除去前面参数所剩余的参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn [x &amp; rest]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">apply</span></span> str rest))</span><br><span class=\"line\"><span class=\"comment\">;rest则表示除第一个参数1，剩余的[2 3 4 5 6]</span></span><br><span class=\"line\">(<span class=\"name\">i_am_fn</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>)<span class=\"comment\">;=\"23456\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;也可以表示可变参数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> i_am_fn_2 [&amp; rest] <span class=\"comment\">;也可以[&amp; [rest]]，这样函数至多接受一个参数</span></span><br><span class=\"line\">  &#123;<span class=\"symbol\">:user-id</span> (<span class=\"name\"><span class=\"builtin-name\">or</span></span> rest</span><br><span class=\"line\">              (<span class=\"name\">java.util.UUID/randomUUID</span>))&#125;)</span><br><span class=\"line\">(<span class=\"name\">i_am_fn_2</span> <span class=\"string\">\"string\"</span> <span class=\"symbol\">:keyname</span> <span class=\"number\">123</span>)<span class=\"comment\">;=&#123;:user-id (\"string\" :keyname 123)&#125;</span></span><br><span class=\"line\">(<span class=\"name\">i_am_fn_2</span>)<span class=\"comment\">;=&#123;:user-id #uuid\"d38aaef2-d5d2-4e86-850e-b29c18b870b5\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>有时候，函数的一些参数并非必要传入，clojure允许我们为参数设置默认值，而这些能被设置\b默认值的参数叫做关键字参数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_man [username &amp; &#123;<span class=\"symbol\">:keys</span> [email times]</span><br><span class=\"line\">                                    <span class=\"comment\">;设置默认值，如果没有传入值的话，传nil是有效的。</span></span><br><span class=\"line\">                                    <span class=\"symbol\">:or</span> &#123;times (<span class=\"name\">java.util.Date.</span>) email <span class=\"string\">\"740762239@qq.com\"</span>&#125;&#125;]</span><br><span class=\"line\">  &#123;<span class=\"symbol\">:username</span> username <span class=\"symbol\">:email</span> email <span class=\"symbol\">:time</span> times&#125;)</span><br><span class=\"line\"><span class=\"comment\">;没有被设为关键字参数的参数，则必须要传入！例如username。</span></span><br><span class=\"line\">(<span class=\"name\">a_man</span> <span class=\"string\">\"i am man\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;=&#123;:username \"i am man\", :email \"740762239@qq.com\", :time #inst\"2017-01-19T14:25:41.806-00:00\"&#125;</span></span><br><span class=\"line\">(<span class=\"name\">a_man</span> <span class=\"string\">\"i am man\"</span> <span class=\"symbol\">:email</span> <span class=\"string\">\"777@qq.com\"</span> <span class=\"symbol\">:times</span> <span class=\"string\">\"2017-01-17 21:23:53\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;=&#123;:username \"i am man\", :email \"777@qq.com\", :time \"2017-01-17 21:23:53\"&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;可能会有点不明白上面关键字参数，其实它就是map的解构</span></span><br><span class=\"line\"><span class=\"comment\">;等同于</span></span><br><span class=\"line\"><span class=\"comment\">;只不过，源于优雅，建议用:keys罢了</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_man [username &amp; &#123;email <span class=\"symbol\">:email</span></span><br><span class=\"line\">                         times <span class=\"symbol\">:times</span></span><br><span class=\"line\">                         <span class=\"symbol\">:or</span> &#123;times (<span class=\"name\">java.util.Date.</span>) email <span class=\"string\">\"740762239@qq.com\"</span>&#125;&#125;]</span><br><span class=\"line\">  &#123;<span class=\"symbol\">:username</span> username <span class=\"symbol\">:email</span> email <span class=\"symbol\">:time</span> times&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"初学Clojure—基本语法","date":"2017-01-14T16:02:55.000Z","_content":"\n为了全面学习函数式编程语言，之前尝试了scala，不得不承认它的入门门槛略高。于是乎，决定从古老的新语言Clorue入手，作为Lisp的一种方言，语法上无疑是古老的，但它又运行在JVM上且有一些不错的机制，无疑是门新语言。\n\n---\n\n- ### <font color=#0099ff>满篇的括号</font>\n\nLisp语法最大特点就是一堆圆括号，任何函数调用都以“(”开始、“)”结束，函数名或函数本身与参数在括号里呈现前缀表达法。\n\n``` clojure\n(+ 1 3) ;=4\n(add 3 5) ;=8\n(or (= 1 2) (> 4 6)) ;=false\n;下面为匿名函数\n(#(apply * %) '(1 3 4 5 6)) ;=360\n```\n\n除了圆括号外，也有方括号“[]”，在clojure中，它既可以是向量的字面量，也可是函数的参数列表。\n\n``` clojure\n(def a_vector [1 3 4 5 6 6]) ;=#'user/a_vector\n;或者是个函数的参数列表\n(defn a_function [param1 param2]\n  (do\n    (print \"i am function\")))\n```\n\n当然少不了花括号“{}”，在Map与Set两种数据结构的字面量中体现。\n\n``` clojure\n{:key1 val1 :key2 val2}\t;这是Map\n#{ 1 2 3 } ;这是个Set\n```\n扯句无关的，在最原始的Lisp中几乎只有圆括号，例如与之最相近的一种方言Common Lisp。\n\n- ### <font color=#0099ff>优先级取决于括号</font>\n\n与其他语言一样，括号总伴随着表达式求值的优先级。\n\n``` clojure\n(+ (* (- 4 2) (/ 10 5)) (- 1 (+ 4 5)) 2) ;=5\n```\n在Lisp语言中，我们通常很容易获知代码的优先级，正如代码本身就是一棵抽象语法树，能快速知道最先被求值的是哪个节点。代码自身等同于AST，我们称之为“同像性”。\n\n正因Clojure的“同像性”，也为它自己带来其他语言没有的特性—可以自定义语法糖，即自定义宏。\n\n- ### <font color=#0099ff>括号外的一些符号—字面量</font>\n\n要知道，Clojure是一种语法极其简易的语言，括号外也有一些能使代码简明易懂的符号，它们被叫做“字面量”。\n\n``` clojure\n;字符串字面量\n\"i am string\"\n\n;数字字面量\n54321 ;十进制，clojure只有long和double类型\n10.1111333 ;double\n16rffa ;十六进制\n2r101 ;二进制\n\n;其他基本类型\ntrue\nfalse\nnil\n\\c ;字符\n\n;\"\"前面加个#就是正则表达式\n(re-seq #\"\\d*-\\w+\" \"omg123-string\") ;=(\"123-string\")\n\n;关键字\n;在Map数据结构中，关键字字面量是很有用的数据类型\n:keyname ;=:keyname 代表自己\n\n;数据结构字面量\n;map\n{:key1 val1 :key2 val2}\n;list\n'(1 3 4 5 :keyname \"item\")\n;vector\n[1 3 4 5 :keyname \"item\"]\n;set\n#{1 2 3}\n\n;与表达式、函数相关的字面量\n;clojure有个叫quote的东西，它被用来阻止表达式求值，其字面量为'\n;可理解为只是个简单声明一个list，这与上面说到的同像性有关\n'(+ 1 3) ;=(+ 1 3) ;变成了一个list，其中+等同于另外两个元素，被作为一个值塞进list中\n\n;函数的字面量 #\n#(+ %1 %2) ;代表了一个匿名函数\n(def my_add #(+ %1 %2)) ;将匿名函数赋值给my_add\n(my_add 1 3) ;=4\n```\n\n- ### <font color=#0099ff>代码块以及值的作用域</font>\n\n每个函数调用都有圆括号包裹起开，执行多条语句同样需要一个圆括号。一个括号里的多条语句，叫做代码块。\nclojure用宏`do`来依次执行代码块中的语句，且以最后的语句的结果作为返回值。\n``` clojure\n(do\n  (println \"1 + 2\")\n  (+ 2 3)\n  (+ 1 2))\n```\n\n在fn、defn、let、loop、try等语义中，已经隐式使用了do，所以并不需要显示声明调用do。\n``` clojure\n(defn no_do []\n  ((println \"1 + 2\")\n  (+ 2 4)\n  (+ 1 2)))\n```\n\n与代码块息息相关的还有值的作用域，上面用def定义的值，都可在其命名空间全局访问。\n``` clojure\n(ns i_am_namespace)\n(def x_in_i_am_namespace) ;=#'i_am_namespace/x_in_i_am_namespace\n```\n\n有时我们需要局部域的值，clojure为我们提供let，叫做本地绑定。\n``` clojure\n(def z \"def_z\")\n\n(let [x (list 1 2 3 4)\n      y (vector 1 3 4 4)]\n  (do\n    ;do something\n    (println z)\n    (conj x z)))\n\n(println z);=def_z\n\n;报错，x只在定义它的let内有效\n(println x);=CompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context\n```\n\n- ### <font color=#0099ff>入参也可以很方便—let参数的解构</font>\n\nclojure有两类重要的数据结构list和map，参数很多时候也需要接受这种数据结构。\n\n有时我们需要若干参数整合或求值。\n``` clojure\n;如果只是打印出1+2等式出来，也许我们会这样写\n(let [x 1\n      y 2\n      r \"1 + 2 =\"]\n      (println r (+ x 1)))\n\n;显然一个个去赋值，看起来很蠢，也不方便，clojure允许这样写。\n(let [[x y r] '(1 2 \"1 + 2 =\")]\n  (println r (+ x 1)))\n\n;倘若我们只需要计算一个长列表中的几项元素，可以这样写\n(let [[x y z r] '(1 2 3 \"i am string\" 4 5)]\n  (println r)\n  (println (+ x y z)))\n;或者\n(let [[a b c _ d e] '(1 2 3 \"i am string\" 4 5)]\n  (println (+ a b c d e)))\n```\n这种对列表或向量解构，叫做顺序解构。\n\n还有一种，叫做map解构。顾名思义，是对map进行解构。\n\n让我们先定义个比较复杂的map，一名员工的家庭地址和单位地址。\n``` clojure\n(def person {\n             :name \"Mark Volkmann\"\n             :address {\n                       :street \"644 Glen Summit\"\n                       :city \"St. Charles\"\n                       :state \"Missouri\"\n                       :zip 63304}\n             :employer {\n                        :name \"Object Computing, Inc.\"\n                        :address {\n                                  :street \"12140 Woodcrest Executive Drive, Suite 250\"\n                                  :city \"Creve Coeur\"\n                                  :state \"Missouri\"\n                                  :zip 63141}}})\n\n;根据一个已知的map结构，我们打印这个叫Mark的哥们在哪里工作。\n(let [{name :name\n       {emp_name :name} :employer\n       {{emp_street :street} :address} :employer} person]\n    (println name \"work in\" emp_name))\n;这种结构方式有个相当不错的用处，当你确定一个json模型时，可以方便地对其进行处理计算。\n;当然，也有难以预料的时候，也许模型中某个值缺失了，let的结构又能帮你设置默认值。\n;:or可以帮你为不确定的健值设置默认值，它负责判断该健是否存在、值是否为nil\n(let [{name :name\n       phone :phone\n       {emp_name :name} :employer\n       {{emp_street :street} :address} :employer\n      :or {phone \"13700000000\"}} person]\n    (println name \"work in\" emp_name \"\\nThe phone:\" phone))\n```\n这里只说到let的结构，还有函数参数的结构，于此大同小异，等专门说到函数定义再聊。\n","source":"_posts/20170115-初学Clojure—基本语法.md","raw":"---\ntitle: 初学Clojure—基本语法\ndate: 2017-01-15 00:02:55\ncategories:\n- 函数编程\ntags:\n- clojure\n- 教程\n- 并发编程语言\n---\n\n为了全面学习函数式编程语言，之前尝试了scala，不得不承认它的入门门槛略高。于是乎，决定从古老的新语言Clorue入手，作为Lisp的一种方言，语法上无疑是古老的，但它又运行在JVM上且有一些不错的机制，无疑是门新语言。\n\n---\n\n- ### <font color=#0099ff>满篇的括号</font>\n\nLisp语法最大特点就是一堆圆括号，任何函数调用都以“(”开始、“)”结束，函数名或函数本身与参数在括号里呈现前缀表达法。\n\n``` clojure\n(+ 1 3) ;=4\n(add 3 5) ;=8\n(or (= 1 2) (> 4 6)) ;=false\n;下面为匿名函数\n(#(apply * %) '(1 3 4 5 6)) ;=360\n```\n\n除了圆括号外，也有方括号“[]”，在clojure中，它既可以是向量的字面量，也可是函数的参数列表。\n\n``` clojure\n(def a_vector [1 3 4 5 6 6]) ;=#'user/a_vector\n;或者是个函数的参数列表\n(defn a_function [param1 param2]\n  (do\n    (print \"i am function\")))\n```\n\n当然少不了花括号“{}”，在Map与Set两种数据结构的字面量中体现。\n\n``` clojure\n{:key1 val1 :key2 val2}\t;这是Map\n#{ 1 2 3 } ;这是个Set\n```\n扯句无关的，在最原始的Lisp中几乎只有圆括号，例如与之最相近的一种方言Common Lisp。\n\n- ### <font color=#0099ff>优先级取决于括号</font>\n\n与其他语言一样，括号总伴随着表达式求值的优先级。\n\n``` clojure\n(+ (* (- 4 2) (/ 10 5)) (- 1 (+ 4 5)) 2) ;=5\n```\n在Lisp语言中，我们通常很容易获知代码的优先级，正如代码本身就是一棵抽象语法树，能快速知道最先被求值的是哪个节点。代码自身等同于AST，我们称之为“同像性”。\n\n正因Clojure的“同像性”，也为它自己带来其他语言没有的特性—可以自定义语法糖，即自定义宏。\n\n- ### <font color=#0099ff>括号外的一些符号—字面量</font>\n\n要知道，Clojure是一种语法极其简易的语言，括号外也有一些能使代码简明易懂的符号，它们被叫做“字面量”。\n\n``` clojure\n;字符串字面量\n\"i am string\"\n\n;数字字面量\n54321 ;十进制，clojure只有long和double类型\n10.1111333 ;double\n16rffa ;十六进制\n2r101 ;二进制\n\n;其他基本类型\ntrue\nfalse\nnil\n\\c ;字符\n\n;\"\"前面加个#就是正则表达式\n(re-seq #\"\\d*-\\w+\" \"omg123-string\") ;=(\"123-string\")\n\n;关键字\n;在Map数据结构中，关键字字面量是很有用的数据类型\n:keyname ;=:keyname 代表自己\n\n;数据结构字面量\n;map\n{:key1 val1 :key2 val2}\n;list\n'(1 3 4 5 :keyname \"item\")\n;vector\n[1 3 4 5 :keyname \"item\"]\n;set\n#{1 2 3}\n\n;与表达式、函数相关的字面量\n;clojure有个叫quote的东西，它被用来阻止表达式求值，其字面量为'\n;可理解为只是个简单声明一个list，这与上面说到的同像性有关\n'(+ 1 3) ;=(+ 1 3) ;变成了一个list，其中+等同于另外两个元素，被作为一个值塞进list中\n\n;函数的字面量 #\n#(+ %1 %2) ;代表了一个匿名函数\n(def my_add #(+ %1 %2)) ;将匿名函数赋值给my_add\n(my_add 1 3) ;=4\n```\n\n- ### <font color=#0099ff>代码块以及值的作用域</font>\n\n每个函数调用都有圆括号包裹起开，执行多条语句同样需要一个圆括号。一个括号里的多条语句，叫做代码块。\nclojure用宏`do`来依次执行代码块中的语句，且以最后的语句的结果作为返回值。\n``` clojure\n(do\n  (println \"1 + 2\")\n  (+ 2 3)\n  (+ 1 2))\n```\n\n在fn、defn、let、loop、try等语义中，已经隐式使用了do，所以并不需要显示声明调用do。\n``` clojure\n(defn no_do []\n  ((println \"1 + 2\")\n  (+ 2 4)\n  (+ 1 2)))\n```\n\n与代码块息息相关的还有值的作用域，上面用def定义的值，都可在其命名空间全局访问。\n``` clojure\n(ns i_am_namespace)\n(def x_in_i_am_namespace) ;=#'i_am_namespace/x_in_i_am_namespace\n```\n\n有时我们需要局部域的值，clojure为我们提供let，叫做本地绑定。\n``` clojure\n(def z \"def_z\")\n\n(let [x (list 1 2 3 4)\n      y (vector 1 3 4 4)]\n  (do\n    ;do something\n    (println z)\n    (conj x z)))\n\n(println z);=def_z\n\n;报错，x只在定义它的let内有效\n(println x);=CompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context\n```\n\n- ### <font color=#0099ff>入参也可以很方便—let参数的解构</font>\n\nclojure有两类重要的数据结构list和map，参数很多时候也需要接受这种数据结构。\n\n有时我们需要若干参数整合或求值。\n``` clojure\n;如果只是打印出1+2等式出来，也许我们会这样写\n(let [x 1\n      y 2\n      r \"1 + 2 =\"]\n      (println r (+ x 1)))\n\n;显然一个个去赋值，看起来很蠢，也不方便，clojure允许这样写。\n(let [[x y r] '(1 2 \"1 + 2 =\")]\n  (println r (+ x 1)))\n\n;倘若我们只需要计算一个长列表中的几项元素，可以这样写\n(let [[x y z r] '(1 2 3 \"i am string\" 4 5)]\n  (println r)\n  (println (+ x y z)))\n;或者\n(let [[a b c _ d e] '(1 2 3 \"i am string\" 4 5)]\n  (println (+ a b c d e)))\n```\n这种对列表或向量解构，叫做顺序解构。\n\n还有一种，叫做map解构。顾名思义，是对map进行解构。\n\n让我们先定义个比较复杂的map，一名员工的家庭地址和单位地址。\n``` clojure\n(def person {\n             :name \"Mark Volkmann\"\n             :address {\n                       :street \"644 Glen Summit\"\n                       :city \"St. Charles\"\n                       :state \"Missouri\"\n                       :zip 63304}\n             :employer {\n                        :name \"Object Computing, Inc.\"\n                        :address {\n                                  :street \"12140 Woodcrest Executive Drive, Suite 250\"\n                                  :city \"Creve Coeur\"\n                                  :state \"Missouri\"\n                                  :zip 63141}}})\n\n;根据一个已知的map结构，我们打印这个叫Mark的哥们在哪里工作。\n(let [{name :name\n       {emp_name :name} :employer\n       {{emp_street :street} :address} :employer} person]\n    (println name \"work in\" emp_name))\n;这种结构方式有个相当不错的用处，当你确定一个json模型时，可以方便地对其进行处理计算。\n;当然，也有难以预料的时候，也许模型中某个值缺失了，let的结构又能帮你设置默认值。\n;:or可以帮你为不确定的健值设置默认值，它负责判断该健是否存在、值是否为nil\n(let [{name :name\n       phone :phone\n       {emp_name :name} :employer\n       {{emp_street :street} :address} :employer\n      :or {phone \"13700000000\"}} person]\n    (println name \"work in\" emp_name \"\\nThe phone:\" phone))\n```\n这里只说到let的结构，还有函数参数的结构，于此大同小异，等专门说到函数定义再聊。\n","slug":"20170115-初学Clojure—基本语法","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sp00224ejdc09md7ls","content":"<p>为了全面学习函数式编程语言，之前尝试了scala，不得不承认它的入门门槛略高。于是乎，决定从古老的新语言Clorue入手，作为Lisp的一种方言，语法上无疑是古老的，但它又运行在JVM上且有一些不错的机制，无疑是门新语言。</p>\n<hr>\n<ul>\n<li><h3 id=\"满篇的括号\"><a href=\"#满篇的括号\" class=\"headerlink\" title=\"满篇的括号\"></a><font color=#0099ff>满篇的括号</font></h3></li>\n</ul>\n<p>Lisp语法最大特点就是一堆圆括号，任何函数调用都以“(”开始、“)”结束，函数名或函数本身与参数在括号里呈现前缀表达法。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">3</span>) <span class=\"comment\">;=4</span></span><br><span class=\"line\">(<span class=\"name\">add</span> <span class=\"number\">3</span> <span class=\"number\">5</span>) <span class=\"comment\">;=8</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>) (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> <span class=\"number\">4</span> <span class=\"number\">6</span>)) <span class=\"comment\">;=false</span></span><br><span class=\"line\"><span class=\"comment\">;下面为匿名函数</span></span><br><span class=\"line\">(<span class=\"name\">#</span>(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> * %) '(<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>)) <span class=\"comment\">;=360</span></span><br></pre></td></tr></table></figure>\n\n<p>除了圆括号外，也有方括号“[]”，在clojure中，它既可以是向量的字面量，也可是函数的参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_vector [<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">6</span>]) <span class=\"comment\">;=#'user/a_vector</span></span><br><span class=\"line\"><span class=\"comment\">;或者是个函数的参数列表</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_function [param1 param2]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">    (<span class=\"name\">print</span> <span class=\"string\">\"i am function\"</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>当然少不了花括号“{}”，在Map与Set两种数据结构的字面量中体现。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"symbol\">:key1</span> val1 <span class=\"symbol\">:key2</span> val2&#125;\t<span class=\"comment\">;这是Map</span></span><br><span class=\"line\">#&#123; 1 2 3 &#125; ;这是个Set</span><br></pre></td></tr></table></figure>\n<p>扯句无关的，在最原始的Lisp中几乎只有圆括号，例如与之最相近的一种方言Common Lisp。</p>\n<ul>\n<li><h3 id=\"优先级取决于括号\"><a href=\"#优先级取决于括号\" class=\"headerlink\" title=\"优先级取决于括号\"></a><font color=#0099ff>优先级取决于括号</font></h3></li>\n</ul>\n<p>与其他语言一样，括号总伴随着表达式求值的优先级。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">4</span> <span class=\"number\">2</span>) (/ <span class=\"number\">10</span> <span class=\"number\">5</span>)) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">4</span> <span class=\"number\">5</span>)) <span class=\"number\">2</span>) <span class=\"comment\">;=5</span></span><br></pre></td></tr></table></figure>\n<p>在Lisp语言中，我们通常很容易获知代码的优先级，正如代码本身就是一棵抽象语法树，能快速知道最先被求值的是哪个节点。代码自身等同于AST，我们称之为“同像性”。</p>\n<p>正因Clojure的“同像性”，也为它自己带来其他语言没有的特性—可以自定义语法糖，即自定义宏。</p>\n<ul>\n<li><h3 id=\"括号外的一些符号—字面量\"><a href=\"#括号外的一些符号—字面量\" class=\"headerlink\" title=\"括号外的一些符号—字面量\"></a><font color=#0099ff>括号外的一些符号—字面量</font></h3></li>\n</ul>\n<p>要知道，Clojure是一种语法极其简易的语言，括号外也有一些能使代码简明易懂的符号，它们被叫做“字面量”。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;字符串字面量</span></span><br><span class=\"line\"><span class=\"string\">\"i am string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;数字字面量</span></span><br><span class=\"line\"><span class=\"number\">54321</span> <span class=\"comment\">;十进制，clojure只有long和double类型</span></span><br><span class=\"line\"><span class=\"number\">10.1111333</span> <span class=\"comment\">;double</span></span><br><span class=\"line\">16rffa ;十六进制</span><br><span class=\"line\">2r101 ;二进制</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;其他基本类型</span></span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br><span class=\"line\">\\c ;字符</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;\"\"前面加个#就是正则表达式</span></span><br><span class=\"line\">(<span class=\"name\">re-seq</span> #<span class=\"string\">\"\\d*-\\w+\"</span> <span class=\"string\">\"omg123-string\"</span>) <span class=\"comment\">;=(\"123-string\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;关键字</span></span><br><span class=\"line\"><span class=\"comment\">;在Map数据结构中，关键字字面量是很有用的数据类型</span></span><br><span class=\"line\"><span class=\"symbol\">:keyname</span> <span class=\"comment\">;=:keyname 代表自己</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;数据结构字面量</span></span><br><span class=\"line\"><span class=\"comment\">;map</span></span><br><span class=\"line\">&#123;<span class=\"symbol\">:key1</span> val1 <span class=\"symbol\">:key2</span> val2&#125;</span><br><span class=\"line\"><span class=\"comment\">;list</span></span><br><span class=\"line\">'(1 3 4 5 :keyname \"item\")</span><br><span class=\"line\"><span class=\"comment\">;vector</span></span><br><span class=\"line\">[<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"symbol\">:keyname</span> <span class=\"string\">\"item\"</span>]</span><br><span class=\"line\"><span class=\"comment\">;set</span></span><br><span class=\"line\">#&#123;1 2 3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;与表达式、函数相关的字面量</span></span><br><span class=\"line\"><span class=\"comment\">;clojure有个叫quote的东西，它被用来阻止表达式求值，其字面量为'</span></span><br><span class=\"line\"><span class=\"comment\">;可理解为只是个简单声明一个list，这与上面说到的同像性有关</span></span><br><span class=\"line\">'(+ 1 3) ;=(+ 1 3) ;变成了一个list，其中+等同于另外两个元素，被作为一个值塞进list中</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;函数的字面量 #</span></span><br><span class=\"line\">#(+ %1 %2) ;代表了一个匿名函数</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_add #(<span class=\"name\"><span class=\"builtin-name\">+</span></span> %<span class=\"number\">1</span> %<span class=\"number\">2</span>)) <span class=\"comment\">;将匿名函数赋值给my_add</span></span><br><span class=\"line\">(<span class=\"name\">my_add</span> <span class=\"number\">1</span> <span class=\"number\">3</span>) <span class=\"comment\">;=4</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"代码块以及值的作用域\"><a href=\"#代码块以及值的作用域\" class=\"headerlink\" title=\"代码块以及值的作用域\"></a><font color=#0099ff>代码块以及值的作用域</font></h3></li>\n</ul>\n<p>每个函数调用都有圆括号包裹起开，执行多条语句同样需要一个圆括号。一个括号里的多条语句，叫做代码块。<br>clojure用宏<code>do</code>来依次执行代码块中的语句，且以最后的语句的结果作为返回值。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"1 + 2\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<p>在fn、defn、let、loop、try等语义中，已经隐式使用了do，所以并不需要显示声明调用do。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> no_do []</span><br><span class=\"line\">  ((<span class=\"name\">println</span> <span class=\"string\">\"1 + 2\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">2</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>与代码块息息相关的还有值的作用域，上面用def定义的值，都可在其命名空间全局访问。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">ns</span></span> i_am_namespace)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> x_in_i_am_namespace) <span class=\"comment\">;=#'i_am_namespace/x_in_i_am_namespace</span></span><br></pre></td></tr></table></figure>\n\n<p>有时我们需要局部域的值，clojure为我们提供let，叫做本地绑定。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> z <span class=\"string\">\"def_z\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [x (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">      y (<span class=\"name\"><span class=\"builtin-name\">vector</span></span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">4</span>)]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">    <span class=\"comment\">;do something</span></span><br><span class=\"line\">    (<span class=\"name\">println</span> z)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> x z)))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">println</span> z)<span class=\"comment\">;=def_z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;报错，x只在定义它的let内有效</span></span><br><span class=\"line\">(<span class=\"name\">println</span> x)<span class=\"comment\">;=CompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"入参也可以很方便—let参数的解构\"><a href=\"#入参也可以很方便—let参数的解构\" class=\"headerlink\" title=\"入参也可以很方便—let参数的解构\"></a><font color=#0099ff>入参也可以很方便—let参数的解构</font></h3></li>\n</ul>\n<p>clojure有两类重要的数据结构list和map，参数很多时候也需要接受这种数据结构。</p>\n<p>有时我们需要若干参数整合或求值。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;如果只是打印出1+2等式出来，也许我们会这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [x <span class=\"number\">1</span></span><br><span class=\"line\">      y <span class=\"number\">2</span></span><br><span class=\"line\">      r <span class=\"string\">\"1 + 2 =\"</span>]</span><br><span class=\"line\">      (<span class=\"name\">println</span> r (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">1</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;显然一个个去赋值，看起来很蠢，也不方便，clojure允许这样写。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y r] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"string\">\"1 + 2 =\"</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> r (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">1</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;倘若我们只需要计算一个长列表中的几项元素，可以这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y z r] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"string\">\"i am string\"</span> <span class=\"number\">4</span> <span class=\"number\">5</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> r)</span><br><span class=\"line\">  (<span class=\"name\">println</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z)))</span><br><span class=\"line\"><span class=\"comment\">;或者</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[a b c _ d e] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"string\">\"i am string\"</span> <span class=\"number\">4</span> <span class=\"number\">5</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> a b c d e)))</span><br></pre></td></tr></table></figure>\n<p>这种对列表或向量解构，叫做顺序解构。</p>\n<p>还有一种，叫做map解构。顾名思义，是对map进行解构。</p>\n<p>让我们先定义个比较复杂的map，一名员工的家庭地址和单位地址。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> person &#123;</span><br><span class=\"line\">             <span class=\"symbol\">:name</span> <span class=\"string\">\"Mark Volkmann\"</span></span><br><span class=\"line\">             <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                       <span class=\"symbol\">:street</span> <span class=\"string\">\"644 Glen Summit\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:city</span> <span class=\"string\">\"St. Charles\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:zip</span> <span class=\"number\">63304</span>&#125;</span><br><span class=\"line\">             <span class=\"symbol\">:employer</span> &#123;</span><br><span class=\"line\">                        <span class=\"symbol\">:name</span> <span class=\"string\">\"Object Computing, Inc.\"</span></span><br><span class=\"line\">                        <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                                  <span class=\"symbol\">:street</span> <span class=\"string\">\"12140 Woodcrest Executive Drive, Suite 250\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:city</span> <span class=\"string\">\"Creve Coeur\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:zip</span> <span class=\"number\">63141</span>&#125;&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;根据一个已知的map结构，我们打印这个叫Mark的哥们在哪里工作。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [&#123;name <span class=\"symbol\">:name</span></span><br><span class=\"line\">       &#123;emp_name <span class=\"symbol\">:name</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">       &#123;&#123;emp_street <span class=\"symbol\">:street</span>&#125; <span class=\"symbol\">:address</span>&#125; <span class=\"symbol\">:employer</span>&#125; person]</span><br><span class=\"line\">    (<span class=\"name\">println</span> name <span class=\"string\">\"work in\"</span> emp_name))</span><br><span class=\"line\"><span class=\"comment\">;这种结构方式有个相当不错的用处，当你确定一个json模型时，可以方便地对其进行处理计算。</span></span><br><span class=\"line\"><span class=\"comment\">;当然，也有难以预料的时候，也许模型中某个值缺失了，let的结构又能帮你设置默认值。</span></span><br><span class=\"line\"><span class=\"comment\">;:or可以帮你为不确定的健值设置默认值，它负责判断该健是否存在、值是否为nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [&#123;name <span class=\"symbol\">:name</span></span><br><span class=\"line\">       phone <span class=\"symbol\">:phone</span></span><br><span class=\"line\">       &#123;emp_name <span class=\"symbol\">:name</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">       &#123;&#123;emp_street <span class=\"symbol\">:street</span>&#125; <span class=\"symbol\">:address</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">      <span class=\"symbol\">:or</span> &#123;phone <span class=\"string\">\"13700000000\"</span>&#125;&#125; person]</span><br><span class=\"line\">    (<span class=\"name\">println</span> name <span class=\"string\">\"work in\"</span> emp_name <span class=\"string\">\"\\nThe phone:\"</span> phone))</span><br></pre></td></tr></table></figure>\n<p>这里只说到let的结构，还有函数参数的结构，于此大同小异，等专门说到函数定义再聊。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了全面学习函数式编程语言，之前尝试了scala，不得不承认它的入门门槛略高。于是乎，决定从古老的新语言Clorue入手，作为Lisp的一种方言，语法上无疑是古老的，但它又运行在JVM上且有一些不错的机制，无疑是门新语言。</p>\n<hr>\n<ul>\n<li><h3 id=\"满篇的括号\"><a href=\"#满篇的括号\" class=\"headerlink\" title=\"满篇的括号\"></a><font color=#0099ff>满篇的括号</font></h3></li>\n</ul>\n<p>Lisp语法最大特点就是一堆圆括号，任何函数调用都以“(”开始、“)”结束，函数名或函数本身与参数在括号里呈现前缀表达法。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">3</span>) <span class=\"comment\">;=4</span></span><br><span class=\"line\">(<span class=\"name\">add</span> <span class=\"number\">3</span> <span class=\"number\">5</span>) <span class=\"comment\">;=8</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">or</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>) (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> <span class=\"number\">4</span> <span class=\"number\">6</span>)) <span class=\"comment\">;=false</span></span><br><span class=\"line\"><span class=\"comment\">;下面为匿名函数</span></span><br><span class=\"line\">(<span class=\"name\">#</span>(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> * %) '(<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>)) <span class=\"comment\">;=360</span></span><br></pre></td></tr></table></figure>\n\n<p>除了圆括号外，也有方括号“[]”，在clojure中，它既可以是向量的字面量，也可是函数的参数列表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_vector [<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">6</span>]) <span class=\"comment\">;=#'user/a_vector</span></span><br><span class=\"line\"><span class=\"comment\">;或者是个函数的参数列表</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> a_function [param1 param2]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">    (<span class=\"name\">print</span> <span class=\"string\">\"i am function\"</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>当然少不了花括号“{}”，在Map与Set两种数据结构的字面量中体现。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"symbol\">:key1</span> val1 <span class=\"symbol\">:key2</span> val2&#125;\t<span class=\"comment\">;这是Map</span></span><br><span class=\"line\">#&#123; 1 2 3 &#125; ;这是个Set</span><br></pre></td></tr></table></figure>\n<p>扯句无关的，在最原始的Lisp中几乎只有圆括号，例如与之最相近的一种方言Common Lisp。</p>\n<ul>\n<li><h3 id=\"优先级取决于括号\"><a href=\"#优先级取决于括号\" class=\"headerlink\" title=\"优先级取决于括号\"></a><font color=#0099ff>优先级取决于括号</font></h3></li>\n</ul>\n<p>与其他语言一样，括号总伴随着表达式求值的优先级。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">*</span></span> (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">4</span> <span class=\"number\">2</span>) (/ <span class=\"number\">10</span> <span class=\"number\">5</span>)) (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">4</span> <span class=\"number\">5</span>)) <span class=\"number\">2</span>) <span class=\"comment\">;=5</span></span><br></pre></td></tr></table></figure>\n<p>在Lisp语言中，我们通常很容易获知代码的优先级，正如代码本身就是一棵抽象语法树，能快速知道最先被求值的是哪个节点。代码自身等同于AST，我们称之为“同像性”。</p>\n<p>正因Clojure的“同像性”，也为它自己带来其他语言没有的特性—可以自定义语法糖，即自定义宏。</p>\n<ul>\n<li><h3 id=\"括号外的一些符号—字面量\"><a href=\"#括号外的一些符号—字面量\" class=\"headerlink\" title=\"括号外的一些符号—字面量\"></a><font color=#0099ff>括号外的一些符号—字面量</font></h3></li>\n</ul>\n<p>要知道，Clojure是一种语法极其简易的语言，括号外也有一些能使代码简明易懂的符号，它们被叫做“字面量”。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;字符串字面量</span></span><br><span class=\"line\"><span class=\"string\">\"i am string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;数字字面量</span></span><br><span class=\"line\"><span class=\"number\">54321</span> <span class=\"comment\">;十进制，clojure只有long和double类型</span></span><br><span class=\"line\"><span class=\"number\">10.1111333</span> <span class=\"comment\">;double</span></span><br><span class=\"line\">16rffa ;十六进制</span><br><span class=\"line\">2r101 ;二进制</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;其他基本类型</span></span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br><span class=\"line\">\\c ;字符</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;\"\"前面加个#就是正则表达式</span></span><br><span class=\"line\">(<span class=\"name\">re-seq</span> #<span class=\"string\">\"\\d*-\\w+\"</span> <span class=\"string\">\"omg123-string\"</span>) <span class=\"comment\">;=(\"123-string\")</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;关键字</span></span><br><span class=\"line\"><span class=\"comment\">;在Map数据结构中，关键字字面量是很有用的数据类型</span></span><br><span class=\"line\"><span class=\"symbol\">:keyname</span> <span class=\"comment\">;=:keyname 代表自己</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;数据结构字面量</span></span><br><span class=\"line\"><span class=\"comment\">;map</span></span><br><span class=\"line\">&#123;<span class=\"symbol\">:key1</span> val1 <span class=\"symbol\">:key2</span> val2&#125;</span><br><span class=\"line\"><span class=\"comment\">;list</span></span><br><span class=\"line\">'(1 3 4 5 :keyname \"item\")</span><br><span class=\"line\"><span class=\"comment\">;vector</span></span><br><span class=\"line\">[<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"symbol\">:keyname</span> <span class=\"string\">\"item\"</span>]</span><br><span class=\"line\"><span class=\"comment\">;set</span></span><br><span class=\"line\">#&#123;1 2 3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;与表达式、函数相关的字面量</span></span><br><span class=\"line\"><span class=\"comment\">;clojure有个叫quote的东西，它被用来阻止表达式求值，其字面量为'</span></span><br><span class=\"line\"><span class=\"comment\">;可理解为只是个简单声明一个list，这与上面说到的同像性有关</span></span><br><span class=\"line\">'(+ 1 3) ;=(+ 1 3) ;变成了一个list，其中+等同于另外两个元素，被作为一个值塞进list中</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;函数的字面量 #</span></span><br><span class=\"line\">#(+ %1 %2) ;代表了一个匿名函数</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_add #(<span class=\"name\"><span class=\"builtin-name\">+</span></span> %<span class=\"number\">1</span> %<span class=\"number\">2</span>)) <span class=\"comment\">;将匿名函数赋值给my_add</span></span><br><span class=\"line\">(<span class=\"name\">my_add</span> <span class=\"number\">1</span> <span class=\"number\">3</span>) <span class=\"comment\">;=4</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"代码块以及值的作用域\"><a href=\"#代码块以及值的作用域\" class=\"headerlink\" title=\"代码块以及值的作用域\"></a><font color=#0099ff>代码块以及值的作用域</font></h3></li>\n</ul>\n<p>每个函数调用都有圆括号包裹起开，执行多条语句同样需要一个圆括号。一个括号里的多条语句，叫做代码块。<br>clojure用宏<code>do</code>来依次执行代码块中的语句，且以最后的语句的结果作为返回值。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">  (<span class=\"name\">println</span> <span class=\"string\">\"1 + 2\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">2</span> <span class=\"number\">3</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br></pre></td></tr></table></figure>\n\n<p>在fn、defn、let、loop、try等语义中，已经隐式使用了do，所以并不需要显示声明调用do。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> no_do []</span><br><span class=\"line\">  ((<span class=\"name\">println</span> <span class=\"string\">\"1 + 2\"</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">2</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>与代码块息息相关的还有值的作用域，上面用def定义的值，都可在其命名空间全局访问。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">ns</span></span> i_am_namespace)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> x_in_i_am_namespace) <span class=\"comment\">;=#'i_am_namespace/x_in_i_am_namespace</span></span><br></pre></td></tr></table></figure>\n\n<p>有时我们需要局部域的值，clojure为我们提供let，叫做本地绑定。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> z <span class=\"string\">\"def_z\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [x (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">      y (<span class=\"name\"><span class=\"builtin-name\">vector</span></span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">4</span>)]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">do</span></span></span><br><span class=\"line\">    <span class=\"comment\">;do something</span></span><br><span class=\"line\">    (<span class=\"name\">println</span> z)</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> x z)))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">println</span> z)<span class=\"comment\">;=def_z</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;报错，x只在定义它的let内有效</span></span><br><span class=\"line\">(<span class=\"name\">println</span> x)<span class=\"comment\">;=CompilerException java.lang.RuntimeException: Unable to resolve symbol: x in this context</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"入参也可以很方便—let参数的解构\"><a href=\"#入参也可以很方便—let参数的解构\" class=\"headerlink\" title=\"入参也可以很方便—let参数的解构\"></a><font color=#0099ff>入参也可以很方便—let参数的解构</font></h3></li>\n</ul>\n<p>clojure有两类重要的数据结构list和map，参数很多时候也需要接受这种数据结构。</p>\n<p>有时我们需要若干参数整合或求值。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;如果只是打印出1+2等式出来，也许我们会这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [x <span class=\"number\">1</span></span><br><span class=\"line\">      y <span class=\"number\">2</span></span><br><span class=\"line\">      r <span class=\"string\">\"1 + 2 =\"</span>]</span><br><span class=\"line\">      (<span class=\"name\">println</span> r (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">1</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;显然一个个去赋值，看起来很蠢，也不方便，clojure允许这样写。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y r] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"string\">\"1 + 2 =\"</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> r (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x <span class=\"number\">1</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;倘若我们只需要计算一个长列表中的几项元素，可以这样写</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y z r] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"string\">\"i am string\"</span> <span class=\"number\">4</span> <span class=\"number\">5</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> r)</span><br><span class=\"line\">  (<span class=\"name\">println</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> x y z)))</span><br><span class=\"line\"><span class=\"comment\">;或者</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[a b c _ d e] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"string\">\"i am string\"</span> <span class=\"number\">4</span> <span class=\"number\">5</span>)]</span><br><span class=\"line\">  (<span class=\"name\">println</span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> a b c d e)))</span><br></pre></td></tr></table></figure>\n<p>这种对列表或向量解构，叫做顺序解构。</p>\n<p>还有一种，叫做map解构。顾名思义，是对map进行解构。</p>\n<p>让我们先定义个比较复杂的map，一名员工的家庭地址和单位地址。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> person &#123;</span><br><span class=\"line\">             <span class=\"symbol\">:name</span> <span class=\"string\">\"Mark Volkmann\"</span></span><br><span class=\"line\">             <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                       <span class=\"symbol\">:street</span> <span class=\"string\">\"644 Glen Summit\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:city</span> <span class=\"string\">\"St. Charles\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:zip</span> <span class=\"number\">63304</span>&#125;</span><br><span class=\"line\">             <span class=\"symbol\">:employer</span> &#123;</span><br><span class=\"line\">                        <span class=\"symbol\">:name</span> <span class=\"string\">\"Object Computing, Inc.\"</span></span><br><span class=\"line\">                        <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                                  <span class=\"symbol\">:street</span> <span class=\"string\">\"12140 Woodcrest Executive Drive, Suite 250\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:city</span> <span class=\"string\">\"Creve Coeur\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:zip</span> <span class=\"number\">63141</span>&#125;&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;根据一个已知的map结构，我们打印这个叫Mark的哥们在哪里工作。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [&#123;name <span class=\"symbol\">:name</span></span><br><span class=\"line\">       &#123;emp_name <span class=\"symbol\">:name</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">       &#123;&#123;emp_street <span class=\"symbol\">:street</span>&#125; <span class=\"symbol\">:address</span>&#125; <span class=\"symbol\">:employer</span>&#125; person]</span><br><span class=\"line\">    (<span class=\"name\">println</span> name <span class=\"string\">\"work in\"</span> emp_name))</span><br><span class=\"line\"><span class=\"comment\">;这种结构方式有个相当不错的用处，当你确定一个json模型时，可以方便地对其进行处理计算。</span></span><br><span class=\"line\"><span class=\"comment\">;当然，也有难以预料的时候，也许模型中某个值缺失了，let的结构又能帮你设置默认值。</span></span><br><span class=\"line\"><span class=\"comment\">;:or可以帮你为不确定的健值设置默认值，它负责判断该健是否存在、值是否为nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [&#123;name <span class=\"symbol\">:name</span></span><br><span class=\"line\">       phone <span class=\"symbol\">:phone</span></span><br><span class=\"line\">       &#123;emp_name <span class=\"symbol\">:name</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">       &#123;&#123;emp_street <span class=\"symbol\">:street</span>&#125; <span class=\"symbol\">:address</span>&#125; <span class=\"symbol\">:employer</span></span><br><span class=\"line\">      <span class=\"symbol\">:or</span> &#123;phone <span class=\"string\">\"13700000000\"</span>&#125;&#125; person]</span><br><span class=\"line\">    (<span class=\"name\">println</span> name <span class=\"string\">\"work in\"</span> emp_name <span class=\"string\">\"\\nThe phone:\"</span> phone))</span><br></pre></td></tr></table></figure>\n<p>这里只说到let的结构，还有函数参数的结构，于此大同小异，等专门说到函数定义再聊。</p>\n"},{"title":"初学Clojure—函数与高阶函数","date":"2017-01-21T15:28:49.000Z","_content":"\n本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。\n\n---\n\n- ### <font color=#0099ff>函数的结果传给下一个函数</font>\n\n有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。\n\n假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。\n``` clojure\n;为了方便，假如只找第一个\n(defn find-name&age [names] (vec (.split\n                                   (first\n                                     (re-seq #\"\\w*-\\d*\" names))\n                                   \"-\")))\n(find-name&age \"tom-42tim-24jim-12\");=[tom 42]\n;上面find-name&age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。\n```\nclojure为我们提供了一个可以省去那么多没必要圆括号的函数-`comp`！！\n``` clojure\n;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参\n((comp vec #(.split % \"-\") first re-seq) #\"\\w*-\\d*\" \"tom-42tim-24jim-12\");=[tom 42]\n```\n- ### <font color=#0099ff>实在不想每次都传那么多个参数！</font>\n\n假如你的代码里总是需要`(+ 101 1 2 ? ? ?)`这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。\n``` clojure\n;传入101 1 2三个实参\n(def my_+ (partial + 101 1 2))\n;传入剩余参数\n(my_+ 1 2 3 4);=114\n```\n说到偏函数，自然会想到柯里化，然而。.\n``` clojure\n(defn rematch [rex]\n  #(re-seq rex %))\n;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！\n((rematch #\"\\w*-\\d*\") \"tom-42tim-24jim-12\")\n```\n\n- ### <font color=#0099ff>传入或返回一个函数</font>\n\n函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如`apply`、`map`、`filter`等。\n``` clojure\n(map + [1 2 3 4] [1 2 3]);=(2 4 6)\n(apply + [1 2 3 4]);=10\n;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。\n(map #(name %) [:a :b :c]);=(\"a\" \"b\" \"c\")\n```\n上面的一个例子`rematch [rex]`就是一个把函数作为返回值的高阶函数。\n\n- ### <font color=#0099ff>绝妙的闭包</font>\n\n在之前出现过的例子，有不少已经体现了闭包这个概念。\n\n闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。`A()`定义并返回`B()`，且`B()`可以返回`A()`中声明的局部量，那么调用`A()`时，得到一个闭包函数。偏函数和柯里化是一种闭包。\n``` clojure\n;函数中定义并返回一个匿名函数\n(defn rematch2 [content]\n  (fn [rex]\n    ;匿名函数可以随意返回上下文(即rematch2内)的局部量content\n    (re-seq rex (str content \"///0099ff\"))))\n((rematch2 \"tom-42tim-24jim-12\") #\"\\d+\")\n```\n","source":"_posts/20170121-初学Clojure—函数与高阶函数.md","raw":"---\ntitle: 初学Clojure—函数与高阶函数\ndate: 2017-01-21 23:28:49\ncategories:\n- 函数编程\ntags:\n- clojure\n- 教程\n- 并发编程语言\n---\n\n本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。\n\n---\n\n- ### <font color=#0099ff>函数的结果传给下一个函数</font>\n\n有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。\n\n假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。\n``` clojure\n;为了方便，假如只找第一个\n(defn find-name&age [names] (vec (.split\n                                   (first\n                                     (re-seq #\"\\w*-\\d*\" names))\n                                   \"-\")))\n(find-name&age \"tom-42tim-24jim-12\");=[tom 42]\n;上面find-name&age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。\n```\nclojure为我们提供了一个可以省去那么多没必要圆括号的函数-`comp`！！\n``` clojure\n;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参\n((comp vec #(.split % \"-\") first re-seq) #\"\\w*-\\d*\" \"tom-42tim-24jim-12\");=[tom 42]\n```\n- ### <font color=#0099ff>实在不想每次都传那么多个参数！</font>\n\n假如你的代码里总是需要`(+ 101 1 2 ? ? ?)`这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。\n``` clojure\n;传入101 1 2三个实参\n(def my_+ (partial + 101 1 2))\n;传入剩余参数\n(my_+ 1 2 3 4);=114\n```\n说到偏函数，自然会想到柯里化，然而。.\n``` clojure\n(defn rematch [rex]\n  #(re-seq rex %))\n;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！\n((rematch #\"\\w*-\\d*\") \"tom-42tim-24jim-12\")\n```\n\n- ### <font color=#0099ff>传入或返回一个函数</font>\n\n函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如`apply`、`map`、`filter`等。\n``` clojure\n(map + [1 2 3 4] [1 2 3]);=(2 4 6)\n(apply + [1 2 3 4]);=10\n;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。\n(map #(name %) [:a :b :c]);=(\"a\" \"b\" \"c\")\n```\n上面的一个例子`rematch [rex]`就是一个把函数作为返回值的高阶函数。\n\n- ### <font color=#0099ff>绝妙的闭包</font>\n\n在之前出现过的例子，有不少已经体现了闭包这个概念。\n\n闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。`A()`定义并返回`B()`，且`B()`可以返回`A()`中声明的局部量，那么调用`A()`时，得到一个闭包函数。偏函数和柯里化是一种闭包。\n``` clojure\n;函数中定义并返回一个匿名函数\n(defn rematch2 [content]\n  (fn [rex]\n    ;匿名函数可以随意返回上下文(即rematch2内)的局部量content\n    (re-seq rex (str content \"///0099ff\"))))\n((rematch2 \"tom-42tim-24jim-12\") #\"\\d+\")\n```\n","slug":"20170121-初学Clojure—函数与高阶函数","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sq00264ejd241xc1k1","content":"<p>本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。</p>\n<hr>\n<ul>\n<li><h3 id=\"函数的结果传给下一个函数\"><a href=\"#函数的结果传给下一个函数\" class=\"headerlink\" title=\"函数的结果传给下一个函数\"></a><font color=#0099ff>函数的结果传给下一个函数</font></h3></li>\n</ul>\n<p>有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。</p>\n<p>假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;为了方便，假如只找第一个</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> find-name&amp;age [names] (<span class=\"name\"><span class=\"builtin-name\">vec</span></span> (<span class=\"name\">.split</span></span><br><span class=\"line\">                                   (<span class=\"name\"><span class=\"builtin-name\">first</span></span></span><br><span class=\"line\">                                     (<span class=\"name\">re-seq</span> #<span class=\"string\">\"\\w*-\\d*\"</span> names))</span><br><span class=\"line\">                                   <span class=\"string\">\"-\"</span>)))</span><br><span class=\"line\">(<span class=\"name\">find-name&amp;age</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>)<span class=\"comment\">;=[tom 42]</span></span><br><span class=\"line\"><span class=\"comment\">;上面find-name&amp;age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。</span></span><br></pre></td></tr></table></figure>\n<p>clojure为我们提供了一个可以省去那么多没必要圆括号的函数-<code>comp</code>！！</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">comp</span></span> vec #(<span class=\"name\">.split</span> % <span class=\"string\">\"-\"</span>) first re-seq) #<span class=\"string\">\"\\w*-\\d*\"</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>)<span class=\"comment\">;=[tom 42]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"实在不想每次都传那么多个参数！\"><a href=\"#实在不想每次都传那么多个参数！\" class=\"headerlink\" title=\"实在不想每次都传那么多个参数！\"></a><font color=#0099ff>实在不想每次都传那么多个参数！</font></h3></li>\n</ul>\n<p>假如你的代码里总是需要<code>(+ 101 1 2 ? ? ?)</code>这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;传入101 1 2三个实参</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_+ (<span class=\"name\"><span class=\"builtin-name\">partial</span></span> + <span class=\"number\">101</span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"comment\">;传入剩余参数</span></span><br><span class=\"line\">(<span class=\"name\">my_+</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)<span class=\"comment\">;=114</span></span><br></pre></td></tr></table></figure>\n<p>说到偏函数，自然会想到柯里化，然而。.</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rematch [rex]</span><br><span class=\"line\">  #(<span class=\"name\">re-seq</span> rex %))</span><br><span class=\"line\"><span class=\"comment\">;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！</span></span><br><span class=\"line\">((<span class=\"name\">rematch</span> #<span class=\"string\">\"\\w*-\\d*\"</span>) <span class=\"string\">\"tom-42tim-24jim-12\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"传入或返回一个函数\"><a href=\"#传入或返回一个函数\" class=\"headerlink\" title=\"传入或返回一个函数\"></a><font color=#0099ff>传入或返回一个函数</font></h3></li>\n</ul>\n<p>函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如<code>apply</code>、<code>map</code>、<code>filter</code>等。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">map</span></span> + [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>] [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=(2 4 6)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> + [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>])<span class=\"comment\">;=10</span></span><br><span class=\"line\"><span class=\"comment\">;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">map</span></span> #(<span class=\"name\"><span class=\"builtin-name\">name</span></span> %) [<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>])<span class=\"comment\">;=(\"a\" \"b\" \"c\")</span></span><br></pre></td></tr></table></figure>\n<p>上面的一个例子<code>rematch [rex]</code>就是一个把函数作为返回值的高阶函数。</p>\n<ul>\n<li><h3 id=\"绝妙的闭包\"><a href=\"#绝妙的闭包\" class=\"headerlink\" title=\"绝妙的闭包\"></a><font color=#0099ff>绝妙的闭包</font></h3></li>\n</ul>\n<p>在之前出现过的例子，有不少已经体现了闭包这个概念。</p>\n<p>闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。<code>A()</code>定义并返回<code>B()</code>，且<code>B()</code>可以返回<code>A()</code>中声明的局部量，那么调用<code>A()</code>时，得到一个闭包函数。偏函数和柯里化是一种闭包。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;函数中定义并返回一个匿名函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rematch2 [content]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [rex]</span><br><span class=\"line\">    <span class=\"comment\">;匿名函数可以随意返回上下文(即rematch2内)的局部量content</span></span><br><span class=\"line\">    (<span class=\"name\">re-seq</span> rex (<span class=\"name\"><span class=\"builtin-name\">str</span></span> content <span class=\"string\">\"///0099ff\"</span>))))</span><br><span class=\"line\">((<span class=\"name\">rematch2</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>) #<span class=\"string\">\"\\d+\"</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>本来这应该放在递归之前的，不过没什么影响，反而对闭包的理解有帮助。把函数作为第一等公民的clojure，自然会给函数提供吊炸天的功能，使其变得吊炸天，写出更吊炸天的闭包！例如串行调用的组合函数、偏函数和柯里化、以及高阶函数等等。</p>\n<hr>\n<ul>\n<li><h3 id=\"函数的结果传给下一个函数\"><a href=\"#函数的结果传给下一个函数\" class=\"headerlink\" title=\"函数的结果传给下一个函数\"></a><font color=#0099ff>函数的结果传给下一个函数</font></h3></li>\n</ul>\n<p>有时候我们一个数据，需要依次传给一个函数处理后，传递给另外一个函数继续处理，多次传递形成函数链。</p>\n<p>假如在一堆没有换行符的字符串中找某个人名以及他的年龄，可能需要这样的函数链。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;为了方便，假如只找第一个</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> find-name&amp;age [names] (<span class=\"name\"><span class=\"builtin-name\">vec</span></span> (<span class=\"name\">.split</span></span><br><span class=\"line\">                                   (<span class=\"name\"><span class=\"builtin-name\">first</span></span></span><br><span class=\"line\">                                     (<span class=\"name\">re-seq</span> #<span class=\"string\">\"\\w*-\\d*\"</span> names))</span><br><span class=\"line\">                                   <span class=\"string\">\"-\"</span>)))</span><br><span class=\"line\">(<span class=\"name\">find-name&amp;age</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>)<span class=\"comment\">;=[tom 42]</span></span><br><span class=\"line\"><span class=\"comment\">;上面find-name&amp;age [names]实在写得难看，一条链下来的函数多得要死不说，单单圆括号就实在让人生畏。</span></span><br></pre></td></tr></table></figure>\n<p>clojure为我们提供了一个可以省去那么多没必要圆括号的函数-<code>comp</code>！！</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;comp从右到左依次接受上一个函数的返回值，最后一个函数则接受comp外的实参</span></span><br><span class=\"line\">((<span class=\"name\"><span class=\"builtin-name\">comp</span></span> vec #(<span class=\"name\">.split</span> % <span class=\"string\">\"-\"</span>) first re-seq) #<span class=\"string\">\"\\w*-\\d*\"</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>)<span class=\"comment\">;=[tom 42]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><h3 id=\"实在不想每次都传那么多个参数！\"><a href=\"#实在不想每次都传那么多个参数！\" class=\"headerlink\" title=\"实在不想每次都传那么多个参数！\"></a><font color=#0099ff>实在不想每次都传那么多个参数！</font></h3></li>\n</ul>\n<p>假如你的代码里总是需要<code>(+ 101 1 2 ? ? ?)</code>这样的函数的，偏函数可以让你传入某些固定的实参并返回一个需要传入剩余参数的新函数。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;传入101 1 2三个实参</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_+ (<span class=\"name\"><span class=\"builtin-name\">partial</span></span> + <span class=\"number\">101</span> <span class=\"number\">1</span> <span class=\"number\">2</span>))</span><br><span class=\"line\"><span class=\"comment\">;传入剩余参数</span></span><br><span class=\"line\">(<span class=\"name\">my_+</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)<span class=\"comment\">;=114</span></span><br></pre></td></tr></table></figure>\n<p>说到偏函数，自然会想到柯里化，然而。.</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rematch [rex]</span><br><span class=\"line\">  #(<span class=\"name\">re-seq</span> rex %))</span><br><span class=\"line\"><span class=\"comment\">;括号没法省略，柯里化？算了吧！可以用变参就用变参吧！</span></span><br><span class=\"line\">((<span class=\"name\">rematch</span> #<span class=\"string\">\"\\w*-\\d*\"</span>) <span class=\"string\">\"tom-42tim-24jim-12\"</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"传入或返回一个函数\"><a href=\"#传入或返回一个函数\" class=\"headerlink\" title=\"传入或返回一个函数\"></a><font color=#0099ff>传入或返回一个函数</font></h3></li>\n</ul>\n<p>函数作为实参传入另外一个函数，后者则是一个高阶函数。clojure提供了许多高阶函数，例如<code>apply</code>、<code>map</code>、<code>filter</code>等。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">map</span></span> + [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>] [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=(2 4 6)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> + [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>])<span class=\"comment\">;=10</span></span><br><span class=\"line\"><span class=\"comment\">;匿名函数是高阶函数的一个重要组成部分，临时作为实参，尤其作为返回值。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">map</span></span> #(<span class=\"name\"><span class=\"builtin-name\">name</span></span> %) [<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>])<span class=\"comment\">;=(\"a\" \"b\" \"c\")</span></span><br></pre></td></tr></table></figure>\n<p>上面的一个例子<code>rematch [rex]</code>就是一个把函数作为返回值的高阶函数。</p>\n<ul>\n<li><h3 id=\"绝妙的闭包\"><a href=\"#绝妙的闭包\" class=\"headerlink\" title=\"绝妙的闭包\"></a><font color=#0099ff>绝妙的闭包</font></h3></li>\n</ul>\n<p>在之前出现过的例子，有不少已经体现了闭包这个概念。</p>\n<p>闭包什么意思呢？简单且不严谨的说，就是返回一个函数，然后这个函数可随意访问定义它的上下文的局部量。<code>A()</code>定义并返回<code>B()</code>，且<code>B()</code>可以返回<code>A()</code>中声明的局部量，那么调用<code>A()</code>时，得到一个闭包函数。偏函数和柯里化是一种闭包。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;函数中定义并返回一个匿名函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rematch2 [content]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [rex]</span><br><span class=\"line\">    <span class=\"comment\">;匿名函数可以随意返回上下文(即rematch2内)的局部量content</span></span><br><span class=\"line\">    (<span class=\"name\">re-seq</span> rex (<span class=\"name\"><span class=\"builtin-name\">str</span></span> content <span class=\"string\">\"///0099ff\"</span>))))</span><br><span class=\"line\">((<span class=\"name\">rematch2</span> <span class=\"string\">\"tom-42tim-24jim-12\"</span>) #<span class=\"string\">\"\\d+\"</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"初学Clojure—集合与数据结构","date":"2017-01-23T15:51:02.000Z","_content":"\n\n这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。\n\n---\n\n- ### <font color=#0099ff>非写入硬盘的数据持久化</font>\n\n这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。\n``` clojure\n;声明list\n(def lst1 (list 1 2 3 4))\n;添加新元素，它重新生产一个“新列表”\n(def lst2 (conj lst 5));=(5 1 2 3 4)\n;lst引用依旧指向(1 2 3 4)\nlst1 ;=(1 2 3 4)\n```\n为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。\n\n其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对`lst1`做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于`lst2`这个版本中，`(1 2 3 4)`则`lst1`与`lst2`共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。\n\n- ### <font color=#0099ff>它叫做向量，不叫数组</font>\n\n在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是`[]`。\n\n如何创建向量呢？\n``` clojure\n;我们可以这样创建一个vector，直接使用字面量\n(def vec1 [1 2 3 4 5])\n;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维\n(def vec2 (vec (range 5)))\n;显然，是往一个vector塞另外一个集合\n(def vec3 (into vec1 (range 6 10)))\n```\n\n可以限制vector为基础数据类型的集合，只要使用`vector-of`函数即可，支持`:int`、`:long`、`:float`、`:double`、`:byte`、`:short`、`:boolean`、`:char`这些基础类型。\n``` clojure\n(into (vector-of :int) [Math/PI 2 1.4]);=[3 2 1]\n(into (vector-of :char) [100 102 104]);=[\\d \\f \\h]\n(into (vector-of :boolean) [false true 1 nil]);=[false true true false]\n(into (vector-of :long) [\"string\" \"number\" 10000])\n;=ClassCastException java.lang.String cannot be cast to java.lang.Number\n```\n\n有索引，自然可以用下标获取元素，有`nth`、`get`、向量自身作为函数三种方式，每种都有那么一点不同。\n``` clojure\n(def nil_vec nil)\n(def empty_vec [])\n(def char_vec [\\a \\b \\c \\d \\f])\n\n(nth nil_vec 3);=nil\n(nth empty_vec 3);=IndexOutOfBoundsException\n(nth char_vec 3);=\\d\n;支持not find参数，找不到元素则返回该实参\n(nth char_vec 100 :no!);=:no!\n\n(get nil_vec 3);=nil\n(get empty_vec 3);=nil\n(get char_vec 3);=\\d\n;同上\n(get char_vec 100 :no!);=:no!\n\n;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素\n(nil_vec 3);=NullPointerException\n(empty_vec 3);=IndexOutOfBoundsException\n(char_vec 3);=\\d\n;然而，它并不支持上面两种方式支持的not find参数\n```\n<font size=2 color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font>\n\n那么来看看怎么修改元素。\n``` clojure\n(def num_vec [1 2 3 4 5])\n;直接修改对于下标的元素\n(assoc num_vec 2 \"string\");=[1 2 \"string\" 4 5]\n;这个则是使用一个函数去改变对应下标的元素\n(update num_vec 2 * 100);=[1 2 300 4 5]\n\n;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素\n(def num_vec2 [[1 2 3] [4 5 6] [7 8 9]])\n(get-in num_vec2 [1 2]);=6\n(get-in num_vec2 [1 6]);=nil\n;支持not find参数\n(get-in num_vec2 [1 6] :no!);=:no!\n(assoc-in num_vec2 [1 2] \\s);=[[1 2 3] [4 5 \\s] [7 8 9]]\n;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException\n(assoc-in num_vec2 [1 3] \\s);=[[1 2 3] [4 5 6 \\s] [7 8 9]]\n(update-in num_vec2 [1 2] * 100);=[[1 2 3] [4 5 600] [7 8 9]]\n(update-in num_vec2 [1 3] * 100);=NullPointerException\n```\n\nvector提供了三个函数，使其支持栈操作，分别是`peek`返回栈顶、`pop`除去栈顶、`conj`推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。\n``` clojure\n(def my_stack [1 2 3 4 5])\n(peek my_stack);=5\n(pop my_stack);=[1 2 3 4]\n(conj my_stack \\s);=[1 2 3 4 5 \\s]\n```\n\n- ### <font color=#0099ff>是Lisp都喜欢的list</font>\n\nlist是单链表结构，即每个节点都有指向下一个节点的指针，且知道距离末端的长度，它同样不可变，添加删除都发生在最左端。\n\n我们可以这样创建list：\n``` clojure\n(list 1 2 3 4 4)\n'(1 2 3 4)\n```\n\n也提供了`conj`和`cons`两种方式添加元素，两者返回的结果有所不同，神奇的是，连参数顺序都不一样！！\n ``` clojure\n;conj返回的结果与它的第一个参数同构，意思是传入seq返回seq，传入list返回list\n;yep!'(1 2)是个list\n(list? (conj '(1 2) 3));=true\n(seq? (conj '(1 2) 3));=true\n;(range 2)是个seq\n(list? (conj (range 2) 3));=false\n(seq? (conj (range 2) 3));=true\n\n;cons则返回seq，不过第二参数传入list还是seq\n(list? (cons 3 '(1 2)));=false\n(seq? (cons 3 '(1 2)));=true\n(list? (cons 3 (range 2)));=false\n(seq? (cons 3 (range 2)));=true\n\n;在对list操作的话，conj无疑是最正确的最为高效的\n ```\n\n对list的取值函数`first`、`next`和`rest`，完全可以把list作为栈使用。\n``` clojure\n(def nil_list nil)\n(def empty_list '())\n(def one_item_list '(1))\n(def num_list '(1 2 3 4 5))\n\n(first nil_list);=nil\n(first empty_list);=nil\n(first num_list);=1\n;若无则返回nil\n(next nil_list);=nil\n(next empty_list);=nil\n(next one_item_list);=nil\n(next num_list);=(2 3 4 5)\n;若无则返回空list\n(rest nil_list);=()\n(rest empty_list);=()\n(rest one_item_list);=()\n(rest num_list);=(2 3 4 5)\n\n;list是可以使用pop和peek的，但由于已经提供了上面三个函数，而且当pop用在empty_list会抛出异常，所以强烈建议用first、next和rest\n```\n<font color=#f28080>强调一点，list不支持索引查找！</font>\n\n- ### <font color=#0099ff>集合！不能有重复元素！</font>\n\nset，即集合，与数学上的集合同样有三种特性-确定性、互异性、无序性，没有薛定谔的元素，也没有重复的元素，也没有先后关系的元素（这还说不定呢）。\n\n怎么创建set？\n``` clojure\n(set [1 2 3 4]);=#{1 4 3 2}\n(set {:a 1 :b 2});=#{[:b 2] [:a 1]}\n(def num_set #{1 4 3 2})\n(def entry_set #{[:b 2] [:a 1]})\n\n(set [1 2 3] '(1 2 3));=#{[1 2 3]}，vector视同为list\n(set [] {} #{} ());=#{[] {} #{}}\n```\n\n查询获取set内元素！\n``` clojure\n;set作为函数\n(#{1 2 3 4} 3);=3\n(get #{:a :b :c} :d);=nil\n\n;contains?查询元素是否存在\n(contains? #{:a :b :c :d} :d);=true\n(contains? #{:a :b :c :d} :e);=false\n\n;顺序集合sorted-set\n(sorted-set :c :d :a :b);=#{:a :b :c :d}\n(sorted-set [1 2] [4 5] [2 3]);=#{[1 2] [2 3] [4 5]}\n;sorted-set在默认情况下，对元素类型有潜在的混淆，比如number与string无法一起排序，添加元素时也容易出现类型混淆\n(sorted-set \"a\" 1 2 \"0\");=ClassCastException java.lang.String cannot be cast to java.lang.Number\n```\n<font size=2 color=#f28080>`contains?`这个函数实际上是查找健值是否存在，这就表明set实际上也是map实现的，而它的键值与值相同。在这补充一点，set与vector都是基于map实现，但`contains?`在vector是无效的，因为它是以索引为键值，故`(contains? [:a :b :c] 2)`才能返回true，按元素值查找始终返回false。</font>\n\n关于set的集合计算没打算讲，见`clojure.set/intersection`、`clojure.set/union`、`clojure.set/difference`的API。\n\n- ### <font color=#0099ff>map！重中之重！</font>\n\nmap可能是clojure被应用最广的数据结构，不管你是否知情，比如用set时实际上用了map。\n\n有几样map，`hash-map`、`array-map`和`sorted-map`，不同的创建方式，返回也会是不同类型的map。\n``` clojure\n;直接用字面量创建map，它是个array-map\n(def a_array_map {:a 1 :b 2 :c 3 :d 4})\n(class a_array_map);=clojure.lang.PersistentArrayMap\n;显示创建array-map\n(array-map :a 1 :b 2);={:a 1, :b 2}\n;用zipmap创建也是个array-map，在clojure 1.2则是个hash-map\n(zipmap [:a :b :c] [1 2 3]);={:a 1, :b 2, :c 3}\n\n;hash-map创建一个HashMap\n(def a_hash_map (hash-map :a 1 :b 2 :c 3 :d 4));={:c 3, :b 2, :d 4, :a 1}\n(class a_hash_map);=clojure.lang.PersistentHashMap\n(apply hash-map [:a 1 :b 2 :c 3 :d 4]);={:c 3, :b 2, :d 4, :a 1}\n```\n\n`hash-map`的键值是无法指定顺序的，`array-map`则是按照插入顺序，只有`sorted-map`的键值能依照默认或我们提供的特定顺序进行排序。不过有一点，因为`sorted-map`键值需要遵循特定顺序，所以对键值的类型也有所限定，不再像其他两个类型的map一样支持异构。\n``` clojure\n(sorted-map :d 1 :a 3 :o 9 :c \"d\");={:a 3, :c \"d\", :d 1, :o 9}\n;键值类型不一致而无法比较，会直接抛出异常\n(sorted-map :d 1 :a 3 :o 9 \"d\" \"d\");=ClassCastException clojure.lang.Keyword cannot be cast to java.lang.String\n;可以自定义比较器来创建sorted-map，即sorted-map-by函数\n(sorted-map-by\n  #(let [[x y]\n         (map (fn [z]\n                (Integer/valueOf (last (.split z \"-\")))) [%1 %2])]\n     (compare x y)) \"tom-12\" :BJ \"jim-24\" :GZ \"anj-6\" :SZ);={\"anj-6\" :SZ, \"tom-12\" :BJ, \"jim-24\" :GZ}\n```\n\n获取map的某个值也是用get，map本身也可以作为函数且接受一个参数，键值(只能为keyword类型)同样可以作为函数且接受一个map。\n``` clojure\n(def person {\n             :name \"Mark Volkmann\"\n             :address {\n                       :street \"644 Glen Summit\"\n                       :city \"St. Charles\"\n                       :state \"Missouri\"\n                       :zip 63304}\n             :employer {\n                        :name \"Object Computing, Inc.\"\n                        :address {\n                                  :street \"12140 Woodcrest Executive Drive, Suite 250\"\n                                  :city \"Creve Coeur\"\n                                  :state \"Missouri\"\n                                  :zip 63141}}})\n\n(get person :name);=\"Mark Volkmann\"\n(get (get person :employer) name);=\"Object Computing, Inc.\"\n\n(person :name);=\"Mark Volkmann\"\n((person :employer) :name);=\"Object Computing, Inc.\"\n\n(:name person);=\"Mark Volkmann\"\n(:name (:employer person));=\"Object Computing, Inc.\"\n;因为键值作为函数，所以可以当作组合函数而使用'->'宏；反之，map作为函数则不行。\n;第一个参数是第二个参数的实参，获取到子map后传递到给后面的键值\n(-> person :employer :name);=\"Object Computing, Inc.\"\n```\n\n给map修改添加键值对的函数与set说到的几个函数一样，`assoc-in`、`update-in`和`assoc`。\n``` clojure\n(assoc-in person [:employer :address :city] \"Clayton\")\n;如果键值不存在，则新添进去\n(assoc-in person [:employer :address :phone] \"13700000000\")\n(update-in person [:employer :address :zip] str \"-1234\")\n\n;需要注意一点，当map的键值是数字类型时，在有序map和hashmap或arraymap上做assoc操作结果是有可能不同的。(在《clojure编程乐趣》有说到)\n(assoc {1 :int} 1.0 :float);={1 :int, 1.0 :float}\n;有序集合中，键值相等则认为是同一个\n(assoc (sorted-map 1 :int) 1.0 :float);={1 :float}\n```\n","source":"_posts/20170123-初学Clojure—集合与数据结构.md","raw":"---\ntitle: 初学Clojure—集合与数据结构\ntags:\n  - clojure\n  - 教程\n  - 并发编程语言\ncategories:\n  - 函数编程\ndate: 2017-01-23 23:51:02\n---\n\n\n这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。\n\n---\n\n- ### <font color=#0099ff>非写入硬盘的数据持久化</font>\n\n这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。\n``` clojure\n;声明list\n(def lst1 (list 1 2 3 4))\n;添加新元素，它重新生产一个“新列表”\n(def lst2 (conj lst 5));=(5 1 2 3 4)\n;lst引用依旧指向(1 2 3 4)\nlst1 ;=(1 2 3 4)\n```\n为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。\n\n其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对`lst1`做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于`lst2`这个版本中，`(1 2 3 4)`则`lst1`与`lst2`共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。\n\n- ### <font color=#0099ff>它叫做向量，不叫数组</font>\n\n在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是`[]`。\n\n如何创建向量呢？\n``` clojure\n;我们可以这样创建一个vector，直接使用字面量\n(def vec1 [1 2 3 4 5])\n;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维\n(def vec2 (vec (range 5)))\n;显然，是往一个vector塞另外一个集合\n(def vec3 (into vec1 (range 6 10)))\n```\n\n可以限制vector为基础数据类型的集合，只要使用`vector-of`函数即可，支持`:int`、`:long`、`:float`、`:double`、`:byte`、`:short`、`:boolean`、`:char`这些基础类型。\n``` clojure\n(into (vector-of :int) [Math/PI 2 1.4]);=[3 2 1]\n(into (vector-of :char) [100 102 104]);=[\\d \\f \\h]\n(into (vector-of :boolean) [false true 1 nil]);=[false true true false]\n(into (vector-of :long) [\"string\" \"number\" 10000])\n;=ClassCastException java.lang.String cannot be cast to java.lang.Number\n```\n\n有索引，自然可以用下标获取元素，有`nth`、`get`、向量自身作为函数三种方式，每种都有那么一点不同。\n``` clojure\n(def nil_vec nil)\n(def empty_vec [])\n(def char_vec [\\a \\b \\c \\d \\f])\n\n(nth nil_vec 3);=nil\n(nth empty_vec 3);=IndexOutOfBoundsException\n(nth char_vec 3);=\\d\n;支持not find参数，找不到元素则返回该实参\n(nth char_vec 100 :no!);=:no!\n\n(get nil_vec 3);=nil\n(get empty_vec 3);=nil\n(get char_vec 3);=\\d\n;同上\n(get char_vec 100 :no!);=:no!\n\n;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素\n(nil_vec 3);=NullPointerException\n(empty_vec 3);=IndexOutOfBoundsException\n(char_vec 3);=\\d\n;然而，它并不支持上面两种方式支持的not find参数\n```\n<font size=2 color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font>\n\n那么来看看怎么修改元素。\n``` clojure\n(def num_vec [1 2 3 4 5])\n;直接修改对于下标的元素\n(assoc num_vec 2 \"string\");=[1 2 \"string\" 4 5]\n;这个则是使用一个函数去改变对应下标的元素\n(update num_vec 2 * 100);=[1 2 300 4 5]\n\n;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素\n(def num_vec2 [[1 2 3] [4 5 6] [7 8 9]])\n(get-in num_vec2 [1 2]);=6\n(get-in num_vec2 [1 6]);=nil\n;支持not find参数\n(get-in num_vec2 [1 6] :no!);=:no!\n(assoc-in num_vec2 [1 2] \\s);=[[1 2 3] [4 5 \\s] [7 8 9]]\n;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException\n(assoc-in num_vec2 [1 3] \\s);=[[1 2 3] [4 5 6 \\s] [7 8 9]]\n(update-in num_vec2 [1 2] * 100);=[[1 2 3] [4 5 600] [7 8 9]]\n(update-in num_vec2 [1 3] * 100);=NullPointerException\n```\n\nvector提供了三个函数，使其支持栈操作，分别是`peek`返回栈顶、`pop`除去栈顶、`conj`推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。\n``` clojure\n(def my_stack [1 2 3 4 5])\n(peek my_stack);=5\n(pop my_stack);=[1 2 3 4]\n(conj my_stack \\s);=[1 2 3 4 5 \\s]\n```\n\n- ### <font color=#0099ff>是Lisp都喜欢的list</font>\n\nlist是单链表结构，即每个节点都有指向下一个节点的指针，且知道距离末端的长度，它同样不可变，添加删除都发生在最左端。\n\n我们可以这样创建list：\n``` clojure\n(list 1 2 3 4 4)\n'(1 2 3 4)\n```\n\n也提供了`conj`和`cons`两种方式添加元素，两者返回的结果有所不同，神奇的是，连参数顺序都不一样！！\n ``` clojure\n;conj返回的结果与它的第一个参数同构，意思是传入seq返回seq，传入list返回list\n;yep!'(1 2)是个list\n(list? (conj '(1 2) 3));=true\n(seq? (conj '(1 2) 3));=true\n;(range 2)是个seq\n(list? (conj (range 2) 3));=false\n(seq? (conj (range 2) 3));=true\n\n;cons则返回seq，不过第二参数传入list还是seq\n(list? (cons 3 '(1 2)));=false\n(seq? (cons 3 '(1 2)));=true\n(list? (cons 3 (range 2)));=false\n(seq? (cons 3 (range 2)));=true\n\n;在对list操作的话，conj无疑是最正确的最为高效的\n ```\n\n对list的取值函数`first`、`next`和`rest`，完全可以把list作为栈使用。\n``` clojure\n(def nil_list nil)\n(def empty_list '())\n(def one_item_list '(1))\n(def num_list '(1 2 3 4 5))\n\n(first nil_list);=nil\n(first empty_list);=nil\n(first num_list);=1\n;若无则返回nil\n(next nil_list);=nil\n(next empty_list);=nil\n(next one_item_list);=nil\n(next num_list);=(2 3 4 5)\n;若无则返回空list\n(rest nil_list);=()\n(rest empty_list);=()\n(rest one_item_list);=()\n(rest num_list);=(2 3 4 5)\n\n;list是可以使用pop和peek的，但由于已经提供了上面三个函数，而且当pop用在empty_list会抛出异常，所以强烈建议用first、next和rest\n```\n<font color=#f28080>强调一点，list不支持索引查找！</font>\n\n- ### <font color=#0099ff>集合！不能有重复元素！</font>\n\nset，即集合，与数学上的集合同样有三种特性-确定性、互异性、无序性，没有薛定谔的元素，也没有重复的元素，也没有先后关系的元素（这还说不定呢）。\n\n怎么创建set？\n``` clojure\n(set [1 2 3 4]);=#{1 4 3 2}\n(set {:a 1 :b 2});=#{[:b 2] [:a 1]}\n(def num_set #{1 4 3 2})\n(def entry_set #{[:b 2] [:a 1]})\n\n(set [1 2 3] '(1 2 3));=#{[1 2 3]}，vector视同为list\n(set [] {} #{} ());=#{[] {} #{}}\n```\n\n查询获取set内元素！\n``` clojure\n;set作为函数\n(#{1 2 3 4} 3);=3\n(get #{:a :b :c} :d);=nil\n\n;contains?查询元素是否存在\n(contains? #{:a :b :c :d} :d);=true\n(contains? #{:a :b :c :d} :e);=false\n\n;顺序集合sorted-set\n(sorted-set :c :d :a :b);=#{:a :b :c :d}\n(sorted-set [1 2] [4 5] [2 3]);=#{[1 2] [2 3] [4 5]}\n;sorted-set在默认情况下，对元素类型有潜在的混淆，比如number与string无法一起排序，添加元素时也容易出现类型混淆\n(sorted-set \"a\" 1 2 \"0\");=ClassCastException java.lang.String cannot be cast to java.lang.Number\n```\n<font size=2 color=#f28080>`contains?`这个函数实际上是查找健值是否存在，这就表明set实际上也是map实现的，而它的键值与值相同。在这补充一点，set与vector都是基于map实现，但`contains?`在vector是无效的，因为它是以索引为键值，故`(contains? [:a :b :c] 2)`才能返回true，按元素值查找始终返回false。</font>\n\n关于set的集合计算没打算讲，见`clojure.set/intersection`、`clojure.set/union`、`clojure.set/difference`的API。\n\n- ### <font color=#0099ff>map！重中之重！</font>\n\nmap可能是clojure被应用最广的数据结构，不管你是否知情，比如用set时实际上用了map。\n\n有几样map，`hash-map`、`array-map`和`sorted-map`，不同的创建方式，返回也会是不同类型的map。\n``` clojure\n;直接用字面量创建map，它是个array-map\n(def a_array_map {:a 1 :b 2 :c 3 :d 4})\n(class a_array_map);=clojure.lang.PersistentArrayMap\n;显示创建array-map\n(array-map :a 1 :b 2);={:a 1, :b 2}\n;用zipmap创建也是个array-map，在clojure 1.2则是个hash-map\n(zipmap [:a :b :c] [1 2 3]);={:a 1, :b 2, :c 3}\n\n;hash-map创建一个HashMap\n(def a_hash_map (hash-map :a 1 :b 2 :c 3 :d 4));={:c 3, :b 2, :d 4, :a 1}\n(class a_hash_map);=clojure.lang.PersistentHashMap\n(apply hash-map [:a 1 :b 2 :c 3 :d 4]);={:c 3, :b 2, :d 4, :a 1}\n```\n\n`hash-map`的键值是无法指定顺序的，`array-map`则是按照插入顺序，只有`sorted-map`的键值能依照默认或我们提供的特定顺序进行排序。不过有一点，因为`sorted-map`键值需要遵循特定顺序，所以对键值的类型也有所限定，不再像其他两个类型的map一样支持异构。\n``` clojure\n(sorted-map :d 1 :a 3 :o 9 :c \"d\");={:a 3, :c \"d\", :d 1, :o 9}\n;键值类型不一致而无法比较，会直接抛出异常\n(sorted-map :d 1 :a 3 :o 9 \"d\" \"d\");=ClassCastException clojure.lang.Keyword cannot be cast to java.lang.String\n;可以自定义比较器来创建sorted-map，即sorted-map-by函数\n(sorted-map-by\n  #(let [[x y]\n         (map (fn [z]\n                (Integer/valueOf (last (.split z \"-\")))) [%1 %2])]\n     (compare x y)) \"tom-12\" :BJ \"jim-24\" :GZ \"anj-6\" :SZ);={\"anj-6\" :SZ, \"tom-12\" :BJ, \"jim-24\" :GZ}\n```\n\n获取map的某个值也是用get，map本身也可以作为函数且接受一个参数，键值(只能为keyword类型)同样可以作为函数且接受一个map。\n``` clojure\n(def person {\n             :name \"Mark Volkmann\"\n             :address {\n                       :street \"644 Glen Summit\"\n                       :city \"St. Charles\"\n                       :state \"Missouri\"\n                       :zip 63304}\n             :employer {\n                        :name \"Object Computing, Inc.\"\n                        :address {\n                                  :street \"12140 Woodcrest Executive Drive, Suite 250\"\n                                  :city \"Creve Coeur\"\n                                  :state \"Missouri\"\n                                  :zip 63141}}})\n\n(get person :name);=\"Mark Volkmann\"\n(get (get person :employer) name);=\"Object Computing, Inc.\"\n\n(person :name);=\"Mark Volkmann\"\n((person :employer) :name);=\"Object Computing, Inc.\"\n\n(:name person);=\"Mark Volkmann\"\n(:name (:employer person));=\"Object Computing, Inc.\"\n;因为键值作为函数，所以可以当作组合函数而使用'->'宏；反之，map作为函数则不行。\n;第一个参数是第二个参数的实参，获取到子map后传递到给后面的键值\n(-> person :employer :name);=\"Object Computing, Inc.\"\n```\n\n给map修改添加键值对的函数与set说到的几个函数一样，`assoc-in`、`update-in`和`assoc`。\n``` clojure\n(assoc-in person [:employer :address :city] \"Clayton\")\n;如果键值不存在，则新添进去\n(assoc-in person [:employer :address :phone] \"13700000000\")\n(update-in person [:employer :address :zip] str \"-1234\")\n\n;需要注意一点，当map的键值是数字类型时，在有序map和hashmap或arraymap上做assoc操作结果是有可能不同的。(在《clojure编程乐趣》有说到)\n(assoc {1 :int} 1.0 :float);={1 :int, 1.0 :float}\n;有序集合中，键值相等则认为是同一个\n(assoc (sorted-map 1 :int) 1.0 :float);={1 :float}\n```\n","slug":"20170123-初学Clojure—集合与数据结构","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sr00294ejd43inc7i3","content":"<p>这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。</p>\n<hr>\n<ul>\n<li><h3 id=\"非写入硬盘的数据持久化\"><a href=\"#非写入硬盘的数据持久化\" class=\"headerlink\" title=\"非写入硬盘的数据持久化\"></a><font color=#0099ff>非写入硬盘的数据持久化</font></h3></li>\n</ul>\n<p>这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;声明list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst1 (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"comment\">;添加新元素，它重新生产一个“新列表”</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst2 (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> lst <span class=\"number\">5</span>))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br><span class=\"line\"><span class=\"comment\">;lst引用依旧指向(1 2 3 4)</span></span><br><span class=\"line\">lst1 ;=(1 2 3 4)</span><br></pre></td></tr></table></figure>\n<p>为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。</p>\n<p>其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对<code>lst1</code>做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于<code>lst2</code>这个版本中，<code>(1 2 3 4)</code>则<code>lst1</code>与<code>lst2</code>共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。</p>\n<ul>\n<li><h3 id=\"它叫做向量，不叫数组\"><a href=\"#它叫做向量，不叫数组\" class=\"headerlink\" title=\"它叫做向量，不叫数组\"></a><font color=#0099ff>它叫做向量，不叫数组</font></h3></li>\n</ul>\n<p>在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是<code>[]</code>。</p>\n<p>如何创建向量呢？</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;我们可以这样创建一个vector，直接使用字面量</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec1 [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec2 (<span class=\"name\"><span class=\"builtin-name\">vec</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">5</span>)))</span><br><span class=\"line\"><span class=\"comment\">;显然，是往一个vector塞另外一个集合</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec3 (<span class=\"name\"><span class=\"builtin-name\">into</span></span> vec1 (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">6</span> <span class=\"number\">10</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>可以限制vector为基础数据类型的集合，只要使用<code>vector-of</code>函数即可，支持<code>:int</code>、<code>:long</code>、<code>:float</code>、<code>:double</code>、<code>:byte</code>、<code>:short</code>、<code>:boolean</code>、<code>:char</code>这些基础类型。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:int</span>) [Math/PI <span class=\"number\">2</span> <span class=\"number\">1.4</span>])<span class=\"comment\">;=[3 2 1]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:char</span>) [<span class=\"number\">100</span> <span class=\"number\">102</span> <span class=\"number\">104</span>])<span class=\"comment\">;=[\\d \\f \\h]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:boolean</span>) [<span class=\"literal\">false</span> <span class=\"literal\">true</span> <span class=\"number\">1</span> <span class=\"literal\">nil</span>])<span class=\"comment\">;=[false true true false]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:long</span>) [<span class=\"string\">\"string\"</span> <span class=\"string\">\"number\"</span> <span class=\"number\">10000</span>])</span><br><span class=\"line\"><span class=\"comment\">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure>\n\n<p>有索引，自然可以用下标获取元素，有<code>nth</code>、<code>get</code>、向量自身作为函数三种方式，每种都有那么一点不同。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> nil_vec <span class=\"literal\">nil</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> empty_vec [])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> char_vec [\\a \\b \\c \\d \\f])</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> nil_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> empty_vec <span class=\"number\">3</span>)<span class=\"comment\">;=IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> char_vec <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;支持not find参数，找不到元素则返回该实参</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> char_vec <span class=\"number\">100</span> <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> nil_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> empty_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> char_vec <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;同上</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> char_vec <span class=\"number\">100</span> <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素</span></span><br><span class=\"line\">(<span class=\"name\">nil_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=NullPointerException</span></span><br><span class=\"line\">(<span class=\"name\">empty_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\">char_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;然而，它并不支持上面两种方式支持的not find参数</span></span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font></p>\n<p>那么来看看怎么修改元素。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_vec [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">;直接修改对于下标的元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> num_vec <span class=\"number\">2</span> <span class=\"string\">\"string\"</span>)<span class=\"comment\">;=[1 2 \"string\" 4 5]</span></span><br><span class=\"line\"><span class=\"comment\">;这个则是使用一个函数去改变对应下标的元素</span></span><br><span class=\"line\">(<span class=\"name\">update</span> num_vec <span class=\"number\">2</span> * <span class=\"number\">100</span>)<span class=\"comment\">;=[1 2 300 4 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_vec2 [[<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>] [<span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>] [<span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>]])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>])<span class=\"comment\">;=6</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">6</span>])<span class=\"comment\">;=nil</span></span><br><span class=\"line\"><span class=\"comment\">;支持not find参数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">6</span>] <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>] \\s)<span class=\"comment\">;=[[1 2 3] [4 5 \\s] [7 8 9]]</span></span><br><span class=\"line\"><span class=\"comment\">;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">3</span>] \\s)<span class=\"comment\">;=[[1 2 3] [4 5 6 \\s] [7 8 9]]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>] * <span class=\"number\">100</span>)<span class=\"comment\">;=[[1 2 3] [4 5 600] [7 8 9]]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">3</span>] * <span class=\"number\">100</span>)<span class=\"comment\">;=NullPointerException</span></span><br></pre></td></tr></table></figure>\n\n<p>vector提供了三个函数，使其支持栈操作，分别是<code>peek</code>返回栈顶、<code>pop</code>除去栈顶、<code>conj</code>推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_stack [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">peek</span></span> my_stack)<span class=\"comment\">;=5</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">pop</span></span> my_stack)<span class=\"comment\">;=[1 2 3 4]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">conj</span></span> my_stack \\s)<span class=\"comment\">;=[1 2 3 4 5 \\s]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"是Lisp都喜欢的list\"><a href=\"#是Lisp都喜欢的list\" class=\"headerlink\" title=\"是Lisp都喜欢的list\"></a><font color=#0099ff>是Lisp都喜欢的list</font></h3></li>\n</ul>\n<p>list是单链表结构，即每个节点都有指向下一个节点的指针，且知道距离末端的长度，它同样不可变，添加删除都发生在最左端。</p>\n<p>我们可以这样创建list：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">'(1 2 3 4)</span><br></pre></td></tr></table></figure>\n\n<p>也提供了<code>conj</code>和<code>cons</code>两种方式添加元素，两者返回的结果有所不同，神奇的是，连参数顺序都不一样！！<br> <figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;conj返回的结果与它的第一个参数同构，意思是传入seq返回seq，传入list返回list</span></span><br><span class=\"line\"><span class=\"comment\">;yep!'(1 2)是个list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;(range 2)是个seq</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;cons则返回seq，不过第二参数传入list还是seq</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>)))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>)))<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>)))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>)))<span class=\"comment\">;=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;在对list操作的话，conj无疑是最正确的最为高效的</span></span><br></pre></td></tr></table></figure></p>\n<p>对list的取值函数<code>first</code>、<code>next</code>和<code>rest</code>，完全可以把list作为栈使用。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> nil_list <span class=\"literal\">nil</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> empty_list '())</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> one_item_list '(<span class=\"number\">1</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_list '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> nil_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> empty_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> num_list)<span class=\"comment\">;=1</span></span><br><span class=\"line\"><span class=\"comment\">;若无则返回nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> nil_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> empty_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> one_item_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> num_list)<span class=\"comment\">;=(2 3 4 5)</span></span><br><span class=\"line\"><span class=\"comment\">;若无则返回空list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> nil_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> empty_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> one_item_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> num_list)<span class=\"comment\">;=(2 3 4 5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;list是可以使用pop和peek的，但由于已经提供了上面三个函数，而且当pop用在empty_list会抛出异常，所以强烈建议用first、next和rest</span></span><br></pre></td></tr></table></figure>\n<p><font color=#f28080>强调一点，list不支持索引查找！</font></p>\n<ul>\n<li><h3 id=\"集合！不能有重复元素！\"><a href=\"#集合！不能有重复元素！\" class=\"headerlink\" title=\"集合！不能有重复元素！\"></a><font color=#0099ff>集合！不能有重复元素！</font></h3></li>\n</ul>\n<p>set，即集合，与数学上的集合同样有三种特性-确定性、互异性、无序性，没有薛定谔的元素，也没有重复的元素，也没有先后关系的元素（这还说不定呢）。</p>\n<p>怎么创建set？</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">set</span> [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>])<span class=\"comment\">;=#&#123;1 4 3 2&#125;</span></span><br><span class=\"line\">(<span class=\"name\">set</span> &#123;<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span>&#125;)<span class=\"comment\">;=#&#123;[:b 2] [:a 1]&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_set #&#123;<span class=\"number\">1</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> entry_set #&#123;[<span class=\"symbol\">:b</span> <span class=\"number\">2</span>] [<span class=\"symbol\">:a</span> <span class=\"number\">1</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">set</span> [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))<span class=\"comment\">;=#&#123;[1 2 3]&#125;，vector视同为list</span></span><br><span class=\"line\">(<span class=\"name\">set</span> [] &#123;&#125; #&#123;&#125; ())<span class=\"comment\">;=#&#123;[] &#123;&#125; #&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>查询获取set内元素！</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;set作为函数</span></span><br><span class=\"line\">(<span class=\"name\">#</span>&#123;<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>&#125; <span class=\"number\">3</span>)<span class=\"comment\">;=3</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>&#125; <span class=\"symbol\">:d</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;contains?查询元素是否存在</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">contains?</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span>&#125; <span class=\"symbol\">:d</span>)<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">contains?</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span>&#125; <span class=\"symbol\">:e</span>)<span class=\"comment\">;=false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;顺序集合sorted-set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span> <span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span>)<span class=\"comment\">;=#&#123;:a :b :c :d&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> [<span class=\"number\">1</span> <span class=\"number\">2</span>] [<span class=\"number\">4</span> <span class=\"number\">5</span>] [<span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=#&#123;[1 2] [2 3] [4 5]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;sorted-set在默认情况下，对元素类型有潜在的混淆，比如number与string无法一起排序，添加元素时也容易出现类型混淆</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> <span class=\"string\">\"a\"</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"string\">\"0\"</span>)<span class=\"comment\">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080><code>contains?</code>这个函数实际上是查找健值是否存在，这就表明set实际上也是map实现的，而它的键值与值相同。在这补充一点，set与vector都是基于map实现，但<code>contains?</code>在vector是无效的，因为它是以索引为键值，故<code>(contains? [:a :b :c] 2)</code>才能返回true，按元素值查找始终返回false。</font></p>\n<p>关于set的集合计算没打算讲，见<code>clojure.set/intersection</code>、<code>clojure.set/union</code>、<code>clojure.set/difference</code>的API。</p>\n<ul>\n<li><h3 id=\"map！重中之重！\"><a href=\"#map！重中之重！\" class=\"headerlink\" title=\"map！重中之重！\"></a><font color=#0099ff>map！重中之重！</font></h3></li>\n</ul>\n<p>map可能是clojure被应用最广的数据结构，不管你是否知情，比如用set时实际上用了map。</p>\n<p>有几样map，<code>hash-map</code>、<code>array-map</code>和<code>sorted-map</code>，不同的创建方式，返回也会是不同类型的map。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;直接用字面量创建map，它是个array-map</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_array_map &#123;<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a_array_map)<span class=\"comment\">;=clojure.lang.PersistentArrayMap</span></span><br><span class=\"line\"><span class=\"comment\">;显示创建array-map</span></span><br><span class=\"line\">(<span class=\"name\">array-map</span> <span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span>)<span class=\"comment\">;=&#123;:a 1, :b 2&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;用zipmap创建也是个array-map，在clojure 1.2则是个hash-map</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">zipmap</span></span> [<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>] [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=&#123;:a 1, :b 2, :c 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;hash-map创建一个HashMap</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_hash_map (<span class=\"name\"><span class=\"builtin-name\">hash-map</span></span> <span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>))<span class=\"comment\">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a_hash_map)<span class=\"comment\">;=clojure.lang.PersistentHashMap</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> hash-map [<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>])<span class=\"comment\">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>hash-map</code>的键值是无法指定顺序的，<code>array-map</code>则是按照插入顺序，只有<code>sorted-map</code>的键值能依照默认或我们提供的特定顺序进行排序。不过有一点，因为<code>sorted-map</code>键值需要遵循特定顺序，所以对键值的类型也有所限定，不再像其他两个类型的map一样支持异构。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"symbol\">:d</span> <span class=\"number\">1</span> <span class=\"symbol\">:a</span> <span class=\"number\">3</span> <span class=\"symbol\">:o</span> <span class=\"number\">9</span> <span class=\"symbol\">:c</span> <span class=\"string\">\"d\"</span>)<span class=\"comment\">;=&#123;:a 3, :c \"d\", :d 1, :o 9&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;键值类型不一致而无法比较，会直接抛出异常</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"symbol\">:d</span> <span class=\"number\">1</span> <span class=\"symbol\">:a</span> <span class=\"number\">3</span> <span class=\"symbol\">:o</span> <span class=\"number\">9</span> <span class=\"string\">\"d\"</span> <span class=\"string\">\"d\"</span>)<span class=\"comment\">;=ClassCastException clojure.lang.Keyword cannot be cast to java.lang.String</span></span><br><span class=\"line\"><span class=\"comment\">;可以自定义比较器来创建sorted-map，即sorted-map-by函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map-by</span></span></span><br><span class=\"line\">  #(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y]</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">map</span></span> (<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [z]</span><br><span class=\"line\">                (<span class=\"name\">Integer/valueOf</span> (<span class=\"name\"><span class=\"builtin-name\">last</span></span> (<span class=\"name\">.split</span> z <span class=\"string\">\"-\"</span>)))) [%<span class=\"number\">1</span> %<span class=\"number\">2</span>])]</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">compare</span></span> x y)) <span class=\"string\">\"tom-12\"</span> <span class=\"symbol\">:BJ</span> <span class=\"string\">\"jim-24\"</span> <span class=\"symbol\">:GZ</span> <span class=\"string\">\"anj-6\"</span> <span class=\"symbol\">:SZ</span>)<span class=\"comment\">;=&#123;\"anj-6\" :SZ, \"tom-12\" :BJ, \"jim-24\" :GZ&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>获取map的某个值也是用get，map本身也可以作为函数且接受一个参数，键值(只能为keyword类型)同样可以作为函数且接受一个map。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> person &#123;</span><br><span class=\"line\">             <span class=\"symbol\">:name</span> <span class=\"string\">\"Mark Volkmann\"</span></span><br><span class=\"line\">             <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                       <span class=\"symbol\">:street</span> <span class=\"string\">\"644 Glen Summit\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:city</span> <span class=\"string\">\"St. Charles\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:zip</span> <span class=\"number\">63304</span>&#125;</span><br><span class=\"line\">             <span class=\"symbol\">:employer</span> &#123;</span><br><span class=\"line\">                        <span class=\"symbol\">:name</span> <span class=\"string\">\"Object Computing, Inc.\"</span></span><br><span class=\"line\">                        <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                                  <span class=\"symbol\">:street</span> <span class=\"string\">\"12140 Woodcrest Executive Drive, Suite 250\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:city</span> <span class=\"string\">\"Creve Coeur\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:zip</span> <span class=\"number\">63141</span>&#125;&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> person <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> (<span class=\"name\"><span class=\"builtin-name\">get</span></span> person <span class=\"symbol\">:employer</span>) name)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">person</span> <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">((<span class=\"name\">person</span> <span class=\"symbol\">:employer</span>) <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"symbol\">:name</span> person)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">(<span class=\"symbol\">:name</span> (<span class=\"symbol\">:employer</span> person))<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"><span class=\"comment\">;因为键值作为函数，所以可以当作组合函数而使用'-&gt;'宏；反之，map作为函数则不行。</span></span><br><span class=\"line\"><span class=\"comment\">;第一个参数是第二个参数的实参，获取到子map后传递到给后面的键值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">-&gt;</span></span> person <span class=\"symbol\">:employer</span> <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br></pre></td></tr></table></figure>\n\n<p>给map修改添加键值对的函数与set说到的几个函数一样，<code>assoc-in</code>、<code>update-in</code>和<code>assoc</code>。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">assoc-in</span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:city</span>] <span class=\"string\">\"Clayton\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;如果键值不存在，则新添进去</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:phone</span>] <span class=\"string\">\"13700000000\"</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:zip</span>] str <span class=\"string\">\"-1234\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;需要注意一点，当map的键值是数字类型时，在有序map和hashmap或arraymap上做assoc操作结果是有可能不同的。(在《clojure编程乐趣》有说到)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> &#123;<span class=\"number\">1</span> <span class=\"symbol\">:int</span>&#125; <span class=\"number\">1.0</span> <span class=\"symbol\">:float</span>)<span class=\"comment\">;=&#123;1 :int, 1.0 :float&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;有序集合中，键值相等则认为是同一个</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> (<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"number\">1</span> <span class=\"symbol\">:int</span>) <span class=\"number\">1.0</span> <span class=\"symbol\">:float</span>)<span class=\"comment\">;=&#123;1 :float&#125;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。</p>\n<hr>\n<ul>\n<li><h3 id=\"非写入硬盘的数据持久化\"><a href=\"#非写入硬盘的数据持久化\" class=\"headerlink\" title=\"非写入硬盘的数据持久化\"></a><font color=#0099ff>非写入硬盘的数据持久化</font></h3></li>\n</ul>\n<p>这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;声明list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst1 (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"comment\">;添加新元素，它重新生产一个“新列表”</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst2 (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> lst <span class=\"number\">5</span>))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br><span class=\"line\"><span class=\"comment\">;lst引用依旧指向(1 2 3 4)</span></span><br><span class=\"line\">lst1 ;=(1 2 3 4)</span><br></pre></td></tr></table></figure>\n<p>为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。</p>\n<p>其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对<code>lst1</code>做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于<code>lst2</code>这个版本中，<code>(1 2 3 4)</code>则<code>lst1</code>与<code>lst2</code>共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。</p>\n<ul>\n<li><h3 id=\"它叫做向量，不叫数组\"><a href=\"#它叫做向量，不叫数组\" class=\"headerlink\" title=\"它叫做向量，不叫数组\"></a><font color=#0099ff>它叫做向量，不叫数组</font></h3></li>\n</ul>\n<p>在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是<code>[]</code>。</p>\n<p>如何创建向量呢？</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;我们可以这样创建一个vector，直接使用字面量</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec1 [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec2 (<span class=\"name\"><span class=\"builtin-name\">vec</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">5</span>)))</span><br><span class=\"line\"><span class=\"comment\">;显然，是往一个vector塞另外一个集合</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> vec3 (<span class=\"name\"><span class=\"builtin-name\">into</span></span> vec1 (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">6</span> <span class=\"number\">10</span>)))</span><br></pre></td></tr></table></figure>\n\n<p>可以限制vector为基础数据类型的集合，只要使用<code>vector-of</code>函数即可，支持<code>:int</code>、<code>:long</code>、<code>:float</code>、<code>:double</code>、<code>:byte</code>、<code>:short</code>、<code>:boolean</code>、<code>:char</code>这些基础类型。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:int</span>) [Math/PI <span class=\"number\">2</span> <span class=\"number\">1.4</span>])<span class=\"comment\">;=[3 2 1]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:char</span>) [<span class=\"number\">100</span> <span class=\"number\">102</span> <span class=\"number\">104</span>])<span class=\"comment\">;=[\\d \\f \\h]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:boolean</span>) [<span class=\"literal\">false</span> <span class=\"literal\">true</span> <span class=\"number\">1</span> <span class=\"literal\">nil</span>])<span class=\"comment\">;=[false true true false]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">into</span></span> (<span class=\"name\">vector-of</span> <span class=\"symbol\">:long</span>) [<span class=\"string\">\"string\"</span> <span class=\"string\">\"number\"</span> <span class=\"number\">10000</span>])</span><br><span class=\"line\"><span class=\"comment\">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure>\n\n<p>有索引，自然可以用下标获取元素，有<code>nth</code>、<code>get</code>、向量自身作为函数三种方式，每种都有那么一点不同。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> nil_vec <span class=\"literal\">nil</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> empty_vec [])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> char_vec [\\a \\b \\c \\d \\f])</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> nil_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> empty_vec <span class=\"number\">3</span>)<span class=\"comment\">;=IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> char_vec <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;支持not find参数，找不到元素则返回该实参</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">nth</span></span> char_vec <span class=\"number\">100</span> <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> nil_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> empty_vec <span class=\"number\">3</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> char_vec <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;同上</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> char_vec <span class=\"number\">100</span> <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素</span></span><br><span class=\"line\">(<span class=\"name\">nil_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=NullPointerException</span></span><br><span class=\"line\">(<span class=\"name\">empty_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\">char_vec</span> <span class=\"number\">3</span>)<span class=\"comment\">;=\\d</span></span><br><span class=\"line\"><span class=\"comment\">;然而，它并不支持上面两种方式支持的not find参数</span></span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font></p>\n<p>那么来看看怎么修改元素。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_vec [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">;直接修改对于下标的元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> num_vec <span class=\"number\">2</span> <span class=\"string\">\"string\"</span>)<span class=\"comment\">;=[1 2 \"string\" 4 5]</span></span><br><span class=\"line\"><span class=\"comment\">;这个则是使用一个函数去改变对应下标的元素</span></span><br><span class=\"line\">(<span class=\"name\">update</span> num_vec <span class=\"number\">2</span> * <span class=\"number\">100</span>)<span class=\"comment\">;=[1 2 300 4 5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_vec2 [[<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>] [<span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>] [<span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>]])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>])<span class=\"comment\">;=6</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">6</span>])<span class=\"comment\">;=nil</span></span><br><span class=\"line\"><span class=\"comment\">;支持not find参数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">6</span>] <span class=\"symbol\">:no!</span>)<span class=\"comment\">;=:no!</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>] \\s)<span class=\"comment\">;=[[1 2 3] [4 5 \\s] [7 8 9]]</span></span><br><span class=\"line\"><span class=\"comment\">;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">3</span>] \\s)<span class=\"comment\">;=[[1 2 3] [4 5 6 \\s] [7 8 9]]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">2</span>] * <span class=\"number\">100</span>)<span class=\"comment\">;=[[1 2 3] [4 5 600] [7 8 9]]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> num_vec2 [<span class=\"number\">1</span> <span class=\"number\">3</span>] * <span class=\"number\">100</span>)<span class=\"comment\">;=NullPointerException</span></span><br></pre></td></tr></table></figure>\n\n<p>vector提供了三个函数，使其支持栈操作，分别是<code>peek</code>返回栈顶、<code>pop</code>除去栈顶、<code>conj</code>推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> my_stack [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>])</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">peek</span></span> my_stack)<span class=\"comment\">;=5</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">pop</span></span> my_stack)<span class=\"comment\">;=[1 2 3 4]</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">conj</span></span> my_stack \\s)<span class=\"comment\">;=[1 2 3 4 5 \\s]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><h3 id=\"是Lisp都喜欢的list\"><a href=\"#是Lisp都喜欢的list\" class=\"headerlink\" title=\"是Lisp都喜欢的list\"></a><font color=#0099ff>是Lisp都喜欢的list</font></h3></li>\n</ul>\n<p>list是单链表结构，即每个节点都有指向下一个节点的指针，且知道距离末端的长度，它同样不可变，添加删除都发生在最左端。</p>\n<p>我们可以这样创建list：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">4</span>)</span><br><span class=\"line\">'(1 2 3 4)</span><br></pre></td></tr></table></figure>\n\n<p>也提供了<code>conj</code>和<code>cons</code>两种方式添加元素，两者返回的结果有所不同，神奇的是，连参数顺序都不一样！！<br> <figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;conj返回的结果与它的第一个参数同构，意思是传入seq返回seq，传入list返回list</span></span><br><span class=\"line\"><span class=\"comment\">;yep!'(1 2)是个list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;(range 2)是个seq</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>) <span class=\"number\">3</span>))<span class=\"comment\">;=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;cons则返回seq，不过第二参数传入list还是seq</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>)))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> '(<span class=\"number\">1</span> <span class=\"number\">2</span>)))<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">list?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>)))<span class=\"comment\">;=false</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">seq?</span></span> (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"number\">3</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">2</span>)))<span class=\"comment\">;=true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;在对list操作的话，conj无疑是最正确的最为高效的</span></span><br></pre></td></tr></table></figure></p>\n<p>对list的取值函数<code>first</code>、<code>next</code>和<code>rest</code>，完全可以把list作为栈使用。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> nil_list <span class=\"literal\">nil</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> empty_list '())</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> one_item_list '(<span class=\"number\">1</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_list '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> nil_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> empty_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">first</span></span> num_list)<span class=\"comment\">;=1</span></span><br><span class=\"line\"><span class=\"comment\">;若无则返回nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> nil_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> empty_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> one_item_list)<span class=\"comment\">;=nil</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">next</span></span> num_list)<span class=\"comment\">;=(2 3 4 5)</span></span><br><span class=\"line\"><span class=\"comment\">;若无则返回空list</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> nil_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> empty_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> one_item_list)<span class=\"comment\">;=()</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">rest</span></span> num_list)<span class=\"comment\">;=(2 3 4 5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;list是可以使用pop和peek的，但由于已经提供了上面三个函数，而且当pop用在empty_list会抛出异常，所以强烈建议用first、next和rest</span></span><br></pre></td></tr></table></figure>\n<p><font color=#f28080>强调一点，list不支持索引查找！</font></p>\n<ul>\n<li><h3 id=\"集合！不能有重复元素！\"><a href=\"#集合！不能有重复元素！\" class=\"headerlink\" title=\"集合！不能有重复元素！\"></a><font color=#0099ff>集合！不能有重复元素！</font></h3></li>\n</ul>\n<p>set，即集合，与数学上的集合同样有三种特性-确定性、互异性、无序性，没有薛定谔的元素，也没有重复的元素，也没有先后关系的元素（这还说不定呢）。</p>\n<p>怎么创建set？</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">set</span> [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>])<span class=\"comment\">;=#&#123;1 4 3 2&#125;</span></span><br><span class=\"line\">(<span class=\"name\">set</span> &#123;<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span>&#125;)<span class=\"comment\">;=#&#123;[:b 2] [:a 1]&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> num_set #&#123;<span class=\"number\">1</span> <span class=\"number\">4</span> <span class=\"number\">3</span> <span class=\"number\">2</span>&#125;)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> entry_set #&#123;[<span class=\"symbol\">:b</span> <span class=\"number\">2</span>] [<span class=\"symbol\">:a</span> <span class=\"number\">1</span>]&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">set</span> [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>] '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))<span class=\"comment\">;=#&#123;[1 2 3]&#125;，vector视同为list</span></span><br><span class=\"line\">(<span class=\"name\">set</span> [] &#123;&#125; #&#123;&#125; ())<span class=\"comment\">;=#&#123;[] &#123;&#125; #&#123;&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>查询获取set内元素！</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;set作为函数</span></span><br><span class=\"line\">(<span class=\"name\">#</span>&#123;<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>&#125; <span class=\"number\">3</span>)<span class=\"comment\">;=3</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>&#125; <span class=\"symbol\">:d</span>)<span class=\"comment\">;=nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;contains?查询元素是否存在</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">contains?</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span>&#125; <span class=\"symbol\">:d</span>)<span class=\"comment\">;=true</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">contains?</span></span> #&#123;<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span>&#125; <span class=\"symbol\">:e</span>)<span class=\"comment\">;=false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;顺序集合sorted-set</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> <span class=\"symbol\">:c</span> <span class=\"symbol\">:d</span> <span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span>)<span class=\"comment\">;=#&#123;:a :b :c :d&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> [<span class=\"number\">1</span> <span class=\"number\">2</span>] [<span class=\"number\">4</span> <span class=\"number\">5</span>] [<span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=#&#123;[1 2] [2 3] [4 5]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;sorted-set在默认情况下，对元素类型有潜在的混淆，比如number与string无法一起排序，添加元素时也容易出现类型混淆</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-set</span></span> <span class=\"string\">\"a\"</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"string\">\"0\"</span>)<span class=\"comment\">;=ClassCastException java.lang.String cannot be cast to java.lang.Number</span></span><br></pre></td></tr></table></figure>\n<p><font size=2 color=#f28080><code>contains?</code>这个函数实际上是查找健值是否存在，这就表明set实际上也是map实现的，而它的键值与值相同。在这补充一点，set与vector都是基于map实现，但<code>contains?</code>在vector是无效的，因为它是以索引为键值，故<code>(contains? [:a :b :c] 2)</code>才能返回true，按元素值查找始终返回false。</font></p>\n<p>关于set的集合计算没打算讲，见<code>clojure.set/intersection</code>、<code>clojure.set/union</code>、<code>clojure.set/difference</code>的API。</p>\n<ul>\n<li><h3 id=\"map！重中之重！\"><a href=\"#map！重中之重！\" class=\"headerlink\" title=\"map！重中之重！\"></a><font color=#0099ff>map！重中之重！</font></h3></li>\n</ul>\n<p>map可能是clojure被应用最广的数据结构，不管你是否知情，比如用set时实际上用了map。</p>\n<p>有几样map，<code>hash-map</code>、<code>array-map</code>和<code>sorted-map</code>，不同的创建方式，返回也会是不同类型的map。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;直接用字面量创建map，它是个array-map</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_array_map &#123;<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>&#125;)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a_array_map)<span class=\"comment\">;=clojure.lang.PersistentArrayMap</span></span><br><span class=\"line\"><span class=\"comment\">;显示创建array-map</span></span><br><span class=\"line\">(<span class=\"name\">array-map</span> <span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span>)<span class=\"comment\">;=&#123;:a 1, :b 2&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;用zipmap创建也是个array-map，在clojure 1.2则是个hash-map</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">zipmap</span></span> [<span class=\"symbol\">:a</span> <span class=\"symbol\">:b</span> <span class=\"symbol\">:c</span>] [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>])<span class=\"comment\">;=&#123;:a 1, :b 2, :c 3&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;hash-map创建一个HashMap</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a_hash_map (<span class=\"name\"><span class=\"builtin-name\">hash-map</span></span> <span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>))<span class=\"comment\">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a_hash_map)<span class=\"comment\">;=clojure.lang.PersistentHashMap</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">apply</span></span> hash-map [<span class=\"symbol\">:a</span> <span class=\"number\">1</span> <span class=\"symbol\">:b</span> <span class=\"number\">2</span> <span class=\"symbol\">:c</span> <span class=\"number\">3</span> <span class=\"symbol\">:d</span> <span class=\"number\">4</span>])<span class=\"comment\">;=&#123;:c 3, :b 2, :d 4, :a 1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>hash-map</code>的键值是无法指定顺序的，<code>array-map</code>则是按照插入顺序，只有<code>sorted-map</code>的键值能依照默认或我们提供的特定顺序进行排序。不过有一点，因为<code>sorted-map</code>键值需要遵循特定顺序，所以对键值的类型也有所限定，不再像其他两个类型的map一样支持异构。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"symbol\">:d</span> <span class=\"number\">1</span> <span class=\"symbol\">:a</span> <span class=\"number\">3</span> <span class=\"symbol\">:o</span> <span class=\"number\">9</span> <span class=\"symbol\">:c</span> <span class=\"string\">\"d\"</span>)<span class=\"comment\">;=&#123;:a 3, :c \"d\", :d 1, :o 9&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;键值类型不一致而无法比较，会直接抛出异常</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"symbol\">:d</span> <span class=\"number\">1</span> <span class=\"symbol\">:a</span> <span class=\"number\">3</span> <span class=\"symbol\">:o</span> <span class=\"number\">9</span> <span class=\"string\">\"d\"</span> <span class=\"string\">\"d\"</span>)<span class=\"comment\">;=ClassCastException clojure.lang.Keyword cannot be cast to java.lang.String</span></span><br><span class=\"line\"><span class=\"comment\">;可以自定义比较器来创建sorted-map，即sorted-map-by函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">sorted-map-by</span></span></span><br><span class=\"line\">  #(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [[x y]</span><br><span class=\"line\">         (<span class=\"name\"><span class=\"builtin-name\">map</span></span> (<span class=\"name\"><span class=\"builtin-name\">fn</span></span> [z]</span><br><span class=\"line\">                (<span class=\"name\">Integer/valueOf</span> (<span class=\"name\"><span class=\"builtin-name\">last</span></span> (<span class=\"name\">.split</span> z <span class=\"string\">\"-\"</span>)))) [%<span class=\"number\">1</span> %<span class=\"number\">2</span>])]</span><br><span class=\"line\">     (<span class=\"name\"><span class=\"builtin-name\">compare</span></span> x y)) <span class=\"string\">\"tom-12\"</span> <span class=\"symbol\">:BJ</span> <span class=\"string\">\"jim-24\"</span> <span class=\"symbol\">:GZ</span> <span class=\"string\">\"anj-6\"</span> <span class=\"symbol\">:SZ</span>)<span class=\"comment\">;=&#123;\"anj-6\" :SZ, \"tom-12\" :BJ, \"jim-24\" :GZ&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>获取map的某个值也是用get，map本身也可以作为函数且接受一个参数，键值(只能为keyword类型)同样可以作为函数且接受一个map。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> person &#123;</span><br><span class=\"line\">             <span class=\"symbol\">:name</span> <span class=\"string\">\"Mark Volkmann\"</span></span><br><span class=\"line\">             <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                       <span class=\"symbol\">:street</span> <span class=\"string\">\"644 Glen Summit\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:city</span> <span class=\"string\">\"St. Charles\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                       <span class=\"symbol\">:zip</span> <span class=\"number\">63304</span>&#125;</span><br><span class=\"line\">             <span class=\"symbol\">:employer</span> &#123;</span><br><span class=\"line\">                        <span class=\"symbol\">:name</span> <span class=\"string\">\"Object Computing, Inc.\"</span></span><br><span class=\"line\">                        <span class=\"symbol\">:address</span> &#123;</span><br><span class=\"line\">                                  <span class=\"symbol\">:street</span> <span class=\"string\">\"12140 Woodcrest Executive Drive, Suite 250\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:city</span> <span class=\"string\">\"Creve Coeur\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:state</span> <span class=\"string\">\"Missouri\"</span></span><br><span class=\"line\">                                  <span class=\"symbol\">:zip</span> <span class=\"number\">63141</span>&#125;&#125;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> person <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">get</span></span> (<span class=\"name\"><span class=\"builtin-name\">get</span></span> person <span class=\"symbol\">:employer</span>) name)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"name\">person</span> <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">((<span class=\"name\">person</span> <span class=\"symbol\">:employer</span>) <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"symbol\">:name</span> person)<span class=\"comment\">;=\"Mark Volkmann\"</span></span><br><span class=\"line\">(<span class=\"symbol\">:name</span> (<span class=\"symbol\">:employer</span> person))<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br><span class=\"line\"><span class=\"comment\">;因为键值作为函数，所以可以当作组合函数而使用'-&gt;'宏；反之，map作为函数则不行。</span></span><br><span class=\"line\"><span class=\"comment\">;第一个参数是第二个参数的实参，获取到子map后传递到给后面的键值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">-&gt;</span></span> person <span class=\"symbol\">:employer</span> <span class=\"symbol\">:name</span>)<span class=\"comment\">;=\"Object Computing, Inc.\"</span></span><br></pre></td></tr></table></figure>\n\n<p>给map修改添加键值对的函数与set说到的几个函数一样，<code>assoc-in</code>、<code>update-in</code>和<code>assoc</code>。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\">assoc-in</span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:city</span>] <span class=\"string\">\"Clayton\"</span>)</span><br><span class=\"line\"><span class=\"comment\">;如果键值不存在，则新添进去</span></span><br><span class=\"line\">(<span class=\"name\">assoc-in</span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:phone</span>] <span class=\"string\">\"13700000000\"</span>)</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">update-in</span></span> person [<span class=\"symbol\">:employer</span> <span class=\"symbol\">:address</span> <span class=\"symbol\">:zip</span>] str <span class=\"string\">\"-1234\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;需要注意一点，当map的键值是数字类型时，在有序map和hashmap或arraymap上做assoc操作结果是有可能不同的。(在《clojure编程乐趣》有说到)</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> &#123;<span class=\"number\">1</span> <span class=\"symbol\">:int</span>&#125; <span class=\"number\">1.0</span> <span class=\"symbol\">:float</span>)<span class=\"comment\">;=&#123;1 :int, 1.0 :float&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;有序集合中，键值相等则认为是同一个</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">assoc</span></span> (<span class=\"name\"><span class=\"builtin-name\">sorted-map</span></span> <span class=\"number\">1</span> <span class=\"symbol\">:int</span>) <span class=\"number\">1.0</span> <span class=\"symbol\">:float</span>)<span class=\"comment\">;=&#123;1 :float&#125;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"初学Clojure—不可变性与惰性","date":"2017-01-29T14:15:15.000Z","_content":"\n\n在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。\n\n---\n\n- ### <font color=#0099ff>数据也有“版本树”？</font>\n\nClojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。\n``` clojure\n(def a '(1 2 3 4))\n(def a (conj 1 a));=(5 1 2 3 4)\n```\n\n数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。\n\n数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。\n\n```clojure\n;继续上面的list\n;好比a和b共享'(1 2 3 4)部分\n(def a '(1 2 3 4))\n(def b (conj a 5));=(5 1 2 3 4)\n;做一下校验\n(identical? a (next b));=true\n;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。\n; b    a\n; |    |\n;[5]--[1]--[2]--[3]--[4]\n```\n\n列表的结构化共享并不复杂，很容易理解。map则会复杂很多，`sorted-map`由红黑树实现，`array-map`、`hash-map`等由Trie树实现。\n\n搞个二叉树来简单说明一下map的结构化。\n```clojure\n(defn xconj [t v]\n  (cond\n    (nil? t) {:val v :L nil :R nil}\n    (< v (:val t)) {:val (:val t)\n                    :L (xconj (:L t) v)\n                    :R (:R t)}\n    :else          {:val (:val t)\n                   :L (:L t)\n                   :R (xconj (:R t) v)}))\n(def tree1 (xconj nil 5));={:val 5, :L nil, :R nil}\n(def tree1 (xconj tree1 3));={:val 5, :L {:val 3, :L nil, :R nil}, :R nil}\n(def tree1 (xconj tree1 2));={:val 5, :L {:val 3, :L {:val 2, :L nil, :R nil}, :R nil}, :R nil}\n(def tree2 (xconj tree1 7));={:val 5, :L {:val 3, :L {:val 2, :L nil, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L nil, :R nil}, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L {:val 0, :L nil, :R nil}, :R nil}, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L {:val 0, :L nil, :R nil}, :R nil}, :R nil}, :R {:val 4, :L nil, :R nil}}, :R {:val 7, :L nil, :R nil}}\n;两棵树的形状大致如下：\n;   tree1            tree2\n;    [5]              [5]\n;   |   |            |   |\n;  [3]  nil         [3] [7]\n; |                |   \n;[2]              [2]  \n\n;取tree1和tree2的左边比较，结果是相等的\n(identical? (:L tree1) (:L tree2));=true\n;   tree1\n;    [5]\n;   |     tree2\n;  [3] --- [5]\n; |          |   \n;[2]        [7]  \n```\n上面的简易二叉树例子，可以发现：\n\n1、数据结果每做一次修改，至少新增一个节点；\n\n2、未被修改的另一边分支不会被复杂(比如[2]-[3])，可应用整棵树及其分支；\n\n3、整个过程是线程安全的，多线程同时改变tree1，tree1依然是那棵树；\n\n不同引用与这个结构化共享的数据形成了“版本树”，每个引用各自对应一个版本的数据。结构化共享是支持不变量所必须的，不然一直复制数据迟早会把内存撑爆。\n\n- ### <font color=#0099ff>让数据更懒惰～</font>\n\n上面说到的结构化共享，作用于修改不变量时节省内存。但在处理大数据量是，单凭结构化共享是远远不够，十万八千里都不止！例如声明一个长列表是很耗性能的，完全实例化需要的内存可能非常多，花费的时间可能相当长，如果实例化过程中使用递归，完全会导致栈溢出。\n\n举个例子，把一个向量转为多个cons嵌套。\n```clojure\n(defn rec-step [[x & rest]]\n  (if x\n    [x (rec-step rest)]\n    []))\n;长度只有10，很容易就实例化全部元素\n(rec-step [0 1 2 3 4 5 6 7 8 9]);=[0 [1 [2 [3 [4 [5 [6 [7 [8 [9 []]]]]]]]]]]\n;假如需要20000个元素，长度不仅很长，而且实例化函数并非尾递归，未完全实例化就栈溢出。\n(rec-step (range 20000));StackOverflowError   clojure.lang.LongRange.next (LongRange.java:142)\n```\n\n所以clojure给我提供了`lazy-seq`宏，用于生成惰性序列。惰性序列是干吗用的呢？当声明一个惰性序列后，里面的元素只有被调用到时才会被实例化，这样内存不会被一时间的大量数据耗尽，程序也不会长时间阻塞在实例化列表元素。\n\n```clojure\n;好比这个生成区间列表的函数\n(defn simple-lst [i limit]\n  (cond (> limit i) (conj (simple-lst (inc i) limit) i)\n        (< limit i) nil\n        :else (list i)))\n;理想结果是(0 1 2 3 .... 9999999 10000000)，然而并不是\n;一不小心就 StackOverflowError   clojure.lang.Numbers$LongOps.lt (Numbers.java:521)\n(simple-lst 0 10000000)\n\n;来个惰性序列版的\n(defn lazy-simple-lst [i limit]\n  (lazy-seq\n    (when (>= limit i)\n      (cons i (lazy-simple-lst (inc i) limit)))))\n(def a (lazy-simple-lst 0 10000000))\n(class a);=clojure.lang.LazySeq\n\n;由于惰性序列需要调用时才实例化元素，所以在类似获取序列长度就需要完全实例化，非常耗时！\n(def lzy-lst (lazy-simple-lst 0 2000))\n(def lst (simple-lst 0 2000))\n(time (count lzy-lst));=\"Elapsed time: 20.47562 msecs\"\n(time (count lst));=\"Elapsed time: 0.274659 msecs\"\n```\n\n<font color=#f28080>lazy-seq的next和rest操作结果也是有区别的。</font>每取一次seq时，rest都会完全按照我们的本意，一个一个实例化出来；next则不然，它为了确保下一次seq是否为nil，会额外实例化至少一个元素，即next返回的序列，至少惰性延迟一个元素。当我们需要尽可能的惰性序列时，则用rest。在一般情况下，用next还是比较保险的，但如果每实例化一个元素都很费劲的话，显然rest实现完全惰性是不二选择!\n\n\n虽然惰性序列能保证大数据量不会被必须一次性完全实例化而导致内存爆，但数据被逐个调用后，如果不放弃头部，迟早还是会奔溃。\n\n```clojure\n;编译器会自行推断lazy-seq是否需要保持头，如果不需要，会自动逐渐清理垃圾。\n(let [r (lazy-simple-lst 0 1e8)] (list (first r) (last r)))\n;否则，一直持有序列头部，会使被实例化的部分无法释放，占用内存，直到StackOverflowError或OutOfMemoryError。尽管编译器可能会优化值的运算顺序，但也是要保证在纯函数下，所以丢弃头是惯用法，最好是这样做！\n(let [r (lazy-simple-lst 0 1e8)] (list (last r) (first r)));=OutOfMemoryError GC overhead limit exceeded  user/lazy-simple-lst\n```\n惰性是个好东西！\n\n\n- ### <font color=#0099ff>分块序列</font>\n\nclojure有个很值得一提的技术，夹在一次性完全实例化和逐一实例化的惰性之间，就是分块序列，意思是每一次实例化一定宽度的元素(称“分块窗口”)。分块序列在某些时候，其综合性能要比惰性序列要高，毕竟惰性的“一次一个”实例化的消耗还是不容小视的。\n```clojure\n(def gimme #(do (print \\. %)))\n;现在只需要第一个元素，但可以看到依然实例化整个区间\n(take 1 (map gimme (range 32)));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31\n;同样只需要第一个元素，整个区间长度为65，但只实例化前32个元素\n(take 1 (map gimme (range 65)));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31\n;当我们想获取第33个元素时，实例化了两个分块窗口(0-31,32-63)，64未被求值\n(take 1 (drop 32 (map gimme (range 65))));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 56. 57. 58. 59. 60. 61. 62. 63\n```\n","source":"_posts/20170129-初学Clojure—不可变性与惰性.md","raw":"---\ntitle: 初学Clojure—不可变性与惰性\ntags:\n  - clojure\n  - 教程\n  - 并发编程语言\ncategories:\n  - 函数编程\ndate: 2017-01-29 22:15:15\n---\n\n\n在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。\n\n---\n\n- ### <font color=#0099ff>数据也有“版本树”？</font>\n\nClojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。\n``` clojure\n(def a '(1 2 3 4))\n(def a (conj 1 a));=(5 1 2 3 4)\n```\n\n数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。\n\n数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。\n\n```clojure\n;继续上面的list\n;好比a和b共享'(1 2 3 4)部分\n(def a '(1 2 3 4))\n(def b (conj a 5));=(5 1 2 3 4)\n;做一下校验\n(identical? a (next b));=true\n;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。\n; b    a\n; |    |\n;[5]--[1]--[2]--[3]--[4]\n```\n\n列表的结构化共享并不复杂，很容易理解。map则会复杂很多，`sorted-map`由红黑树实现，`array-map`、`hash-map`等由Trie树实现。\n\n搞个二叉树来简单说明一下map的结构化。\n```clojure\n(defn xconj [t v]\n  (cond\n    (nil? t) {:val v :L nil :R nil}\n    (< v (:val t)) {:val (:val t)\n                    :L (xconj (:L t) v)\n                    :R (:R t)}\n    :else          {:val (:val t)\n                   :L (:L t)\n                   :R (xconj (:R t) v)}))\n(def tree1 (xconj nil 5));={:val 5, :L nil, :R nil}\n(def tree1 (xconj tree1 3));={:val 5, :L {:val 3, :L nil, :R nil}, :R nil}\n(def tree1 (xconj tree1 2));={:val 5, :L {:val 3, :L {:val 2, :L nil, :R nil}, :R nil}, :R nil}\n(def tree2 (xconj tree1 7));={:val 5, :L {:val 3, :L {:val 2, :L nil, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L nil, :R nil}, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L {:val 0, :L nil, :R nil}, :R nil}, :R nil}, :R nil}, :R {:val 7, :L nil, :R nil}}\n;{:val 5, :L {:val 3, :L {:val 2, :L {:val 1, :L {:val 0, :L nil, :R nil}, :R nil}, :R nil}, :R {:val 4, :L nil, :R nil}}, :R {:val 7, :L nil, :R nil}}\n;两棵树的形状大致如下：\n;   tree1            tree2\n;    [5]              [5]\n;   |   |            |   |\n;  [3]  nil         [3] [7]\n; |                |   \n;[2]              [2]  \n\n;取tree1和tree2的左边比较，结果是相等的\n(identical? (:L tree1) (:L tree2));=true\n;   tree1\n;    [5]\n;   |     tree2\n;  [3] --- [5]\n; |          |   \n;[2]        [7]  \n```\n上面的简易二叉树例子，可以发现：\n\n1、数据结果每做一次修改，至少新增一个节点；\n\n2、未被修改的另一边分支不会被复杂(比如[2]-[3])，可应用整棵树及其分支；\n\n3、整个过程是线程安全的，多线程同时改变tree1，tree1依然是那棵树；\n\n不同引用与这个结构化共享的数据形成了“版本树”，每个引用各自对应一个版本的数据。结构化共享是支持不变量所必须的，不然一直复制数据迟早会把内存撑爆。\n\n- ### <font color=#0099ff>让数据更懒惰～</font>\n\n上面说到的结构化共享，作用于修改不变量时节省内存。但在处理大数据量是，单凭结构化共享是远远不够，十万八千里都不止！例如声明一个长列表是很耗性能的，完全实例化需要的内存可能非常多，花费的时间可能相当长，如果实例化过程中使用递归，完全会导致栈溢出。\n\n举个例子，把一个向量转为多个cons嵌套。\n```clojure\n(defn rec-step [[x & rest]]\n  (if x\n    [x (rec-step rest)]\n    []))\n;长度只有10，很容易就实例化全部元素\n(rec-step [0 1 2 3 4 5 6 7 8 9]);=[0 [1 [2 [3 [4 [5 [6 [7 [8 [9 []]]]]]]]]]]\n;假如需要20000个元素，长度不仅很长，而且实例化函数并非尾递归，未完全实例化就栈溢出。\n(rec-step (range 20000));StackOverflowError   clojure.lang.LongRange.next (LongRange.java:142)\n```\n\n所以clojure给我提供了`lazy-seq`宏，用于生成惰性序列。惰性序列是干吗用的呢？当声明一个惰性序列后，里面的元素只有被调用到时才会被实例化，这样内存不会被一时间的大量数据耗尽，程序也不会长时间阻塞在实例化列表元素。\n\n```clojure\n;好比这个生成区间列表的函数\n(defn simple-lst [i limit]\n  (cond (> limit i) (conj (simple-lst (inc i) limit) i)\n        (< limit i) nil\n        :else (list i)))\n;理想结果是(0 1 2 3 .... 9999999 10000000)，然而并不是\n;一不小心就 StackOverflowError   clojure.lang.Numbers$LongOps.lt (Numbers.java:521)\n(simple-lst 0 10000000)\n\n;来个惰性序列版的\n(defn lazy-simple-lst [i limit]\n  (lazy-seq\n    (when (>= limit i)\n      (cons i (lazy-simple-lst (inc i) limit)))))\n(def a (lazy-simple-lst 0 10000000))\n(class a);=clojure.lang.LazySeq\n\n;由于惰性序列需要调用时才实例化元素，所以在类似获取序列长度就需要完全实例化，非常耗时！\n(def lzy-lst (lazy-simple-lst 0 2000))\n(def lst (simple-lst 0 2000))\n(time (count lzy-lst));=\"Elapsed time: 20.47562 msecs\"\n(time (count lst));=\"Elapsed time: 0.274659 msecs\"\n```\n\n<font color=#f28080>lazy-seq的next和rest操作结果也是有区别的。</font>每取一次seq时，rest都会完全按照我们的本意，一个一个实例化出来；next则不然，它为了确保下一次seq是否为nil，会额外实例化至少一个元素，即next返回的序列，至少惰性延迟一个元素。当我们需要尽可能的惰性序列时，则用rest。在一般情况下，用next还是比较保险的，但如果每实例化一个元素都很费劲的话，显然rest实现完全惰性是不二选择!\n\n\n虽然惰性序列能保证大数据量不会被必须一次性完全实例化而导致内存爆，但数据被逐个调用后，如果不放弃头部，迟早还是会奔溃。\n\n```clojure\n;编译器会自行推断lazy-seq是否需要保持头，如果不需要，会自动逐渐清理垃圾。\n(let [r (lazy-simple-lst 0 1e8)] (list (first r) (last r)))\n;否则，一直持有序列头部，会使被实例化的部分无法释放，占用内存，直到StackOverflowError或OutOfMemoryError。尽管编译器可能会优化值的运算顺序，但也是要保证在纯函数下，所以丢弃头是惯用法，最好是这样做！\n(let [r (lazy-simple-lst 0 1e8)] (list (last r) (first r)));=OutOfMemoryError GC overhead limit exceeded  user/lazy-simple-lst\n```\n惰性是个好东西！\n\n\n- ### <font color=#0099ff>分块序列</font>\n\nclojure有个很值得一提的技术，夹在一次性完全实例化和逐一实例化的惰性之间，就是分块序列，意思是每一次实例化一定宽度的元素(称“分块窗口”)。分块序列在某些时候，其综合性能要比惰性序列要高，毕竟惰性的“一次一个”实例化的消耗还是不容小视的。\n```clojure\n(def gimme #(do (print \\. %)))\n;现在只需要第一个元素，但可以看到依然实例化整个区间\n(take 1 (map gimme (range 32)));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31\n;同样只需要第一个元素，整个区间长度为65，但只实例化前32个元素\n(take 1 (map gimme (range 65)));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31\n;当我们想获取第33个元素时，实例化了两个分块窗口(0-31,32-63)，64未被求值\n(take 1 (drop 32 (map gimme (range 65))));=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 56. 57. 58. 59. 60. 61. 62. 63\n```\n","slug":"20170129-初学Clojure—不可变性与惰性","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7st002e4ejd8ni07dgd","content":"<p>在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。</p>\n<hr>\n<ul>\n<li><h3 id=\"数据也有“版本树”？\"><a href=\"#数据也有“版本树”？\" class=\"headerlink\" title=\"数据也有“版本树”？\"></a><font color=#0099ff>数据也有“版本树”？</font></h3></li>\n</ul>\n<p>Clojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> <span class=\"number\">1</span> a))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br></pre></td></tr></table></figure>\n\n<p>数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。</p>\n<p>数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;继续上面的list</span></span><br><span class=\"line\"><span class=\"comment\">;好比a和b共享'(1 2 3 4)部分</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> b (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> a <span class=\"number\">5</span>))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br><span class=\"line\"><span class=\"comment\">;做一下校验</span></span><br><span class=\"line\">(<span class=\"name\">identical?</span> a (<span class=\"name\"><span class=\"builtin-name\">next</span></span> b))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。</span></span><br><span class=\"line\"><span class=\"comment\">; b    a</span></span><br><span class=\"line\"><span class=\"comment\">; |    |</span></span><br><span class=\"line\"><span class=\"comment\">;[5]--[1]--[2]--[3]--[4]</span></span><br></pre></td></tr></table></figure>\n\n<p>列表的结构化共享并不复杂，很容易理解。map则会复杂很多，<code>sorted-map</code>由红黑树实现，<code>array-map</code>、<code>hash-map</code>等由Trie树实现。</p>\n<p>搞个二叉树来简单说明一下map的结构化。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> xconj [t v]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">nil?</span></span> t) &#123;<span class=\"symbol\">:val</span> v <span class=\"symbol\">:L</span> <span class=\"literal\">nil</span> <span class=\"symbol\">:R</span> <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> v (<span class=\"symbol\">:val</span> t)) &#123;<span class=\"symbol\">:val</span> (<span class=\"symbol\">:val</span> t)</span><br><span class=\"line\">                    <span class=\"symbol\">:L</span> (<span class=\"name\">xconj</span> (<span class=\"symbol\">:L</span> t) v)</span><br><span class=\"line\">                    <span class=\"symbol\">:R</span> (<span class=\"symbol\">:R</span> t)&#125;</span><br><span class=\"line\">    <span class=\"symbol\">:else</span>          &#123;<span class=\"symbol\">:val</span> (<span class=\"symbol\">:val</span> t)</span><br><span class=\"line\">                   <span class=\"symbol\">:L</span> (<span class=\"symbol\">:L</span> t)</span><br><span class=\"line\">                   <span class=\"symbol\">:R</span> (<span class=\"name\">xconj</span> (<span class=\"symbol\">:R</span> t) v)&#125;))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> <span class=\"literal\">nil</span> <span class=\"number\">5</span>))<span class=\"comment\">;=&#123;:val 5, :L nil, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">3</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L nil, :R nil&#125;, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">2</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree2 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">7</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 4, :L nil, :R nil&#125;&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;两棵树的形状大致如下：</span></span><br><span class=\"line\"><span class=\"comment\">;   tree1            tree2</span></span><br><span class=\"line\"><span class=\"comment\">;    [5]              [5]</span></span><br><span class=\"line\"><span class=\"comment\">;   |   |            |   |</span></span><br><span class=\"line\"><span class=\"comment\">;  [3]  nil         [3] [7]</span></span><br><span class=\"line\"><span class=\"comment\">; |                |   </span></span><br><span class=\"line\"><span class=\"comment\">;[2]              [2]  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;取tree1和tree2的左边比较，结果是相等的</span></span><br><span class=\"line\">(<span class=\"name\">identical?</span> (<span class=\"symbol\">:L</span> tree1) (<span class=\"symbol\">:L</span> tree2))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;   tree1</span></span><br><span class=\"line\"><span class=\"comment\">;    [5]</span></span><br><span class=\"line\"><span class=\"comment\">;   |     tree2</span></span><br><span class=\"line\"><span class=\"comment\">;  [3] --- [5]</span></span><br><span class=\"line\"><span class=\"comment\">; |          |   </span></span><br><span class=\"line\"><span class=\"comment\">;[2]        [7]</span></span><br></pre></td></tr></table></figure>\n<p>上面的简易二叉树例子，可以发现：</p>\n<p>1、数据结果每做一次修改，至少新增一个节点；</p>\n<p>2、未被修改的另一边分支不会被复杂(比如[2]-[3])，可应用整棵树及其分支；</p>\n<p>3、整个过程是线程安全的，多线程同时改变tree1，tree1依然是那棵树；</p>\n<p>不同引用与这个结构化共享的数据形成了“版本树”，每个引用各自对应一个版本的数据。结构化共享是支持不变量所必须的，不然一直复制数据迟早会把内存撑爆。</p>\n<ul>\n<li><h3 id=\"让数据更懒惰～\"><a href=\"#让数据更懒惰～\" class=\"headerlink\" title=\"让数据更懒惰～\"></a><font color=#0099ff>让数据更懒惰～</font></h3></li>\n</ul>\n<p>上面说到的结构化共享，作用于修改不变量时节省内存。但在处理大数据量是，单凭结构化共享是远远不够，十万八千里都不止！例如声明一个长列表是很耗性能的，完全实例化需要的内存可能非常多，花费的时间可能相当长，如果实例化过程中使用递归，完全会导致栈溢出。</p>\n<p>举个例子，把一个向量转为多个cons嵌套。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rec-step [[x &amp; rest]]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x</span><br><span class=\"line\">    [x (<span class=\"name\">rec-step</span> rest)]</span><br><span class=\"line\">    []))</span><br><span class=\"line\"><span class=\"comment\">;长度只有10，很容易就实例化全部元素</span></span><br><span class=\"line\">(<span class=\"name\">rec-step</span> [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>])<span class=\"comment\">;=[0 [1 [2 [3 [4 [5 [6 [7 [8 [9 []]]]]]]]]]]</span></span><br><span class=\"line\"><span class=\"comment\">;假如需要20000个元素，长度不仅很长，而且实例化函数并非尾递归，未完全实例化就栈溢出。</span></span><br><span class=\"line\">(<span class=\"name\">rec-step</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">20000</span>))<span class=\"comment\">;StackOverflowError   clojure.lang.LongRange.next (LongRange.java:142)</span></span><br></pre></td></tr></table></figure>\n\n<p>所以clojure给我提供了<code>lazy-seq</code>宏，用于生成惰性序列。惰性序列是干吗用的呢？当声明一个惰性序列后，里面的元素只有被调用到时才会被实例化，这样内存不会被一时间的大量数据耗尽，程序也不会长时间阻塞在实例化列表元素。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;好比这个生成区间列表的函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> simple-lst [i limit]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> limit i) (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\">simple-lst</span> (<span class=\"name\"><span class=\"builtin-name\">inc</span></span> i) limit) i)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> limit i) <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"symbol\">:else</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> i)))</span><br><span class=\"line\"><span class=\"comment\">;理想结果是(0 1 2 3 .... 9999999 10000000)，然而并不是</span></span><br><span class=\"line\"><span class=\"comment\">;一不小心就 StackOverflowError   clojure.lang.Numbers$LongOps.lt (Numbers.java:521)</span></span><br><span class=\"line\">(<span class=\"name\">simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">10000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;来个惰性序列版的</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> lazy-simple-lst [i limit]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lazy-seq</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">when</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> limit i)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> i (<span class=\"name\">lazy-simple-lst</span> (<span class=\"name\"><span class=\"builtin-name\">inc</span></span> i) limit)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">10000000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a)<span class=\"comment\">;=clojure.lang.LazySeq</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;由于惰性序列需要调用时才实例化元素，所以在类似获取序列长度就需要完全实例化，非常耗时！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lzy-lst (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">2000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst (<span class=\"name\">simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">2000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">time</span></span> (<span class=\"name\"><span class=\"builtin-name\">count</span></span> lzy-lst))<span class=\"comment\">;=\"Elapsed time: 20.47562 msecs\"</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">time</span></span> (<span class=\"name\"><span class=\"builtin-name\">count</span></span> lst))<span class=\"comment\">;=\"Elapsed time: 0.274659 msecs\"</span></span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080>lazy-seq的next和rest操作结果也是有区别的。</font>每取一次seq时，rest都会完全按照我们的本意，一个一个实例化出来；next则不然，它为了确保下一次seq是否为nil，会额外实例化至少一个元素，即next返回的序列，至少惰性延迟一个元素。当我们需要尽可能的惰性序列时，则用rest。在一般情况下，用next还是比较保险的，但如果每实例化一个元素都很费劲的话，显然rest实现完全惰性是不二选择!</p>\n<p>虽然惰性序列能保证大数据量不会被必须一次性完全实例化而导致内存爆，但数据被逐个调用后，如果不放弃头部，迟早还是会奔溃。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;编译器会自行推断lazy-seq是否需要保持头，如果不需要，会自动逐渐清理垃圾。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [r (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">1</span>e8)] (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">first</span></span> r) (<span class=\"name\"><span class=\"builtin-name\">last</span></span> r)))</span><br><span class=\"line\"><span class=\"comment\">;否则，一直持有序列头部，会使被实例化的部分无法释放，占用内存，直到StackOverflowError或OutOfMemoryError。尽管编译器可能会优化值的运算顺序，但也是要保证在纯函数下，所以丢弃头是惯用法，最好是这样做！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [r (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">1</span>e8)] (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">last</span></span> r) (<span class=\"name\"><span class=\"builtin-name\">first</span></span> r)))<span class=\"comment\">;=OutOfMemoryError GC overhead limit exceeded  user/lazy-simple-lst</span></span><br></pre></td></tr></table></figure>\n<p>惰性是个好东西！</p>\n<ul>\n<li><h3 id=\"分块序列\"><a href=\"#分块序列\" class=\"headerlink\" title=\"分块序列\"></a><font color=#0099ff>分块序列</font></h3></li>\n</ul>\n<p>clojure有个很值得一提的技术，夹在一次性完全实例化和逐一实例化的惰性之间，就是分块序列，意思是每一次实例化一定宽度的元素(称“分块窗口”)。分块序列在某些时候，其综合性能要比惰性序列要高，毕竟惰性的“一次一个”实例化的消耗还是不容小视的。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> gimme #(<span class=\"name\"><span class=\"builtin-name\">do</span></span> (<span class=\"name\">print</span> \\. %)))</span><br><span class=\"line\"><span class=\"comment\">;现在只需要第一个元素，但可以看到依然实例化整个区间</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">32</span>)))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class=\"line\"><span class=\"comment\">;同样只需要第一个元素，整个区间长度为65，但只实例化前32个元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">65</span>)))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class=\"line\"><span class=\"comment\">;当我们想获取第33个元素时，实例化了两个分块窗口(0-31,32-63)，64未被求值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">drop</span></span> <span class=\"number\">32</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">65</span>))))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 56. 57. 58. 59. 60. 61. 62. 63</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。</p>\n<hr>\n<ul>\n<li><h3 id=\"数据也有“版本树”？\"><a href=\"#数据也有“版本树”？\" class=\"headerlink\" title=\"数据也有“版本树”？\"></a><font color=#0099ff>数据也有“版本树”？</font></h3></li>\n</ul>\n<p>Clojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> <span class=\"number\">1</span> a))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br></pre></td></tr></table></figure>\n\n<p>数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。</p>\n<p>数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;继续上面的list</span></span><br><span class=\"line\"><span class=\"comment\">;好比a和b共享'(1 2 3 4)部分</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a '(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> b (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> a <span class=\"number\">5</span>))<span class=\"comment\">;=(5 1 2 3 4)</span></span><br><span class=\"line\"><span class=\"comment\">;做一下校验</span></span><br><span class=\"line\">(<span class=\"name\">identical?</span> a (<span class=\"name\"><span class=\"builtin-name\">next</span></span> b))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。</span></span><br><span class=\"line\"><span class=\"comment\">; b    a</span></span><br><span class=\"line\"><span class=\"comment\">; |    |</span></span><br><span class=\"line\"><span class=\"comment\">;[5]--[1]--[2]--[3]--[4]</span></span><br></pre></td></tr></table></figure>\n\n<p>列表的结构化共享并不复杂，很容易理解。map则会复杂很多，<code>sorted-map</code>由红黑树实现，<code>array-map</code>、<code>hash-map</code>等由Trie树实现。</p>\n<p>搞个二叉树来简单说明一下map的结构化。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> xconj [t v]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">nil?</span></span> t) &#123;<span class=\"symbol\">:val</span> v <span class=\"symbol\">:L</span> <span class=\"literal\">nil</span> <span class=\"symbol\">:R</span> <span class=\"literal\">nil</span>&#125;</span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> v (<span class=\"symbol\">:val</span> t)) &#123;<span class=\"symbol\">:val</span> (<span class=\"symbol\">:val</span> t)</span><br><span class=\"line\">                    <span class=\"symbol\">:L</span> (<span class=\"name\">xconj</span> (<span class=\"symbol\">:L</span> t) v)</span><br><span class=\"line\">                    <span class=\"symbol\">:R</span> (<span class=\"symbol\">:R</span> t)&#125;</span><br><span class=\"line\">    <span class=\"symbol\">:else</span>          &#123;<span class=\"symbol\">:val</span> (<span class=\"symbol\">:val</span> t)</span><br><span class=\"line\">                   <span class=\"symbol\">:L</span> (<span class=\"symbol\">:L</span> t)</span><br><span class=\"line\">                   <span class=\"symbol\">:R</span> (<span class=\"name\">xconj</span> (<span class=\"symbol\">:R</span> t) v)&#125;))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> <span class=\"literal\">nil</span> <span class=\"number\">5</span>))<span class=\"comment\">;=&#123;:val 5, :L nil, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">3</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L nil, :R nil&#125;, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree1 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">2</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> tree2 (<span class=\"name\">xconj</span> tree1 <span class=\"number\">7</span>))<span class=\"comment\">;=&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L nil, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;&#123;:val 5, :L &#123;:val 3, :L &#123;:val 2, :L &#123;:val 1, :L &#123;:val 0, :L nil, :R nil&#125;, :R nil&#125;, :R nil&#125;, :R &#123;:val 4, :L nil, :R nil&#125;&#125;, :R &#123;:val 7, :L nil, :R nil&#125;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">;两棵树的形状大致如下：</span></span><br><span class=\"line\"><span class=\"comment\">;   tree1            tree2</span></span><br><span class=\"line\"><span class=\"comment\">;    [5]              [5]</span></span><br><span class=\"line\"><span class=\"comment\">;   |   |            |   |</span></span><br><span class=\"line\"><span class=\"comment\">;  [3]  nil         [3] [7]</span></span><br><span class=\"line\"><span class=\"comment\">; |                |   </span></span><br><span class=\"line\"><span class=\"comment\">;[2]              [2]  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;取tree1和tree2的左边比较，结果是相等的</span></span><br><span class=\"line\">(<span class=\"name\">identical?</span> (<span class=\"symbol\">:L</span> tree1) (<span class=\"symbol\">:L</span> tree2))<span class=\"comment\">;=true</span></span><br><span class=\"line\"><span class=\"comment\">;   tree1</span></span><br><span class=\"line\"><span class=\"comment\">;    [5]</span></span><br><span class=\"line\"><span class=\"comment\">;   |     tree2</span></span><br><span class=\"line\"><span class=\"comment\">;  [3] --- [5]</span></span><br><span class=\"line\"><span class=\"comment\">; |          |   </span></span><br><span class=\"line\"><span class=\"comment\">;[2]        [7]</span></span><br></pre></td></tr></table></figure>\n<p>上面的简易二叉树例子，可以发现：</p>\n<p>1、数据结果每做一次修改，至少新增一个节点；</p>\n<p>2、未被修改的另一边分支不会被复杂(比如[2]-[3])，可应用整棵树及其分支；</p>\n<p>3、整个过程是线程安全的，多线程同时改变tree1，tree1依然是那棵树；</p>\n<p>不同引用与这个结构化共享的数据形成了“版本树”，每个引用各自对应一个版本的数据。结构化共享是支持不变量所必须的，不然一直复制数据迟早会把内存撑爆。</p>\n<ul>\n<li><h3 id=\"让数据更懒惰～\"><a href=\"#让数据更懒惰～\" class=\"headerlink\" title=\"让数据更懒惰～\"></a><font color=#0099ff>让数据更懒惰～</font></h3></li>\n</ul>\n<p>上面说到的结构化共享，作用于修改不变量时节省内存。但在处理大数据量是，单凭结构化共享是远远不够，十万八千里都不止！例如声明一个长列表是很耗性能的，完全实例化需要的内存可能非常多，花费的时间可能相当长，如果实例化过程中使用递归，完全会导致栈溢出。</p>\n<p>举个例子，把一个向量转为多个cons嵌套。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> rec-step [[x &amp; rest]]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">if</span></span> x</span><br><span class=\"line\">    [x (<span class=\"name\">rec-step</span> rest)]</span><br><span class=\"line\">    []))</span><br><span class=\"line\"><span class=\"comment\">;长度只有10，很容易就实例化全部元素</span></span><br><span class=\"line\">(<span class=\"name\">rec-step</span> [<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>])<span class=\"comment\">;=[0 [1 [2 [3 [4 [5 [6 [7 [8 [9 []]]]]]]]]]]</span></span><br><span class=\"line\"><span class=\"comment\">;假如需要20000个元素，长度不仅很长，而且实例化函数并非尾递归，未完全实例化就栈溢出。</span></span><br><span class=\"line\">(<span class=\"name\">rec-step</span> (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">20000</span>))<span class=\"comment\">;StackOverflowError   clojure.lang.LongRange.next (LongRange.java:142)</span></span><br></pre></td></tr></table></figure>\n\n<p>所以clojure给我提供了<code>lazy-seq</code>宏，用于生成惰性序列。惰性序列是干吗用的呢？当声明一个惰性序列后，里面的元素只有被调用到时才会被实例化，这样内存不会被一时间的大量数据耗尽，程序也不会长时间阻塞在实例化列表元素。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;好比这个生成区间列表的函数</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> simple-lst [i limit]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">cond</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;</span></span> limit i) (<span class=\"name\"><span class=\"builtin-name\">conj</span></span> (<span class=\"name\">simple-lst</span> (<span class=\"name\"><span class=\"builtin-name\">inc</span></span> i) limit) i)</span><br><span class=\"line\">        (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> limit i) <span class=\"literal\">nil</span></span><br><span class=\"line\">        <span class=\"symbol\">:else</span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> i)))</span><br><span class=\"line\"><span class=\"comment\">;理想结果是(0 1 2 3 .... 9999999 10000000)，然而并不是</span></span><br><span class=\"line\"><span class=\"comment\">;一不小心就 StackOverflowError   clojure.lang.Numbers$LongOps.lt (Numbers.java:521)</span></span><br><span class=\"line\">(<span class=\"name\">simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">10000000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;来个惰性序列版的</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">defn</span></span> lazy-simple-lst [i limit]</span><br><span class=\"line\">  (<span class=\"name\"><span class=\"builtin-name\">lazy-seq</span></span></span><br><span class=\"line\">    (<span class=\"name\"><span class=\"builtin-name\">when</span></span> (<span class=\"name\"><span class=\"builtin-name\">&gt;=</span></span> limit i)</span><br><span class=\"line\">      (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> i (<span class=\"name\">lazy-simple-lst</span> (<span class=\"name\"><span class=\"builtin-name\">inc</span></span> i) limit)))))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> a (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">10000000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">class</span></span> a)<span class=\"comment\">;=clojure.lang.LazySeq</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">;由于惰性序列需要调用时才实例化元素，所以在类似获取序列长度就需要完全实例化，非常耗时！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lzy-lst (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">2000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> lst (<span class=\"name\">simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">2000</span>))</span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">time</span></span> (<span class=\"name\"><span class=\"builtin-name\">count</span></span> lzy-lst))<span class=\"comment\">;=\"Elapsed time: 20.47562 msecs\"</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">time</span></span> (<span class=\"name\"><span class=\"builtin-name\">count</span></span> lst))<span class=\"comment\">;=\"Elapsed time: 0.274659 msecs\"</span></span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080>lazy-seq的next和rest操作结果也是有区别的。</font>每取一次seq时，rest都会完全按照我们的本意，一个一个实例化出来；next则不然，它为了确保下一次seq是否为nil，会额外实例化至少一个元素，即next返回的序列，至少惰性延迟一个元素。当我们需要尽可能的惰性序列时，则用rest。在一般情况下，用next还是比较保险的，但如果每实例化一个元素都很费劲的话，显然rest实现完全惰性是不二选择!</p>\n<p>虽然惰性序列能保证大数据量不会被必须一次性完全实例化而导致内存爆，但数据被逐个调用后，如果不放弃头部，迟早还是会奔溃。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">;编译器会自行推断lazy-seq是否需要保持头，如果不需要，会自动逐渐清理垃圾。</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [r (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">1</span>e8)] (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">first</span></span> r) (<span class=\"name\"><span class=\"builtin-name\">last</span></span> r)))</span><br><span class=\"line\"><span class=\"comment\">;否则，一直持有序列头部，会使被实例化的部分无法释放，占用内存，直到StackOverflowError或OutOfMemoryError。尽管编译器可能会优化值的运算顺序，但也是要保证在纯函数下，所以丢弃头是惯用法，最好是这样做！</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">let</span></span> [r (<span class=\"name\">lazy-simple-lst</span> <span class=\"number\">0</span> <span class=\"number\">1</span>e8)] (<span class=\"name\"><span class=\"builtin-name\">list</span></span> (<span class=\"name\"><span class=\"builtin-name\">last</span></span> r) (<span class=\"name\"><span class=\"builtin-name\">first</span></span> r)))<span class=\"comment\">;=OutOfMemoryError GC overhead limit exceeded  user/lazy-simple-lst</span></span><br></pre></td></tr></table></figure>\n<p>惰性是个好东西！</p>\n<ul>\n<li><h3 id=\"分块序列\"><a href=\"#分块序列\" class=\"headerlink\" title=\"分块序列\"></a><font color=#0099ff>分块序列</font></h3></li>\n</ul>\n<p>clojure有个很值得一提的技术，夹在一次性完全实例化和逐一实例化的惰性之间，就是分块序列，意思是每一次实例化一定宽度的元素(称“分块窗口”)。分块序列在某些时候，其综合性能要比惰性序列要高，毕竟惰性的“一次一个”实例化的消耗还是不容小视的。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">def</span></span> gimme #(<span class=\"name\"><span class=\"builtin-name\">do</span></span> (<span class=\"name\">print</span> \\. %)))</span><br><span class=\"line\"><span class=\"comment\">;现在只需要第一个元素，但可以看到依然实例化整个区间</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">32</span>)))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class=\"line\"><span class=\"comment\">;同样只需要第一个元素，整个区间长度为65，但只实例化前32个元素</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">65</span>)))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 24. 25. 26. 27. 28. 29. 30. 31</span></span><br><span class=\"line\"><span class=\"comment\">;当我们想获取第33个元素时，实例化了两个分块窗口(0-31,32-63)，64未被求值</span></span><br><span class=\"line\">(<span class=\"name\"><span class=\"builtin-name\">take</span></span> <span class=\"number\">1</span> (<span class=\"name\"><span class=\"builtin-name\">drop</span></span> <span class=\"number\">32</span> (<span class=\"name\"><span class=\"builtin-name\">map</span></span> gimme (<span class=\"name\"><span class=\"builtin-name\">range</span></span> <span class=\"number\">65</span>))))<span class=\"comment\">;=. 0. 1. 2. 3. 4. 5. 6. 7. 8 ... 56. 57. 58. 59. 60. 61. 62. 63</span></span><br></pre></td></tr></table></figure>\n"},{"title":"【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！","date":"2018-07-02T12:05:59.000Z","_content":"\n好长一段时间前，某些场景需要JUC的读写锁，但在某个时刻内读写线程都报超时预警（长时间无响应），看起来像是锁竞争过程中出现死锁（我猜）。经过排查项目并没有能造成死锁的可疑之处，因为业务代码并不复杂（仅仅是一个计算过程），经几番折腾，把注意力转移到JDK源码，正文详细说下ReentrantReadWriteLock的隐藏坑点。\n\n---\n\n过程大致如下：\n- 若干个读写线程抢占读写锁\n- 读线程手脚快，优先抢占到读锁（其中少数线程任务较重，执行时间较长）\n- 写线程随即尝试获取写锁，未成功，进入双列表进行等待\n- 随后读线程也进来了，要去拿读锁\n\n问题：优先得到锁的读线程执行时间长达73秒，该时段写线程等待是理所当然的，那读线程也应该能够得到读锁才对，因为是共享锁，是吧？但预警结果并不是如此，超时任务线程中大部分为读。究竟是什么让读线程无法抢占到读锁，而导致响应超时呢？\n\n把场景简化为如下的测试代码：读——写——读 线程依次尝试获取ReadWriteLock，用空转替换执行时间过长。\n\n执行结果：控制台仅打印出`Thread[读线程 -- 1,5,main]`，既是说`读线程 -- 2`并没有抢占到读锁，跟上诉的表现似乎一样。\n\n``` Java\npublic class ReadWriteLockTest {\n  public static void main(String[] args) {\n    ReadWriteLockTest readWriteLockTest = new ReadWriteLockTest();\n  }\n\n  public ReadWriteLockTest() {\n    try {\n      init();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n  void init() throws InterruptedException {\n    TestLock testLock = new TestLock();\n    Thread read1 = new Thread(new ReadThread(testLock), \"读线程 -- 1\");\n    read1.start();\n    Thread.sleep(100);\n    Thread write = new Thread(new WriteThread(testLock), \"写线程 -- 1\");\n    write.start();\n    Thread.sleep(100);\n    Thread read2 = new Thread(new ReadThread(testLock), \"读线程 -- 2\");\n    read2.start();\n  }\n\n  private class TestLock {\n\n    private String string = null;\n    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    private Lock readLock = readWriteLock.readLock();\n    private Lock writeLock = readWriteLock.writeLock();\n\n    public void set(String s) {\n      writeLock.lock();\n      try {\n//                writeLock.tryLock(10, TimeUnit.SECONDS);\n        string = s;\n      } finally {\n        writeLock.unlock();\n      }\n    }\n\n    public String getString() {\n      readLock.lock();\n      System.out.println(Thread.currentThread());\n      try {\n        while (true) {\n\n        }\n      } finally {\n        readLock.unlock();\n      }\n    }\n  }\n\n  class WriteThread implements Runnable {\n\n    private TestLock testLock;\n    public WriteThread(TestLock testLock) {\n      this.testLock = testLock;\n    }\n\n    @Override\n    public void run() {\n      testLock.set(\"射不进去，怎么办？\");\n    }\n  }\n\n  class ReadThread implements Runnable {\n\n    private TestLock testLock;\n    public ReadThread(TestLock testLock) {\n      this.testLock = testLock;\n    }\n\n    @Override\n    public void run() {\n      testLock.getString();\n    }\n  }\n}\n```\n我们用`jstack`查看一下线程，看到读线程2和写线程1确实处于WAITING的状态。\n\n![jstack](http://p4ygo03xz.bkt.clouddn.com/github-blog/image/jstack.png-50pencent)\n\n排查项目后，业务代码并没有问题，转而看下ReentrantReadWriteLock或AQS是否有什么问题被我忽略的。\n\n第一时间关注共享锁，因为独占锁的实现逻辑我确定很清晰了，很快我似乎看到自己想要的方法。\n``` Java\npublic static class ReadLock implements Lock, java.io.Serializable {\n  public void lock() {\n    //if(tryAcquireShared(arg) < 0) doAcquireShared(arg);\n    sync.acquireShared(1);\n  }\n}\nabstract static class Sync extends AbstractQueuedSynchronizer {\n  protected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    //计算stata，若独占锁被占，且持有锁非本线程，返回-1等待挂起\n    if (exclusiveCount(c) != 0 &&\n      getExclusiveOwnerThread() != current)\n      return -1;\n    //计算获取共享锁的线程数\n    int r = sharedCount(c);\n    //readerShouldBlock检查读线程是否要阻塞\n    if (!readerShouldBlock() &&\n      //线程数必须少于65535\n      r < MAX_COUNT &&\n      //符合上诉两个条件，CAS(r, r+1)\n      compareAndSetState(c, c + SHARED_UNIT)) {\n      //下面的逻辑就不说了，很简单\n      if (r == 0) {\n        firstReader = current;\n        firstReaderHoldCount = 1;\n      } else if (firstReader == current) {\n        firstReaderHoldCount++;\n      } else {\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current))\n          cachedHoldCounter = rh = readHolds.get();\n        else if (rh.count == 0)\n          readHolds.set(rh);\n        rh.count++;\n      }\n      return 1;\n    }\n    return fullTryAcquireShared(current);\n  }\n}\n```\n嗯，没错，方法`readerShouldBlock()`十分瞩目，几乎不用看上下文就定位到该方法。因为默认非公平锁，所以直接关注NonfairSync。\n``` Java\nstatic final class NonfairSync extends Sync {\n  final boolean writerShouldBlock() {\n      return false;\n  }\n  final boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n  }\n}\n//下面方法在ASQ中\nfinal boolean apparentlyFirstQueuedIsExclusive() {\n  Node h, s;\n  return (h = head) != null && //head非空\n      (s = h.next)  != null && //后续节点非空\n      !s.isShared()         && //后续节点是否为写线程\n      s.thread != null;        //后续节点线程非空\n}\n```\n`apparentlyFirstQueuedIsExclusive`什么作用，检查持锁线程head后续节点s是否为写锁，若真则返回true。结合`tryAcquireShared`的逻辑，如果true意味着读线程会被挂起无法共享锁。\n\n这好像就说得通了，当持锁的是读线程时，跟随其后的是一个写线程，那么再后面来的读线程是无法获取读锁的，只有等待写线程执行完后，才能竞争。\n\n这是jdk为了避免写线程过分饥渴，而做出的策略。但有坑点就是，如果某一读线程执行时间过长，甚至陷入死循环，后续线程会无限期挂起，严重程度堪比死锁。为避免这种情况，除了确保读线程不会有问题外，尽量用`tryLock`，超时我们可以做出响应。\n\n当然也可以自己实现ReentrantReadWriteLock的读写锁竞争策略，但还是算了吧，遇到读远多于写的场景时，写线程饥渴带来的麻烦更大，表示踩过坑，别介。\n","source":"_posts/20180702 -【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！.md","raw":"---\ntitle: 【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！\ndate: 2018-07-02 20:05:59\ntags:\n  - java　\n  - 并发编程\n  - 同步\n  - 读写锁\n  - 线程饥渴\ncategories:\n  - java并发编程\n---\n\n好长一段时间前，某些场景需要JUC的读写锁，但在某个时刻内读写线程都报超时预警（长时间无响应），看起来像是锁竞争过程中出现死锁（我猜）。经过排查项目并没有能造成死锁的可疑之处，因为业务代码并不复杂（仅仅是一个计算过程），经几番折腾，把注意力转移到JDK源码，正文详细说下ReentrantReadWriteLock的隐藏坑点。\n\n---\n\n过程大致如下：\n- 若干个读写线程抢占读写锁\n- 读线程手脚快，优先抢占到读锁（其中少数线程任务较重，执行时间较长）\n- 写线程随即尝试获取写锁，未成功，进入双列表进行等待\n- 随后读线程也进来了，要去拿读锁\n\n问题：优先得到锁的读线程执行时间长达73秒，该时段写线程等待是理所当然的，那读线程也应该能够得到读锁才对，因为是共享锁，是吧？但预警结果并不是如此，超时任务线程中大部分为读。究竟是什么让读线程无法抢占到读锁，而导致响应超时呢？\n\n把场景简化为如下的测试代码：读——写——读 线程依次尝试获取ReadWriteLock，用空转替换执行时间过长。\n\n执行结果：控制台仅打印出`Thread[读线程 -- 1,5,main]`，既是说`读线程 -- 2`并没有抢占到读锁，跟上诉的表现似乎一样。\n\n``` Java\npublic class ReadWriteLockTest {\n  public static void main(String[] args) {\n    ReadWriteLockTest readWriteLockTest = new ReadWriteLockTest();\n  }\n\n  public ReadWriteLockTest() {\n    try {\n      init();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }\n\n  void init() throws InterruptedException {\n    TestLock testLock = new TestLock();\n    Thread read1 = new Thread(new ReadThread(testLock), \"读线程 -- 1\");\n    read1.start();\n    Thread.sleep(100);\n    Thread write = new Thread(new WriteThread(testLock), \"写线程 -- 1\");\n    write.start();\n    Thread.sleep(100);\n    Thread read2 = new Thread(new ReadThread(testLock), \"读线程 -- 2\");\n    read2.start();\n  }\n\n  private class TestLock {\n\n    private String string = null;\n    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    private Lock readLock = readWriteLock.readLock();\n    private Lock writeLock = readWriteLock.writeLock();\n\n    public void set(String s) {\n      writeLock.lock();\n      try {\n//                writeLock.tryLock(10, TimeUnit.SECONDS);\n        string = s;\n      } finally {\n        writeLock.unlock();\n      }\n    }\n\n    public String getString() {\n      readLock.lock();\n      System.out.println(Thread.currentThread());\n      try {\n        while (true) {\n\n        }\n      } finally {\n        readLock.unlock();\n      }\n    }\n  }\n\n  class WriteThread implements Runnable {\n\n    private TestLock testLock;\n    public WriteThread(TestLock testLock) {\n      this.testLock = testLock;\n    }\n\n    @Override\n    public void run() {\n      testLock.set(\"射不进去，怎么办？\");\n    }\n  }\n\n  class ReadThread implements Runnable {\n\n    private TestLock testLock;\n    public ReadThread(TestLock testLock) {\n      this.testLock = testLock;\n    }\n\n    @Override\n    public void run() {\n      testLock.getString();\n    }\n  }\n}\n```\n我们用`jstack`查看一下线程，看到读线程2和写线程1确实处于WAITING的状态。\n\n![jstack](http://p4ygo03xz.bkt.clouddn.com/github-blog/image/jstack.png-50pencent)\n\n排查项目后，业务代码并没有问题，转而看下ReentrantReadWriteLock或AQS是否有什么问题被我忽略的。\n\n第一时间关注共享锁，因为独占锁的实现逻辑我确定很清晰了，很快我似乎看到自己想要的方法。\n``` Java\npublic static class ReadLock implements Lock, java.io.Serializable {\n  public void lock() {\n    //if(tryAcquireShared(arg) < 0) doAcquireShared(arg);\n    sync.acquireShared(1);\n  }\n}\nabstract static class Sync extends AbstractQueuedSynchronizer {\n  protected final int tryAcquireShared(int unused) {\n    Thread current = Thread.currentThread();\n    int c = getState();\n    //计算stata，若独占锁被占，且持有锁非本线程，返回-1等待挂起\n    if (exclusiveCount(c) != 0 &&\n      getExclusiveOwnerThread() != current)\n      return -1;\n    //计算获取共享锁的线程数\n    int r = sharedCount(c);\n    //readerShouldBlock检查读线程是否要阻塞\n    if (!readerShouldBlock() &&\n      //线程数必须少于65535\n      r < MAX_COUNT &&\n      //符合上诉两个条件，CAS(r, r+1)\n      compareAndSetState(c, c + SHARED_UNIT)) {\n      //下面的逻辑就不说了，很简单\n      if (r == 0) {\n        firstReader = current;\n        firstReaderHoldCount = 1;\n      } else if (firstReader == current) {\n        firstReaderHoldCount++;\n      } else {\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current))\n          cachedHoldCounter = rh = readHolds.get();\n        else if (rh.count == 0)\n          readHolds.set(rh);\n        rh.count++;\n      }\n      return 1;\n    }\n    return fullTryAcquireShared(current);\n  }\n}\n```\n嗯，没错，方法`readerShouldBlock()`十分瞩目，几乎不用看上下文就定位到该方法。因为默认非公平锁，所以直接关注NonfairSync。\n``` Java\nstatic final class NonfairSync extends Sync {\n  final boolean writerShouldBlock() {\n      return false;\n  }\n  final boolean readerShouldBlock() {\n    return apparentlyFirstQueuedIsExclusive();\n  }\n}\n//下面方法在ASQ中\nfinal boolean apparentlyFirstQueuedIsExclusive() {\n  Node h, s;\n  return (h = head) != null && //head非空\n      (s = h.next)  != null && //后续节点非空\n      !s.isShared()         && //后续节点是否为写线程\n      s.thread != null;        //后续节点线程非空\n}\n```\n`apparentlyFirstQueuedIsExclusive`什么作用，检查持锁线程head后续节点s是否为写锁，若真则返回true。结合`tryAcquireShared`的逻辑，如果true意味着读线程会被挂起无法共享锁。\n\n这好像就说得通了，当持锁的是读线程时，跟随其后的是一个写线程，那么再后面来的读线程是无法获取读锁的，只有等待写线程执行完后，才能竞争。\n\n这是jdk为了避免写线程过分饥渴，而做出的策略。但有坑点就是，如果某一读线程执行时间过长，甚至陷入死循环，后续线程会无限期挂起，严重程度堪比死锁。为避免这种情况，除了确保读线程不会有问题外，尽量用`tryLock`，超时我们可以做出响应。\n\n当然也可以自己实现ReentrantReadWriteLock的读写锁竞争策略，但还是算了吧，遇到读远多于写的场景时，写线程饥渴带来的麻烦更大，表示踩过坑，别介。\n","slug":"20180702 -【Java并发】JUC—ReentrantReadWriteLock有坑，小心读锁！","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7su002h4ejd9ngt0fez","content":"<p>好长一段时间前，某些场景需要JUC的读写锁，但在某个时刻内读写线程都报超时预警（长时间无响应），看起来像是锁竞争过程中出现死锁（我猜）。经过排查项目并没有能造成死锁的可疑之处，因为业务代码并不复杂（仅仅是一个计算过程），经几番折腾，把注意力转移到JDK源码，正文详细说下ReentrantReadWriteLock的隐藏坑点。</p>\n<hr>\n<p>过程大致如下：</p>\n<ul>\n<li>若干个读写线程抢占读写锁</li>\n<li>读线程手脚快，优先抢占到读锁（其中少数线程任务较重，执行时间较长）</li>\n<li>写线程随即尝试获取写锁，未成功，进入双列表进行等待</li>\n<li>随后读线程也进来了，要去拿读锁</li>\n</ul>\n<p>问题：优先得到锁的读线程执行时间长达73秒，该时段写线程等待是理所当然的，那读线程也应该能够得到读锁才对，因为是共享锁，是吧？但预警结果并不是如此，超时任务线程中大部分为读。究竟是什么让读线程无法抢占到读锁，而导致响应超时呢？</p>\n<p>把场景简化为如下的测试代码：读——写——读 线程依次尝试获取ReadWriteLock，用空转替换执行时间过长。</p>\n<p>执行结果：控制台仅打印出<code>Thread[读线程 -- 1,5,main]</code>，既是说<code>读线程 -- 2</code>并没有抢占到读锁，跟上诉的表现似乎一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadWriteLockTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ReadWriteLockTest readWriteLockTest = <span class=\"keyword\">new</span> ReadWriteLockTest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReadWriteLockTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      init();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    TestLock testLock = <span class=\"keyword\">new</span> TestLock();</span><br><span class=\"line\">    Thread read1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ReadThread(testLock), <span class=\"string\">\"读线程 -- 1\"</span>);</span><br><span class=\"line\">    read1.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> WriteThread(testLock), <span class=\"string\">\"写线程 -- 1\"</span>);</span><br><span class=\"line\">    write.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    Thread read2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ReadThread(testLock), <span class=\"string\">\"读线程 -- 2\"</span>);</span><br><span class=\"line\">    read2.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String string = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//                writeLock.tryLock(10, TimeUnit.SECONDS);</span></span><br><span class=\"line\">        string = s;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      System.out.println(Thread.currentThread());</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WriteThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestLock testLock;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WriteThread</span><span class=\"params\">(TestLock testLock)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.testLock = testLock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      testLock.set(<span class=\"string\">\"射不进去，怎么办？\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestLock testLock;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReadThread</span><span class=\"params\">(TestLock testLock)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.testLock = testLock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      testLock.getString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用<code>jstack</code>查看一下线程，看到读线程2和写线程1确实处于WAITING的状态。</p>\n<p><img src=\"http://p4ygo03xz.bkt.clouddn.com/github-blog/image/jstack.png-50pencent\" alt=\"jstack\"></p>\n<p>排查项目后，业务代码并没有问题，转而看下ReentrantReadWriteLock或AQS是否有什么问题被我忽略的。</p>\n<p>第一时间关注共享锁，因为独占锁的实现逻辑我确定很清晰了，很快我似乎看到自己想要的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if(tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);</span></span><br><span class=\"line\">    sync.acquireShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">    Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//计算stata，若独占锁被占，且持有锁非本线程，返回-1等待挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      getExclusiveOwnerThread() != current)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//计算获取共享锁的线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = sharedCount(c);</span><br><span class=\"line\">    <span class=\"comment\">//readerShouldBlock检查读线程是否要阻塞</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class=\"line\">      <span class=\"comment\">//线程数必须少于65535</span></span><br><span class=\"line\">      r &lt; MAX_COUNT &amp;&amp;</span><br><span class=\"line\">      <span class=\"comment\">//符合上诉两个条件，CAS(r, r+1)</span></span><br><span class=\"line\">      compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//下面的逻辑就不说了，很简单</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        firstReader = current;</span><br><span class=\"line\">        firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">        firstReaderHoldCount++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        HoldCounter rh = cachedHoldCounter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">          cachedHoldCounter = rh = readHolds.get();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          readHolds.set(rh);</span><br><span class=\"line\">        rh.count++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fullTryAcquireShared(current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，没错，方法<code>readerShouldBlock()</code>十分瞩目，几乎不用看上下文就定位到该方法。因为默认非公平锁，所以直接关注NonfairSync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//下面方法在ASQ中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">apparentlyFirstQueuedIsExclusive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Node h, s;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (h = head) != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"comment\">//head非空</span></span><br><span class=\"line\">      (s = h.next)  != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"comment\">//后续节点非空</span></span><br><span class=\"line\">      !s.isShared()         &amp;&amp; <span class=\"comment\">//后续节点是否为写线程</span></span><br><span class=\"line\">      s.thread != <span class=\"keyword\">null</span>;        <span class=\"comment\">//后续节点线程非空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>apparentlyFirstQueuedIsExclusive</code>什么作用，检查持锁线程head后续节点s是否为写锁，若真则返回true。结合<code>tryAcquireShared</code>的逻辑，如果true意味着读线程会被挂起无法共享锁。</p>\n<p>这好像就说得通了，当持锁的是读线程时，跟随其后的是一个写线程，那么再后面来的读线程是无法获取读锁的，只有等待写线程执行完后，才能竞争。</p>\n<p>这是jdk为了避免写线程过分饥渴，而做出的策略。但有坑点就是，如果某一读线程执行时间过长，甚至陷入死循环，后续线程会无限期挂起，严重程度堪比死锁。为避免这种情况，除了确保读线程不会有问题外，尽量用<code>tryLock</code>，超时我们可以做出响应。</p>\n<p>当然也可以自己实现ReentrantReadWriteLock的读写锁竞争策略，但还是算了吧，遇到读远多于写的场景时，写线程饥渴带来的麻烦更大，表示踩过坑，别介。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好长一段时间前，某些场景需要JUC的读写锁，但在某个时刻内读写线程都报超时预警（长时间无响应），看起来像是锁竞争过程中出现死锁（我猜）。经过排查项目并没有能造成死锁的可疑之处，因为业务代码并不复杂（仅仅是一个计算过程），经几番折腾，把注意力转移到JDK源码，正文详细说下ReentrantReadWriteLock的隐藏坑点。</p>\n<hr>\n<p>过程大致如下：</p>\n<ul>\n<li>若干个读写线程抢占读写锁</li>\n<li>读线程手脚快，优先抢占到读锁（其中少数线程任务较重，执行时间较长）</li>\n<li>写线程随即尝试获取写锁，未成功，进入双列表进行等待</li>\n<li>随后读线程也进来了，要去拿读锁</li>\n</ul>\n<p>问题：优先得到锁的读线程执行时间长达73秒，该时段写线程等待是理所当然的，那读线程也应该能够得到读锁才对，因为是共享锁，是吧？但预警结果并不是如此，超时任务线程中大部分为读。究竟是什么让读线程无法抢占到读锁，而导致响应超时呢？</p>\n<p>把场景简化为如下的测试代码：读——写——读 线程依次尝试获取ReadWriteLock，用空转替换执行时间过长。</p>\n<p>执行结果：控制台仅打印出<code>Thread[读线程 -- 1,5,main]</code>，既是说<code>读线程 -- 2</code>并没有抢占到读锁，跟上诉的表现似乎一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadWriteLockTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ReadWriteLockTest readWriteLockTest = <span class=\"keyword\">new</span> ReadWriteLockTest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReadWriteLockTest</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      init();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    TestLock testLock = <span class=\"keyword\">new</span> TestLock();</span><br><span class=\"line\">    Thread read1 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ReadThread(testLock), <span class=\"string\">\"读线程 -- 1\"</span>);</span><br><span class=\"line\">    read1.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    Thread write = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> WriteThread(testLock), <span class=\"string\">\"写线程 -- 1\"</span>);</span><br><span class=\"line\">    write.start();</span><br><span class=\"line\">    Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    Thread read2 = <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> ReadThread(testLock), <span class=\"string\">\"读线程 -- 2\"</span>);</span><br><span class=\"line\">    read2.start();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestLock</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String string = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">      writeLock.lock();</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//                writeLock.tryLock(10, TimeUnit.SECONDS);</span></span><br><span class=\"line\">        string = s;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        writeLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      readLock.lock();</span><br><span class=\"line\">      System.out.println(Thread.currentThread());</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        readLock.unlock();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WriteThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestLock testLock;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WriteThread</span><span class=\"params\">(TestLock testLock)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.testLock = testLock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      testLock.set(<span class=\"string\">\"射不进去，怎么办？\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadThread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TestLock testLock;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReadThread</span><span class=\"params\">(TestLock testLock)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.testLock = testLock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      testLock.getString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们用<code>jstack</code>查看一下线程，看到读线程2和写线程1确实处于WAITING的状态。</p>\n<p><img src=\"http://p4ygo03xz.bkt.clouddn.com/github-blog/image/jstack.png-50pencent\" alt=\"jstack\"></p>\n<p>排查项目后，业务代码并没有问题，转而看下ReentrantReadWriteLock或AQS是否有什么问题被我忽略的。</p>\n<p>第一时间关注共享锁，因为独占锁的实现逻辑我确定很清晰了，很快我似乎看到自己想要的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//if(tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);</span></span><br><span class=\"line\">    sync.acquireShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">    Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//计算stata，若独占锁被占，且持有锁非本线程，返回-1等待挂起</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exclusiveCount(c) != <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">      getExclusiveOwnerThread() != current)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//计算获取共享锁的线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> r = sharedCount(c);</span><br><span class=\"line\">    <span class=\"comment\">//readerShouldBlock检查读线程是否要阻塞</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class=\"line\">      <span class=\"comment\">//线程数必须少于65535</span></span><br><span class=\"line\">      r &lt; MAX_COUNT &amp;&amp;</span><br><span class=\"line\">      <span class=\"comment\">//符合上诉两个条件，CAS(r, r+1)</span></span><br><span class=\"line\">      compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//下面的逻辑就不说了，很简单</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (r == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        firstReader = current;</span><br><span class=\"line\">        firstReaderHoldCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (firstReader == current) &#123;</span><br><span class=\"line\">        firstReaderHoldCount++;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        HoldCounter rh = cachedHoldCounter;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rh == <span class=\"keyword\">null</span> || rh.tid != getThreadId(current))</span><br><span class=\"line\">          cachedHoldCounter = rh = readHolds.get();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (rh.count == <span class=\"number\">0</span>)</span><br><span class=\"line\">          readHolds.set(rh);</span><br><span class=\"line\">        rh.count++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fullTryAcquireShared(current);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯，没错，方法<code>readerShouldBlock()</code>十分瞩目，几乎不用看上下文就定位到该方法。因为默认非公平锁，所以直接关注NonfairSync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">writerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">readerShouldBlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//下面方法在ASQ中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">apparentlyFirstQueuedIsExclusive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Node h, s;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (h = head) != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"comment\">//head非空</span></span><br><span class=\"line\">      (s = h.next)  != <span class=\"keyword\">null</span> &amp;&amp; <span class=\"comment\">//后续节点非空</span></span><br><span class=\"line\">      !s.isShared()         &amp;&amp; <span class=\"comment\">//后续节点是否为写线程</span></span><br><span class=\"line\">      s.thread != <span class=\"keyword\">null</span>;        <span class=\"comment\">//后续节点线程非空</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>apparentlyFirstQueuedIsExclusive</code>什么作用，检查持锁线程head后续节点s是否为写锁，若真则返回true。结合<code>tryAcquireShared</code>的逻辑，如果true意味着读线程会被挂起无法共享锁。</p>\n<p>这好像就说得通了，当持锁的是读线程时，跟随其后的是一个写线程，那么再后面来的读线程是无法获取读锁的，只有等待写线程执行完后，才能竞争。</p>\n<p>这是jdk为了避免写线程过分饥渴，而做出的策略。但有坑点就是，如果某一读线程执行时间过长，甚至陷入死循环，后续线程会无限期挂起，严重程度堪比死锁。为避免这种情况，除了确保读线程不会有问题外，尽量用<code>tryLock</code>，超时我们可以做出响应。</p>\n<p>当然也可以自己实现ReentrantReadWriteLock的读写锁竞争策略，但还是算了吧，遇到读远多于写的场景时，写线程饥渴带来的麻烦更大，表示踩过坑，别介。</p>\n"},{"title":"【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）","date":"2018-02-27T12:28:55.000Z","_content":"\n平时开发不少使用`synchronized`，java提供了这个语法特性使用起来非常方便，但灵活性似乎不太好，因为它只是个独占且可重入锁，无法唤醒指定线程和实现共享等其他类型锁。\n\njdk提供了JUC这个并发包，里面就包含了功能更多的lock包，有ReentrantLock、ReentrantReadWriteLock等多功能锁，而实现这些锁的核心在于一个同步器AbstractQueuedSynchronizer（AQS）。\n\n我们从AQS开始分析，了解一下jdk提供的公平锁、非公平锁、共享锁、独占锁、读写锁分别是怎么实现的。\n\n---\n\n咱先来看下ReentrantLock怎么用的，语义上跟synchronized是一致的，不过lock()与unlock()需要成对存在。\n``` java\nprivate int count = 0;\npublic void task() {\n  Lock lock = new ReentrantLock();\n  lock.lock();\n  try {\n    for(int j = 0; j < 10; j++) {\n      count++;\n    }\n  } finally {\n    lock.unlock();\n  }\n}\n```\n这里看到lock()是调用了抽象内部类Sync的lock方法，具体实现在其子类FairSync、NonfairSync。\n``` java\npublic class ReentrantLock implements Lock, java.io.Serializable {\n  private final Sync sync;\n  public void lock() {\n    sync.lock();\n  }\n  abstract static class Sync extends AbstractQueuedSynchronizer {\n    abstract void lock();\n  }\n}\n```\n\n我们先来看一下ReentrantLock的公平锁怎么实现的，可以看到lock()只调用了acquire(1)，acquire是AQS的一个方法。\n``` java\nstatic final class FairSync extends Sync {\n  private static final long serialVersionUID = -3000897897090466540L;\n  final void lock() {\n      acquire(1);\n  }\n  protected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //如果c=0，则锁处于空闲状态\n    if (c == 0) {\n      //如果当前线程没有前节点的话，将cas state，成功则唤醒当前线程，返回true\n      if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n      }\n    }\n    //c非0，如果当前线程已经持有锁，则state + 1，返回true。再次已实现可重入性\n    else if (current == getExclusiveOwnerThread()) {\n      int nextc = c + acquires;\n      if (nextc < 0)\n        throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n  }\n}\n```\n\n先看一下AQS的acquire方法，每次调用都会去尝试获取锁，tryAcquire方法是个空方法，有子类做具体的实现。回头来看FairSync的实现。\n\n`current`是当前线程，先判断锁是非空闲；如果是，hasQueuedPredecessors再判断线程是否有前节点，没有则compareAndSetState将state设置为acquires。\n\n如果锁不是空闲状态，且当前线程是锁的持有人，则将state设置为state + acquires。在这一步已经实现了Lock的可重入性，线程进入lock()后，会判断当前线程是否已经持有锁，是的话将state加1.\n``` java\n//记录lock()被多少调用了几次，0表示空闲状态，大于0表示忙碌状态\nprivate volatile int state;\npublic final void acquire(int arg) {\n  //尝试获取锁，若失败，则进入等待队列;\n  //acquireQueued将线程挂起，挂起异常则selfInterrupt中断当前线程\n  if (!tryAcquire(arg) &&\n          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n      selfInterrupt();\n}\n//尝试获取锁\nprotected boolean tryAcquire(int arg) {\n  throw new UnsupportedOperationException();\n}\nprotected boolean tryRelease(int arg) {\n  throw new UnsupportedOperationException();\n}\n```\n\nOK！上面已经知道了Lock是怎么实现可重入性的，现在了解一下怎么管理抢占失败而被挂起的线程。\n\n看到AQS的内部类Node，即可知道是一个双链表，表头Head代表当前占有锁的线程，抢占失败的线程将被添加到尾部。\n![双链表](http://p4ygo03xz.bkt.clouddn.com/github-blog/image/AbstractQueuedSynchronizer-Node.png)\n\n可以看到Node都有类型和挂起状态，作用于实现各类锁。在上面的代码可以看到acquire方法中通过`addWaiter`方法将新节点添加到尾部的。\n``` java\nprivate transient volatile Node head;\nprivate transient volatile Node tail;\nstatic final class Node {\n  //共享类型\n  static final Node SHARED = new Node();\n  //独占类型\n  static final Node EXCLUSIVE = null;\n\n  //取消状态\n  static final int CANCELLED =  1;\n  //等待触发，即抢占不到锁被挂起；\n  //需要注意的事，head是锁的持有人，此时依然处于该状态，只有释放锁时waitStatus=0\n  static final int SIGNAL    = -1;\n  //等待条件符合，需要等待Condition的signal唤醒，Lock提供了newCondition()，作用跟Object的wait()与notify()是一样的\n  static final int CONDITION = -2;\n  //节点状态向后传递，在共享锁有用处\n  static final int PROPAGATE = -3;\n\n  //挂起的状态，aitStatus=0表明释放锁\n  volatile int waitStatus;\n  volatile Node prev;\n  volatile Node next;\n  volatile Thread thread;\n  //节点类型，是共享还是独占\n  Node nextWaiter;\n  final boolean isShared() {\n      return nextWaiter == SHARED;\n  }\n  final Node predecessor() throws NullPointerException {\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n  }\n  Node() {    // Used to establish initial head or SHARED marker\n  }\n  Node(Thread thread, Node mode) {     // Used by addWaiter\n    this.nextWaiter = mode;\n    this.thread = thread;\n  }\n  Node(Thread thread, int waitStatus) { // Used by Condition\n    this.waitStatus = waitStatus;\n    this.thread = thread;\n  }\n}\n```\n这里我看一下AQS是怎么把线程添加到链表的。将当前tail设置为pred，如果非空，把pred设置为当前node的前节点prev，再将node设置到成员变量tail。如果tail为null，说明此刻双链表未初始化，进去`enq`。\n``` java\nprivate Node addWaiter(Node mode) {\n  //创建当前线程为新节点\n  Node node = new Node(Thread.currentThread(), mode);\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    //如果此时tail没有被其他线程抢先修改，则当前节点成功添加到尾部\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  //若失败，循环直到成功\n  enq(node);\n  return node;\n}\nprivate Node enq(final Node node) {\n  for (;;) {\n    Node t = tail;\n    //此时链表为空，初始化双链表\n    //第一个成功抢占锁的线程是不会被添加到双链表的，所以第二个线程进来时tail是空的\n    if (t == null) {\n      if (compareAndSetHead(new Node())) //存在多线程同时修改head的情况\n        tail = head;\n    } else {\n      //如果此刻tail非空，将node添加到链表尾部，直到成功返回\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n```\n\n上面的代码只展示了线程如何变成一个Node被塞进链表末端的，至关重要的线程挂起则在下面`acquireQueued`方法。挂起线程最终会调用到`LockSupport.park`这个静态方法，而park又调用了`Unsafe.park`这个本地方法。\n\nacquireQueued的逻辑其实跟while里的wait是差不多的，一直在被无意义的循环，被挂起，直到当前节点被推到第二个节点，head结束后，被unpark唤醒后及时抢占锁(详见`unparkSuccessor`方法)\n\n``` java\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      //获取前节点，如果是表头则尝试获取锁\n      final Node p = node.predecessor();\n      if (p == head && tryAcquire(arg)) { //被挂起前最后一次挣扎，也许这时head已经完事了，就该轮到自己了\n        //若成功，则将当前节点设置为表头\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      //检查当前上一个节点是否应该被挂起\n      if (shouldParkAfterFailedAcquire(p, node) &&\n            //挂起线程以及检查是否中断\n            parkAndCheckInterrupt())\n        interrupted = true;\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n  int ws = pred.waitStatus;\n  //上一个节点还在等待中，则返回true，该节点也要乖乖在队列中等待\n  if (ws == Node.SIGNAL)\n    return true;\n  //把取消状态中的节点全部移除\n  if (ws > 0) {\n    do {\n      node.prev = pred = pred.prev;\n    } while (pred.waitStatus > 0);\n    pred.next = node;\n  } else {\n    //这一步没有理解明白，但应该是再一次重试获取，确保被挂起之前不能获取到锁，如果还是失败，下一轮循环将被挂起\n    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n  }\n  return false;\n}\n\n```\n\n嗯，好的，上面实在公平锁的分析，下面非公平锁只是比`FairSync`的lock()多了两句代码。调用lock的时候，不是跟公平锁一样乖乖到队列中等待，而是先重试抢占锁，把state设置1，将自己设为持有锁线程。如果lock失败了，还会在tryAcquire再一次抢占，再失败则进入等待队列。\n``` java\nstatic final class NonfairSync extends Sync {\n  private static final long serialVersionUID = 7316153563782823691L;\n\n  final void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n  }\n\n  protected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n  }\n}\n```\n\n最后来到释放锁，unlock()则是调用到AQS的release方法，tryRelease是AQS的空方法，具体实现在ReentrantLock内部类Sync。\n``` java\npublic final boolean release(int arg) {\n  //尝试释放锁，tryRelease具体实现需要关注子类\n  if (tryRelease(arg)) {\n    //如果head不为空，且未表明被标记已释放锁，则唤醒下一个节点\n    Node h = head;\n    if (h != null && h.waitStatus != 0)\n      //尝试唤醒下一个节点\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n\nprivate void unparkSuccessor(Node node) {\n  int ws = node.waitStatus;\n  if (ws < 0)\n    compareAndSetWaitStatus(node, ws, 0);\n  Node s = node.next;\n  if (s == null || s.waitStatus > 0) {\n    s = null;\n    //从尾部扫描，直到找到与head最近的一个等待线程\n    for (Node t = tail; t != null && t != node; t = t.prev)\n      if (t.waitStatus <= 0)\n        s = t;\n  }\n  //被唤醒的线程将在acquireQueued方法重新设置head，并把该节点从链表移除\n  if (s != null)\n    LockSupport.unpark(s.thread);\n}\n\n/*\n * ReentrantLock内部类Sync的实现\n */\nprotected final boolean tryRelease(int releases) {\n  int c = getState() - releases;\n  if (Thread.currentThread() != getExclusiveOwnerThread())\n    throw new IllegalMonitorStateException();\n  boolean free = false;\n  //当state=0是，说明锁已经处于空闲状态，将当前持有锁线程置空\n  if (c == 0) {\n    free = true;\n    setExclusiveOwnerThread(null);\n  }\n  setState(c);\n  return free;\n}\n```\n","source":"_posts/20180227-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（一）.md","raw":"---\ntitle: 【Java并发】JUC.lock包AbstractQueuedSynchronizer的源码分析（一）\ndate: 2018-02-27 20:28:55\ntags:\n  - java　\n  - 并发编程\n  - 同步\n  - 公平锁\n  - 非公平锁\n  - 可重入锁\n  - ReentrantLock\ncategories:\n    - java并发编程\n---\n\n平时开发不少使用`synchronized`，java提供了这个语法特性使用起来非常方便，但灵活性似乎不太好，因为它只是个独占且可重入锁，无法唤醒指定线程和实现共享等其他类型锁。\n\njdk提供了JUC这个并发包，里面就包含了功能更多的lock包，有ReentrantLock、ReentrantReadWriteLock等多功能锁，而实现这些锁的核心在于一个同步器AbstractQueuedSynchronizer（AQS）。\n\n我们从AQS开始分析，了解一下jdk提供的公平锁、非公平锁、共享锁、独占锁、读写锁分别是怎么实现的。\n\n---\n\n咱先来看下ReentrantLock怎么用的，语义上跟synchronized是一致的，不过lock()与unlock()需要成对存在。\n``` java\nprivate int count = 0;\npublic void task() {\n  Lock lock = new ReentrantLock();\n  lock.lock();\n  try {\n    for(int j = 0; j < 10; j++) {\n      count++;\n    }\n  } finally {\n    lock.unlock();\n  }\n}\n```\n这里看到lock()是调用了抽象内部类Sync的lock方法，具体实现在其子类FairSync、NonfairSync。\n``` java\npublic class ReentrantLock implements Lock, java.io.Serializable {\n  private final Sync sync;\n  public void lock() {\n    sync.lock();\n  }\n  abstract static class Sync extends AbstractQueuedSynchronizer {\n    abstract void lock();\n  }\n}\n```\n\n我们先来看一下ReentrantLock的公平锁怎么实现的，可以看到lock()只调用了acquire(1)，acquire是AQS的一个方法。\n``` java\nstatic final class FairSync extends Sync {\n  private static final long serialVersionUID = -3000897897090466540L;\n  final void lock() {\n      acquire(1);\n  }\n  protected final boolean tryAcquire(int acquires) {\n    //获取当前线程\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //如果c=0，则锁处于空闲状态\n    if (c == 0) {\n      //如果当前线程没有前节点的话，将cas state，成功则唤醒当前线程，返回true\n      if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n        setExclusiveOwnerThread(current);\n        return true;\n      }\n    }\n    //c非0，如果当前线程已经持有锁，则state + 1，返回true。再次已实现可重入性\n    else if (current == getExclusiveOwnerThread()) {\n      int nextc = c + acquires;\n      if (nextc < 0)\n        throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n  }\n}\n```\n\n先看一下AQS的acquire方法，每次调用都会去尝试获取锁，tryAcquire方法是个空方法，有子类做具体的实现。回头来看FairSync的实现。\n\n`current`是当前线程，先判断锁是非空闲；如果是，hasQueuedPredecessors再判断线程是否有前节点，没有则compareAndSetState将state设置为acquires。\n\n如果锁不是空闲状态，且当前线程是锁的持有人，则将state设置为state + acquires。在这一步已经实现了Lock的可重入性，线程进入lock()后，会判断当前线程是否已经持有锁，是的话将state加1.\n``` java\n//记录lock()被多少调用了几次，0表示空闲状态，大于0表示忙碌状态\nprivate volatile int state;\npublic final void acquire(int arg) {\n  //尝试获取锁，若失败，则进入等待队列;\n  //acquireQueued将线程挂起，挂起异常则selfInterrupt中断当前线程\n  if (!tryAcquire(arg) &&\n          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n      selfInterrupt();\n}\n//尝试获取锁\nprotected boolean tryAcquire(int arg) {\n  throw new UnsupportedOperationException();\n}\nprotected boolean tryRelease(int arg) {\n  throw new UnsupportedOperationException();\n}\n```\n\nOK！上面已经知道了Lock是怎么实现可重入性的，现在了解一下怎么管理抢占失败而被挂起的线程。\n\n看到AQS的内部类Node，即可知道是一个双链表，表头Head代表当前占有锁的线程，抢占失败的线程将被添加到尾部。\n![双链表](http://p4ygo03xz.bkt.clouddn.com/github-blog/image/AbstractQueuedSynchronizer-Node.png)\n\n可以看到Node都有类型和挂起状态，作用于实现各类锁。在上面的代码可以看到acquire方法中通过`addWaiter`方法将新节点添加到尾部的。\n``` java\nprivate transient volatile Node head;\nprivate transient volatile Node tail;\nstatic final class Node {\n  //共享类型\n  static final Node SHARED = new Node();\n  //独占类型\n  static final Node EXCLUSIVE = null;\n\n  //取消状态\n  static final int CANCELLED =  1;\n  //等待触发，即抢占不到锁被挂起；\n  //需要注意的事，head是锁的持有人，此时依然处于该状态，只有释放锁时waitStatus=0\n  static final int SIGNAL    = -1;\n  //等待条件符合，需要等待Condition的signal唤醒，Lock提供了newCondition()，作用跟Object的wait()与notify()是一样的\n  static final int CONDITION = -2;\n  //节点状态向后传递，在共享锁有用处\n  static final int PROPAGATE = -3;\n\n  //挂起的状态，aitStatus=0表明释放锁\n  volatile int waitStatus;\n  volatile Node prev;\n  volatile Node next;\n  volatile Thread thread;\n  //节点类型，是共享还是独占\n  Node nextWaiter;\n  final boolean isShared() {\n      return nextWaiter == SHARED;\n  }\n  final Node predecessor() throws NullPointerException {\n    Node p = prev;\n    if (p == null)\n        throw new NullPointerException();\n    else\n        return p;\n  }\n  Node() {    // Used to establish initial head or SHARED marker\n  }\n  Node(Thread thread, Node mode) {     // Used by addWaiter\n    this.nextWaiter = mode;\n    this.thread = thread;\n  }\n  Node(Thread thread, int waitStatus) { // Used by Condition\n    this.waitStatus = waitStatus;\n    this.thread = thread;\n  }\n}\n```\n这里我看一下AQS是怎么把线程添加到链表的。将当前tail设置为pred，如果非空，把pred设置为当前node的前节点prev，再将node设置到成员变量tail。如果tail为null，说明此刻双链表未初始化，进去`enq`。\n``` java\nprivate Node addWaiter(Node mode) {\n  //创建当前线程为新节点\n  Node node = new Node(Thread.currentThread(), mode);\n  Node pred = tail;\n  if (pred != null) {\n    node.prev = pred;\n    //如果此时tail没有被其他线程抢先修改，则当前节点成功添加到尾部\n    if (compareAndSetTail(pred, node)) {\n      pred.next = node;\n      return node;\n    }\n  }\n  //若失败，循环直到成功\n  enq(node);\n  return node;\n}\nprivate Node enq(final Node node) {\n  for (;;) {\n    Node t = tail;\n    //此时链表为空，初始化双链表\n    //第一个成功抢占锁的线程是不会被添加到双链表的，所以第二个线程进来时tail是空的\n    if (t == null) {\n      if (compareAndSetHead(new Node())) //存在多线程同时修改head的情况\n        tail = head;\n    } else {\n      //如果此刻tail非空，将node添加到链表尾部，直到成功返回\n      node.prev = t;\n      if (compareAndSetTail(t, node)) {\n        t.next = node;\n        return t;\n      }\n    }\n  }\n}\n```\n\n上面的代码只展示了线程如何变成一个Node被塞进链表末端的，至关重要的线程挂起则在下面`acquireQueued`方法。挂起线程最终会调用到`LockSupport.park`这个静态方法，而park又调用了`Unsafe.park`这个本地方法。\n\nacquireQueued的逻辑其实跟while里的wait是差不多的，一直在被无意义的循环，被挂起，直到当前节点被推到第二个节点，head结束后，被unpark唤醒后及时抢占锁(详见`unparkSuccessor`方法)\n\n``` java\n\nfinal boolean acquireQueued(final Node node, int arg) {\n  boolean failed = true;\n  try {\n    boolean interrupted = false;\n    for (;;) {\n      //获取前节点，如果是表头则尝试获取锁\n      final Node p = node.predecessor();\n      if (p == head && tryAcquire(arg)) { //被挂起前最后一次挣扎，也许这时head已经完事了，就该轮到自己了\n        //若成功，则将当前节点设置为表头\n        setHead(node);\n        p.next = null; // help GC\n        failed = false;\n        return interrupted;\n      }\n      //检查当前上一个节点是否应该被挂起\n      if (shouldParkAfterFailedAcquire(p, node) &&\n            //挂起线程以及检查是否中断\n            parkAndCheckInterrupt())\n        interrupted = true;\n    }\n  } finally {\n    if (failed)\n      cancelAcquire(node);\n  }\n}\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n  int ws = pred.waitStatus;\n  //上一个节点还在等待中，则返回true，该节点也要乖乖在队列中等待\n  if (ws == Node.SIGNAL)\n    return true;\n  //把取消状态中的节点全部移除\n  if (ws > 0) {\n    do {\n      node.prev = pred = pred.prev;\n    } while (pred.waitStatus > 0);\n    pred.next = node;\n  } else {\n    //这一步没有理解明白，但应该是再一次重试获取，确保被挂起之前不能获取到锁，如果还是失败，下一轮循环将被挂起\n    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n  }\n  return false;\n}\n\n```\n\n嗯，好的，上面实在公平锁的分析，下面非公平锁只是比`FairSync`的lock()多了两句代码。调用lock的时候，不是跟公平锁一样乖乖到队列中等待，而是先重试抢占锁，把state设置1，将自己设为持有锁线程。如果lock失败了，还会在tryAcquire再一次抢占，再失败则进入等待队列。\n``` java\nstatic final class NonfairSync extends Sync {\n  private static final long serialVersionUID = 7316153563782823691L;\n\n  final void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n  }\n\n  protected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n  }\n}\n```\n\n最后来到释放锁，unlock()则是调用到AQS的release方法，tryRelease是AQS的空方法，具体实现在ReentrantLock内部类Sync。\n``` java\npublic final boolean release(int arg) {\n  //尝试释放锁，tryRelease具体实现需要关注子类\n  if (tryRelease(arg)) {\n    //如果head不为空，且未表明被标记已释放锁，则唤醒下一个节点\n    Node h = head;\n    if (h != null && h.waitStatus != 0)\n      //尝试唤醒下一个节点\n      unparkSuccessor(h);\n    return true;\n  }\n  return false;\n}\n\nprivate void unparkSuccessor(Node node) {\n  int ws = node.waitStatus;\n  if (ws < 0)\n    compareAndSetWaitStatus(node, ws, 0);\n  Node s = node.next;\n  if (s == null || s.waitStatus > 0) {\n    s = null;\n    //从尾部扫描，直到找到与head最近的一个等待线程\n    for (Node t = tail; t != null && t != node; t = t.prev)\n      if (t.waitStatus <= 0)\n        s = t;\n  }\n  //被唤醒的线程将在acquireQueued方法重新设置head，并把该节点从链表移除\n  if (s != null)\n    LockSupport.unpark(s.thread);\n}\n\n/*\n * ReentrantLock内部类Sync的实现\n */\nprotected final boolean tryRelease(int releases) {\n  int c = getState() - releases;\n  if (Thread.currentThread() != getExclusiveOwnerThread())\n    throw new IllegalMonitorStateException();\n  boolean free = false;\n  //当state=0是，说明锁已经处于空闲状态，将当前持有锁线程置空\n  if (c == 0) {\n    free = true;\n    setExclusiveOwnerThread(null);\n  }\n  setState(c);\n  return free;\n}\n```\n","slug":"20180227-【Java并发】JUC-lock包AbstractQueuedSynchronizer的源码分析（一）","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sv002m4ejdfwsmfy6k","content":"<p>平时开发不少使用<code>synchronized</code>，java提供了这个语法特性使用起来非常方便，但灵活性似乎不太好，因为它只是个独占且可重入锁，无法唤醒指定线程和实现共享等其他类型锁。</p>\n<p>jdk提供了JUC这个并发包，里面就包含了功能更多的lock包，有ReentrantLock、ReentrantReadWriteLock等多功能锁，而实现这些锁的核心在于一个同步器AbstractQueuedSynchronizer（AQS）。</p>\n<p>我们从AQS开始分析，了解一下jdk提供的公平锁、非公平锁、共享锁、独占锁、读写锁分别是怎么实现的。</p>\n<hr>\n<p>咱先来看下ReentrantLock怎么用的，语义上跟synchronized是一致的，不过lock()与unlock()需要成对存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">task</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  lock.lock();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里看到lock()是调用了抽象内部类Sync的lock方法，具体实现在其子类FairSync、NonfairSync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看一下ReentrantLock的公平锁怎么实现的，可以看到lock()只调用了acquire(1)，acquire是AQS的一个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//如果c=0，则锁处于空闲状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果当前线程没有前节点的话，将cas state，成功则唤醒当前线程，返回true</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(current);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//c非0，如果当前线程已经持有锁，则state + 1，返回true。再次已实现可重入性</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看一下AQS的acquire方法，每次调用都会去尝试获取锁，tryAcquire方法是个空方法，有子类做具体的实现。回头来看FairSync的实现。</p>\n<p><code>current</code>是当前线程，先判断锁是非空闲；如果是，hasQueuedPredecessors再判断线程是否有前节点，没有则compareAndSetState将state设置为acquires。</p>\n<p>如果锁不是空闲状态，且当前线程是锁的持有人，则将state设置为state + acquires。在这一步已经实现了Lock的可重入性，线程进入lock()后，会判断当前线程是否已经持有锁，是的话将state加1.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//记录lock()被多少调用了几次，0表示空闲状态，大于0表示忙碌状态</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//尝试获取锁，若失败，则进入等待队列;</span></span><br><span class=\"line\">  <span class=\"comment\">//acquireQueued将线程挂起，挂起异常则selfInterrupt中断当前线程</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">      selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//尝试获取锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK！上面已经知道了Lock是怎么实现可重入性的，现在了解一下怎么管理抢占失败而被挂起的线程。</p>\n<p>看到AQS的内部类Node，即可知道是一个双链表，表头Head代表当前占有锁的线程，抢占失败的线程将被添加到尾部。<br><img src=\"http://p4ygo03xz.bkt.clouddn.com/github-blog/image/AbstractQueuedSynchronizer-Node.png\" alt=\"双链表\"></p>\n<p>可以看到Node都有类型和挂起状态，作用于实现各类锁。在上面的代码可以看到acquire方法中通过<code>addWaiter</code>方法将新节点添加到尾部的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//共享类型</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">  <span class=\"comment\">//独占类型</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//取消状态</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//等待触发，即抢占不到锁被挂起；</span></span><br><span class=\"line\">  <span class=\"comment\">//需要注意的事，head是锁的持有人，此时依然处于该状态，只有释放锁时waitStatus=0</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//等待条件符合，需要等待Condition的signal唤醒，Lock提供了newCondition()，作用跟Object的wait()与notify()是一样的</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//节点状态向后传递，在共享锁有用处</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//挂起的状态，aitStatus=0表明释放锁</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">  <span class=\"comment\">//节点类型，是共享还是独占</span></span><br><span class=\"line\">  Node nextWaiter;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">    Node p = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node() &#123;    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">// Used by Condition</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我看一下AQS是怎么把线程添加到链表的。将当前tail设置为pred，如果非空，把pred设置为当前node的前节点prev，再将node设置到成员变量tail。如果tail为null，说明此刻双链表未初始化，进去<code>enq</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建当前线程为新节点</span></span><br><span class=\"line\">  Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">  Node pred = tail;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    node.prev = pred;</span><br><span class=\"line\">    <span class=\"comment\">//如果此时tail没有被其他线程抢先修改，则当前节点成功添加到尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">      pred.next = node;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//若失败，循环直到成功</span></span><br><span class=\"line\">  enq(node);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"comment\">//此时链表为空，初始化双链表</span></span><br><span class=\"line\">    <span class=\"comment\">//第一个成功抢占锁的线程是不会被添加到双链表的，所以第二个线程进来时tail是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node())) <span class=\"comment\">//存在多线程同时修改head的情况</span></span><br><span class=\"line\">        tail = head;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果此刻tail非空，将node添加到链表尾部，直到成功返回</span></span><br><span class=\"line\">      node.prev = t;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">        t.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码只展示了线程如何变成一个Node被塞进链表末端的，至关重要的线程挂起则在下面<code>acquireQueued</code>方法。挂起线程最终会调用到<code>LockSupport.park</code>这个静态方法，而park又调用了<code>Unsafe.park</code>这个本地方法。</p>\n<p>acquireQueued的逻辑其实跟while里的wait是差不多的，一直在被无意义的循环，被挂起，直到当前节点被推到第二个节点，head结束后，被unpark唤醒后及时抢占锁(详见<code>unparkSuccessor</code>方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取前节点，如果是表头则尝试获取锁</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">//被挂起前最后一次挣扎，也许这时head已经完事了，就该轮到自己了</span></span><br><span class=\"line\">        <span class=\"comment\">//若成功，则将当前节点设置为表头</span></span><br><span class=\"line\">        setHead(node);</span><br><span class=\"line\">        p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">        failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//检查当前上一个节点是否应该被挂起</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">            <span class=\"comment\">//挂起线程以及检查是否中断</span></span><br><span class=\"line\">            parkAndCheckInterrupt())</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">      cancelAcquire(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">  <span class=\"comment\">//上一个节点还在等待中，则返回true，该节点也要乖乖在队列中等待</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">//把取消状态中的节点全部移除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      node.prev = pred = pred.prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    pred.next = node;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这一步没有理解明白，但应该是再一次重试获取，确保被挂起之前不能获取到锁，如果还是失败，下一轮循环将被挂起</span></span><br><span class=\"line\">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>嗯，好的，上面实在公平锁的分析，下面非公平锁只是比<code>FairSync</code>的lock()多了两句代码。调用lock的时候，不是跟公平锁一样乖乖到队列中等待，而是先重试抢占锁，把state设置1，将自己设为持有锁线程。如果lock失败了，还会在tryAcquire再一次抢占，再失败则进入等待队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后来到释放锁，unlock()则是调用到AQS的release方法，tryRelease是AQS的空方法，具体实现在ReentrantLock内部类Sync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//尝试释放锁，tryRelease具体实现需要关注子类</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果head不为空，且未表明被标记已释放锁，则唤醒下一个节点</span></span><br><span class=\"line\">    Node h = head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//尝试唤醒下一个节点</span></span><br><span class=\"line\">      unparkSuccessor(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\">  Node s = node.next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从尾部扫描，直到找到与head最近的一个等待线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        s = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//被唤醒的线程将在acquireQueued方法重新设置head，并把该节点从链表移除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ReentrantLock内部类Sync的实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">//当state=0是，说明锁已经处于空闲状态，将当前持有锁线程置空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setState(c);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>平时开发不少使用<code>synchronized</code>，java提供了这个语法特性使用起来非常方便，但灵活性似乎不太好，因为它只是个独占且可重入锁，无法唤醒指定线程和实现共享等其他类型锁。</p>\n<p>jdk提供了JUC这个并发包，里面就包含了功能更多的lock包，有ReentrantLock、ReentrantReadWriteLock等多功能锁，而实现这些锁的核心在于一个同步器AbstractQueuedSynchronizer（AQS）。</p>\n<p>我们从AQS开始分析，了解一下jdk提供的公平锁、非公平锁、共享锁、独占锁、读写锁分别是怎么实现的。</p>\n<hr>\n<p>咱先来看下ReentrantLock怎么用的，语义上跟synchronized是一致的，不过lock()与unlock()需要成对存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">task</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">  lock.lock();</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">      count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    lock.unlock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里看到lock()是调用了抽象内部类Sync的lock方法，具体实现在其子类FairSync、NonfairSync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.lock();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们先来看一下ReentrantLock的公平锁怎么实现的，可以看到lock()只调用了acquire(1)，acquire是AQS的一个方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">    <span class=\"comment\">//如果c=0，则锁处于空闲状态</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果当前线程没有前节点的话，将cas state，成功则唤醒当前线程，返回true</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">            compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(current);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//c非0，如果当前线程已经持有锁，则state + 1，返回true。再次已实现可重入性</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">        setState(nextc);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看一下AQS的acquire方法，每次调用都会去尝试获取锁，tryAcquire方法是个空方法，有子类做具体的实现。回头来看FairSync的实现。</p>\n<p><code>current</code>是当前线程，先判断锁是非空闲；如果是，hasQueuedPredecessors再判断线程是否有前节点，没有则compareAndSetState将state设置为acquires。</p>\n<p>如果锁不是空闲状态，且当前线程是锁的持有人，则将state设置为state + acquires。在这一步已经实现了Lock的可重入性，线程进入lock()后，会判断当前线程是否已经持有锁，是的话将state加1.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//记录lock()被多少调用了几次，0表示空闲状态，大于0表示忙碌状态</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//尝试获取锁，若失败，则进入等待队列;</span></span><br><span class=\"line\">  <span class=\"comment\">//acquireQueued将线程挂起，挂起异常则selfInterrupt中断当前线程</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">      selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//尝试获取锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK！上面已经知道了Lock是怎么实现可重入性的，现在了解一下怎么管理抢占失败而被挂起的线程。</p>\n<p>看到AQS的内部类Node，即可知道是一个双链表，表头Head代表当前占有锁的线程，抢占失败的线程将被添加到尾部。<br><img src=\"http://p4ygo03xz.bkt.clouddn.com/github-blog/image/AbstractQueuedSynchronizer-Node.png\" alt=\"双链表\"></p>\n<p>可以看到Node都有类型和挂起状态，作用于实现各类锁。在上面的代码可以看到acquire方法中通过<code>addWaiter</code>方法将新节点添加到尾部的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node head;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node tail;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//共享类型</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node SHARED = <span class=\"keyword\">new</span> Node();</span><br><span class=\"line\">  <span class=\"comment\">//独占类型</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Node EXCLUSIVE = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//取消状态</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED =  <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//等待触发，即抢占不到锁被挂起；</span></span><br><span class=\"line\">  <span class=\"comment\">//需要注意的事，head是锁的持有人，此时依然处于该状态，只有释放锁时waitStatus=0</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SIGNAL    = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//等待条件符合，需要等待Condition的signal唤醒，Lock提供了newCondition()，作用跟Object的wait()与notify()是一样的</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CONDITION = -<span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//节点状态向后传递，在共享锁有用处</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> PROPAGATE = -<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//挂起的状态，aitStatus=0表明释放锁</span></span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> waitStatus;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Node prev;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Node next;</span><br><span class=\"line\">  <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">  <span class=\"comment\">//节点类型，是共享还是独占</span></span><br><span class=\"line\">  Node nextWaiter;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isShared</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> nextWaiter == SHARED;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> Node <span class=\"title\">predecessor</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> NullPointerException </span>&#123;</span><br><span class=\"line\">    Node p = prev;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node() &#123;    <span class=\"comment\">// Used to establish initial head or SHARED marker</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node(Thread thread, Node mode) &#123;     <span class=\"comment\">// Used by addWaiter</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.nextWaiter = mode;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Node(Thread thread, <span class=\"keyword\">int</span> waitStatus) &#123; <span class=\"comment\">// Used by Condition</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.waitStatus = waitStatus;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = thread;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我看一下AQS是怎么把线程添加到链表的。将当前tail设置为pred，如果非空，把pred设置为当前node的前节点prev，再将node设置到成员变量tail。如果tail为null，说明此刻双链表未初始化，进去<code>enq</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//创建当前线程为新节点</span></span><br><span class=\"line\">  Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">  Node pred = tail;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    node.prev = pred;</span><br><span class=\"line\">    <span class=\"comment\">//如果此时tail没有被其他线程抢先修改，则当前节点成功添加到尾部</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">      pred.next = node;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//若失败，循环直到成功</span></span><br><span class=\"line\">  enq(node);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"comment\">//此时链表为空，初始化双链表</span></span><br><span class=\"line\">    <span class=\"comment\">//第一个成功抢占锁的线程是不会被添加到双链表的，所以第二个线程进来时tail是空的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node())) <span class=\"comment\">//存在多线程同时修改head的情况</span></span><br><span class=\"line\">        tail = head;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果此刻tail非空，将node添加到链表尾部，直到成功返回</span></span><br><span class=\"line\">      node.prev = t;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">        t.next = node;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码只展示了线程如何变成一个Node被塞进链表末端的，至关重要的线程挂起则在下面<code>acquireQueued</code>方法。挂起线程最终会调用到<code>LockSupport.park</code>这个静态方法，而park又调用了<code>Unsafe.park</code>这个本地方法。</p>\n<p>acquireQueued的逻辑其实跟while里的wait是差不多的，一直在被无意义的循环，被挂起，直到当前节点被推到第二个节点，head结束后，被unpark唤醒后及时抢占锁(详见<code>unparkSuccessor</code>方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取前节点，如果是表头则尝试获取锁</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class=\"comment\">//被挂起前最后一次挣扎，也许这时head已经完事了，就该轮到自己了</span></span><br><span class=\"line\">        <span class=\"comment\">//若成功，则将当前节点设置为表头</span></span><br><span class=\"line\">        setHead(node);</span><br><span class=\"line\">        p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">        failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//检查当前上一个节点是否应该被挂起</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">            <span class=\"comment\">//挂起线程以及检查是否中断</span></span><br><span class=\"line\">            parkAndCheckInterrupt())</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">      cancelAcquire(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">  <span class=\"comment\">//上一个节点还在等待中，则返回true，该节点也要乖乖在队列中等待</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">//把取消状态中的节点全部移除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">      node.prev = pred = pred.prev;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">    pred.next = node;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这一步没有理解明白，但应该是再一次重试获取，确保被挂起之前不能获取到锁，如果还是失败，下一轮循环将被挂起</span></span><br><span class=\"line\">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>嗯，好的，上面实在公平锁的分析，下面非公平锁只是比<code>FairSync</code>的lock()多了两句代码。调用lock的时候，不是跟公平锁一样乖乖到队列中等待，而是先重试抢占锁，把state设置1，将自己设为持有锁线程。如果lock失败了，还会在tryAcquire再一次抢占，再失败则进入等待队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后来到释放锁，unlock()则是调用到AQS的release方法，tryRelease是AQS的空方法，具体实现在ReentrantLock内部类Sync。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//尝试释放锁，tryRelease具体实现需要关注子类</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果head不为空，且未表明被标记已释放锁，则唤醒下一个节点</span></span><br><span class=\"line\">    Node h = head;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//尝试唤醒下一个节点</span></span><br><span class=\"line\">      unparkSuccessor(h);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unparkSuccessor</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ws = node.waitStatus;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ws &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    compareAndSetWaitStatus(node, ws, <span class=\"number\">0</span>);</span><br><span class=\"line\">  Node s = node.next;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span> || s.waitStatus &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//从尾部扫描，直到找到与head最近的一个等待线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node t = tail; t != <span class=\"keyword\">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (t.waitStatus &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        s = t;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//被唤醒的线程将在acquireQueued方法重新设置head，并把该节点从链表移除</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (s != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    LockSupport.unpark(s.thread);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ReentrantLock内部类Sync的实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  <span class=\"comment\">//当state=0是，说明锁已经处于空闲状态，将当前持有锁线程置空</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  setState(c);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"asynchttpclient源码分析-基于Netty的连接池实现","date":"2017-04-03T09:53:18.000Z","_content":"\n最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！\n\n---\n\n**这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。**\n\n由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。\n\n\n先上一个简单的例子，事实上使用起来也不复杂。\n``` java\npublic class HttpTest {\n    static AsyncHttpClient asyncHttpClient = Dsl\n            //实例化所有池和检测器\n            .asyncHttpClient(\n                    Dsl.config()\n                    .setMaxConnections(500)\n                    .setMaxConnectionsPerHost(50)\n                    .setPooledConnectionIdleTimeout(6000)\n                    .setConnectionTtl(500)\n                    .setIoThreadsCount(100)\n                    .setConnectTimeout(60000)\n                    .setUseNativeTransport(\n                            System.getProperty(\"os.name\").toLowerCase().indexOf(\"linux\") > 0));\n\n    public static void main(String[] args) throws Exception {\n        List<Param> params = new ArrayList<>();\n        params.add(new Param(\"keyfrom\", \"XXX\"));\n\n        asyncHttpClient\n                .prepareGet(\"http://fanyi.youdao.com/openapi.do\")\n                .addQueryParams(params)\n                //这里进入发送请求阶段\n                .execute()\n                .toCompletableFuture()\n                //超时报错，或请求异常，做容错处理，抛出一个Response\n                .exceptionally(t -> {\n                    return new Response() {...};\n                })\n                .thenAccept(rep -> System.out.println(\"RESPONSE BODY\" + rep.getResponseBody()));\n    }\n}\n```\n\n先看看`DefaultAsyncHttpClientConfig`类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。\n``` java\n// timeouts\n//连接超时\nprivate final int connectTimeout;\n//请求超时\nprivate final int requestTimeout;\n//读取超时，含于请求时间\nprivate final int readTimeout;\n//关闭Client前的静默时间\nprivate final int shutdownQuietPeriod;\n//关闭超时\nprivate final int shutdownTimeout;\n\n// keep-alive\nprivate final boolean keepAlive;\n//连接池空闲时间\nprivate final int pooledConnectionIdleTimeout;\n//定时清理空闲连接的时间\nprivate final int connectionPoolCleanerPeriod;\n//连接存活时间\nprivate final int connectionTtl;\n//最大连接数\nprivate final int maxConnections;\n//每个路由的最大连接数\nprivate final int maxConnectionsPerHost;\n//用于channel超时处理\nprivate final ChannelPool channelPool;\nprivate final KeepAliveStrategy keepAliveStrategy;\n\n\n// internals\nprivate final String threadPoolName;\nprivate final int httpClientCodecMaxInitialLineLength;\nprivate final int httpClientCodecMaxHeaderSize;\nprivate final int httpClientCodecMaxChunkSize;\nprivate final int chunkedFileChunkSize;\nprivate final int webSocketMaxBufferSize;\nprivate final int webSocketMaxFrameSize;\nprivate final Map<ChannelOption<Object>, Object> channelOptions;\n//时间轮询组类型\nprivate final EventLoopGroup eventLoopGroup;\n//是否用epoll，仅linux系统支持\nprivate final boolean useNativeTransport;\n//用于Timeout处理，建议用默认Netty的HashedWheelTimer\nprivate final Timer nettyTimer;\nprivate final ThreadFactory threadFactory;\nprivate final AdditionalChannelInitializer httpAdditionalChannelInitializer;\nprivate final AdditionalChannelInitializer wsAdditionalChannelInitializer;\nprivate final ResponseBodyPartFactory responseBodyPartFactory;\n//其实就是EventLoopGroup指定的线程数\nprivate final int ioThreadsCount;\n```\n\n就从这里开始，开头主要实例化`ChannelManager`和`NettyRequestSender`以及`Timer`三个重要组件，`NettyRequestSender`用于发送请求以及向`ChannelManager`索取channel使用权，`Timer`则负责另外两个组件给他的检测任务。\n``` java\npublic final class Dsl {\n  public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {\n    //默认客户端\n    return new DefaultAsyncHttpClient(configBuilder.build());\n  }\n  //...\n  //...\n}\n\npublic class DefaultAsyncHttpClient implements AsyncHttpClient {\n  private final AsyncHttpClientConfig config;\n  private final AtomicBoolean closed = new AtomicBoolean(false);\n  //Netty初始化的起点，Bootstrap与Channel池管理都在这里声明\n  private final ChannelManager channelManager;\n  //发送请求，以及向ChannelManager索取channel的使用权\n  private final NettyRequestSender requestSender;\n  private final boolean allowStopNettyTimer;\n  //定时做超时处理\n  private final Timer nettyTimer;\n\n  public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {\n\n    this.config = config;\n\n    allowStopNettyTimer = config.getNettyTimer() == null;\n    //默认使用HashedWheelTimer\n    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();\n    //下面两个是重点！！！\n    channelManager = new ChannelManager(config, nettyTimer);\n    requestSender = new NettyRequestSender(config, channelManager,nettyTimer, new AsyncHttpClientState(closed));\n    //给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器\n    channelManager.configureBootstraps(requestSender);\n  }\n  private Timer newNettyTimer() {\n    HashedWheelTimer timer = new HashedWheelTimer();\n    timer.start();\n    return timer;\n  }\n}\n```\n\n这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。\n``` java\npublic class ChannelManager {\n  private final AsyncHttpClientConfig config;\n  private final EventLoopGroup eventLoopGroup;\n  private final boolean allowReleaseEventLoopGroup;\n  private final Bootstrap httpBootstrap;\n  private final Bootstrap wsBootstrap;\n  private final long handshakeTimeout;\n  private final IOException tooManyConnections;\n  private final IOException tooManyConnectionsPerHost;\n\n  //定时清理不符合标准的channel\n  private final ChannelPool channelPool;\n  //netty自带的用于管理channel的管理器\n  private final ChannelGroup openChannels;\n  private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();\n  //是否开启最大总连接数\n  private final boolean maxTotalConnectionsEnabled;\n  //最大连接数\n  private final Semaphore freeChannels;\n  //是否开启每个路由最大连接数\n  private final boolean maxConnectionsPerHostEnabled;\n  //每个路由最大连接数\n  private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();\n\n  private AsyncHttpClientHandler wsHandler;\n\n  public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {\n\n    this.config = config;\n    //忽略一小段关于ssl的\n    //ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉\n    ChannelPool channelPool = config.getChannelPool();\n    if (channelPool == null) {\n        if (config.isKeepAlive()) {\n            //这是默认使用的，事实上多数场景不需要我们自己实现\n            channelPool = new DefaultChannelPool(config, nettyTimer);\n        } else {\n            channelPool = NoopChannelPool.INSTANCE;\n        }\n    }\n    this.channelPool = channelPool;\n\n    tooManyConnections = trimStackTrace(new TooManyConnectionsException(config.getMaxConnections()));\n    tooManyConnectionsPerHost = trimStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));\n    maxTotalConnectionsEnabled = config.getMaxConnections() > 0;\n    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;\n\n    if (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) {\n        //管理已经被实例化的channel\n        openChannels = new DefaultChannelGroup(\"asyncHttpClient\", GlobalEventExecutor.INSTANCE) {\n            //重写删除方法，因为删除channel时，需要释放信号量\n            @Override\n            public boolean remove(Object o) {\n                boolean removed = super.remove(o);\n                if (removed) {\n                    //释放总连接池的信号量\n                    if (maxTotalConnectionsEnabled)\n                        freeChannels.release();\n                    //释放路由连接池的信号量\n                    if (maxConnectionsPerHostEnabled) {\n                        Object partitionKey = channelId2PartitionKey.remove(Channel.class.cast(o));\n                        if (partitionKey != null) {\n                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);\n                            if (hostFreeChannels != null)\n                                hostFreeChannels.release();\n                        }\n                    }\n                }\n                return removed;\n            }\n        };\n        //信号量数为最大连接数\n        freeChannels = new Semaphore(config.getMaxConnections());\n    } else {\n        openChannels = new DefaultChannelGroup(\"asyncHttpClient\", GlobalEventExecutor.INSTANCE);\n        freeChannels = null;\n    }\n\n    handshakeTimeout = config.getHandshakeTimeout();\n\n    ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());\n    allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;\n    ChannelFactory<? extends Channel> channelFactory;\n    if (allowReleaseEventLoopGroup) {\n        //这个只能在linux下使用\n        if (config.isUseNativeTransport()) {\n            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);\n            channelFactory = getEpollSocketChannelFactory();\n        } else {\n            //通常默认走这个！\n            eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), //瞧！IO线程数就是时间轮询的线程数\n              threadFactory);\n            channelFactory = NioSocketChannelFactory.INSTANCE;\n        }\n    } else {\n        //...\n    }\n    //用于http请求的bootstrap\n    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);\n    //用于WebSocket请求的bootstrap\n    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);\n\n    httpBootstrap.option(ChannelOption.AUTO_READ, false);\n  }\n}\n```\n\n实例化完`ChannelManager`后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。\n``` java\npublic final class NettyRequestSender {\n  private final AsyncHttpClientConfig config;\n  private final ChannelManager channelManager;\n  private final Timer nettyTimer;\n  private final AsyncHttpClientState clientState;\n  private final NettyRequestFactory requestFactory;\n\n  public NettyRequestSender(AsyncHttpClientConfig config,//\n            ChannelManager channelManager,//\n            Timer nettyTimer,//\n            AsyncHttpClientState clientState) {\n      this.config = config;\n      this.channelManager = channelManager;\n      this.nettyTimer = nettyTimer;\n      this.clientState = clientState;\n      requestFactory = new NettyRequestFactory(config);\n  }\n}\n```\n\n再回来看看`ChannelManager`构造方法中使用的工厂方法`newBootstrap(channelFactory, eventLoopGroup, config)`，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！\n``` java\nprivate Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {\n    @SuppressWarnings(\"deprecation\")\n    Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory)\n            //客户端只有worker线程池，ServerBootstrap则需要boss和worker\n            .group(eventLoopGroup)\n            //设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化\n            .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)\n            //是否使用tcp的Nagle算法，文件传输可以选择使用\n            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())\n            //重复使用本地地址端口\n            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//\n            .option(ChannelOption.AUTO_CLOSE, false);\n    if (config.getConnectTimeout() > 0) {\n        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());\n    }\n    if (config.getSoLinger() >= 0) {\n        //就是一个设置延迟关闭时间的参数，用于保证数据发送完成\n        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());\n    }\n    if (config.getSoSndBuf() >= 0) {\n        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());\n    }\n    if (config.getSoRcvBuf() >= 0) {\n        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());\n    }\n    //自定义配置\n    for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {\n        bootstrap.option(entry.getKey(), entry.getValue());\n    }\n    return bootstrap;\n}\n\n//下面则是管道的配置\npublic void configureBootstraps(NettyRequestSender requestSender) {\n    //ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据\n    //我们自己获取数据后的核心业务逻辑，也在这里开始\n    final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);\n    wsHandler = new WebSocketHandler(config, this, requestSender);\n    final NoopHandler pinnedEntry = new NoopHandler();\n\n    httpBootstrap.handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline()//\n                    .addLast(PINNED_ENTRY, pinnedEntry)//\n                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//\n                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//\n                    .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//\n                    .addLast(AHC_HTTP_HANDLER, httpHandler);\n            if (config.getHttpAdditionalChannelInitializer() != null)\n                config.getHttpAdditionalChannelInitializer().initChannel(ch);\n        }\n    });\n\n    wsBootstrap.handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline()//\n                    .addLast(PINNED_ENTRY, pinnedEntry)//\n                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//\n                    .addLast(AHC_WS_HANDLER, wsHandler);\n            if (config.getWsAdditionalChannelInitializer() != null)\n                config.getWsAdditionalChannelInitializer().initChannel(ch);\n        }\n    });\n}\n```\n\n一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读`RequestBuilderBase`类。执行`execute()`方法，正式开始请求，往下看`DefaultAsyncHttpClient.executeRequest()`怎么创建连接的。\n``` java\npublic class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {\n  private final AsyncHttpClient client;\n  public ListenableFuture<Response> execute() {\n      return client.executeRequest(build(), new AsyncCompletionHandlerBase());\n  }\n}\n\npublic class DefaultAsyncHttpClient implements AsyncHttpClient {\n  @Override\n  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {\n      if (config.getRequestFilters().isEmpty()) {\n          return execute(request, handler);\n      } else {\n        //不考虑设置请求过滤器的情况\n      }\n  }\n  private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {\n      try {\n          //把请求参数，和读取数据后的回调一同塞给请求发送器\n          return requestSender.sendRequest(request, asyncHandler, null, false);\n      } catch (Exception e) {\n          asyncHandler.onThrowable(e);\n          return new ListenableFuture.CompletedFailure<>(e);\n      }\n  }\n}\n```\n\nOK～～上面列出`NettyRequestSender`需要什么参数，现在再来看看怎么做的？\n下面的方法中，重点关注`sendRequestWithNewChannel`，它包括了如何新建channel、连接，抢占信号量\n``` java\npublic <T> ListenableFuture<T> sendRequest(final Request request,//\n            final AsyncHandler<T> asyncHandler,//\n            NettyResponseFuture<T> future,//\n            boolean performingNextRequest) {\n    //...\n    ProxyServer proxyServer = getProxyServer(config, request);\n    //使用SSL代理或者ws\n    if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))\n        //暂时忽略另外两个创建连接的方式\n    else\n        //我们的例子用的是GET，所以执行该方法\n        return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);\n}\n\nprivate <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//\n            Request request,//\n            AsyncHandler<T> asyncHandler,//\n            NettyResponseFuture<T> future,//注意，这时候传进来是null\n            boolean performingNextRequest,//\n            ProxyServer proxyServer,//\n            boolean forceConnect) {\n    //把所有请求信息保证在一个响应回调对象里\n    NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);\n    //这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释\n    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);\n\n    if (Channels.isChannelValid(channel))\n        return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);\n    else\n        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);\n}\nprivate Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {\n    //future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel\n    if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel()))\n        return future.channel();\n    //视图在channelManager中找到可用对象\n    else\n        return pollPooledChannel(request, proxyServer, asyncHandler);\n}\n\nprivate <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {\n    if (asyncHandler instanceof AsyncHandlerExtensions)\n        AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);\n    //启动请求超时，在writeRequest中，会启动读取超时\n    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);\n    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());\n    future.setChannelState(ChannelState.POOLED);\n    future.attachChannel(channel, false);\n\n    Channels.setAttribute(channel, future);\n    if (Channels.isChannelValid(channel)) {\n        writeRequest(future, channel);\n    } else {\n        handleUnexpectedClosedChannel(channel, future);\n    }\n    return future;\n}\n//把这里当作一个请求连接的开始\nprivate <T> ListenableFuture<T> sendRequestWithNewChannel(//\n            Request request,//\n            ProxyServer proxy,//\n            NettyResponseFuture<T> future,//\n            AsyncHandler<T> asyncHandler,//\n            boolean performingNextRequest) {\n\n    Realm realm = future.getRealm();\n    Realm proxyRealm = future.getProxyRealm();\n    //...\n    //为做连接做准备\n    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);\n    //用于索取channel\n    Object partitionKey = future.getPartitionKey();\n    final boolean acquireChannelLock = !performingNextRequest;\n\n    try {\n        //抢占信号量\n        if (acquireChannelLock) {\n            channelManager.acquireChannelLock(partitionKey);\n        }\n    } catch (Throwable t) {\n        abort(null, future, getCause(t));\n        return future;\n    }\n    //开启请求超时定时器\n    scheduleRequestTimeout(future);\n    //域名解析\n    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)//\n            .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {\n                @Override\n                //域名解析后得到的IP地址列表\n                protected void onSuccess(List<InetSocketAddress> addresses) {\n                    NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, acquireChannelLock, partitionKey);\n                    //不要怀疑！这里开始连接了！！！\n                    NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);\n                    if (!future.isDone()) {\n                        connector.connect(bootstrap, connectListener);\n                    } else if (acquireChannelLock) {\n                        //如果future已经完成，则释放信号量\n                        channelManager.releaseChannelLock(partitionKey);\n                    }\n                }\n                @Override\n                protected void onFailure(Throwable cause) {\n                    //失败，释放信号\n                    if (acquireChannelLock) {\n                        channelManager.releaseChannelLock(partitionKey);\n                    }\n                    abort(null, future, getCause(cause));\n                }\n            });\n    return future;\n}\n```\n\n`NettyChannelConnector`负责对远程IP创建连接，一旦连接成功，`NettyConnectListener`就会调用requestSender向服务端发送数据。\n``` java\npublic class NettyChannelConnector {\n  public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {\n      //获取DNS后的IP地址\n      final InetSocketAddress remoteAddress = remoteAddresses.get(i);\n      if (asyncHandlerExtensions != null)\n          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);\n      try {\n          connect0(bootstrap, connectListener, remoteAddress);\n      } catch (RejectedExecutionException e) {\n          if (clientState.isClosed()) {\n              connectListener.onFailure(null, e);\n          }\n      }\n  }\n\n  private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {\n      bootstrap.connect(remoteAddress, localAddress)//\n              .addListener(new SimpleChannelFutureListener() {\n                  @Override\n                  public void onSuccess(Channel channel) {\n                      if (asyncHandlerExtensions != null) {\n                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);\n                      }\n                      //如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到\n                      if (connectionTtlEnabled) {\n                          Channels.initChannelId(channel);\n                      }\n                      connectListener.onSuccess(channel, remoteAddress);\n                  }\n                  @Override\n                  public void onFailure(Channel channel, Throwable t) {\n                      if (asyncHandlerExtensions != null)\n                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);\n                      //如果连接失败，则尝试连接下一个IP\n                      boolean retry = pickNextRemoteAddress();\n                      if (retry)\n                          NettyChannelConnector.this.connect(bootstrap, connectListener);\n                      else\n                          connectListener.onFailure(channel, t);\n                  }\n              });\n  }\n}\n```\n\n连接成功，就来到这里，拿到channel，准备向服务器发送数据！\n``` java\npublic final class NettyConnectListener<T> {\n  public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {\n\n      Channels.setInactiveToken(channel);\n      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();\n      if (futureIsAlreadyCancelled(channel)) {\n          return;\n      }\n      Request request = future.getTargetRequest();\n      Uri uri = request.getUri();\n      timeoutsHolder.initRemoteAddress(remoteAddress);\n\n      if (future.getProxyServer() == null && uri.isSecured()) {\n        //直接无视\n      } else {\n          writeRequest(channel);\n      }\n  }\n\n  private void writeRequest(Channel channel) {\n      if (futureIsAlreadyCancelled(channel)) {\n          return;\n      }\n      //在这设置属性，在读取服务器数据的httphandler里面有用到\n      Channels.setAttribute(channel, future);\n      //注册到ChannelGroup中\n      channelManager.registerOpenChannel(channel, partitionKey);\n      //设置为不复用channel\n      future.attachChannel(channel, false);\n      //发送请求数据\n      //这个方法就不贴上来了，没什么意思\n      //方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据\n      requestSender.writeRequest(future, channel);\n  }\n}\n```\n读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！\n``` java\npublic final class HttpHandler extends AsyncHttpClientHandler {\n  private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {\n      future.cancelTimeouts();\n      boolean keepAlive = future.isKeepAlive();\n      //这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法\n      if (expectOtherChunks && keepAlive)\n          channelManager.drainChannelAndOffer(channel, future);\n      else\n          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());\n      try {\n          future.done();\n      } catch (Exception t) {}\n  }\n}\n```\n\n**tryToOfferChannelToPool** 是`ChannelManager`的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！\n``` java\npublic final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {\n    //长连接，或者依然活跃的\n    if (channel.isActive() && keepAlive) {\n        //丢弃被设置的属性\n        Channels.setDiscard(channel);\n        if (asyncHandler instanceof AsyncHandlerExtensions)\n            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOffer(channel);\n            //尝试塞进pool里\n        if (channelPool.offer(channel, partitionKey)) {\n            if (maxConnectionsPerHostEnabled)\n                //我没明白这个映射到底是干嘛用的\n                channelId2PartitionKey.putIfAbsent(channel, partitionKey);\n        } else {\n          //被pool驳回，就直接关闭掉！！\n            closeChannel(channel);\n        }\n    } else {\n      //已经死亡或者不是长连接，直接关闭！！\n        closeChannel(channel);\n    }\n}\n```\n\n<font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 **ChannelGroup** 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 **ChannelGroup** 时已经将`remove(channel)`重写，可以倒回去看是不是已经释放了信号量，也可以看看 **ChannelGroup** 源码是不是在`add`时候添加了监听器。</font>\n\n不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 **ChannelPool** 进行生命的倒计时。\n``` java\npublic final class DefaultChannelPool implements ChannelPool {\n  private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();\n  private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;\n  private final AtomicBoolean isClosed = new AtomicBoolean(false);\n  private final Timer nettyTimer;\n  private final int connectionTtl;\n  private final boolean connectionTtlEnabled;\n  private final int maxIdleTime;\n  private final boolean maxIdleTimeEnabled;\n  private final long cleanerPeriod;\n  private final PoolLeaseStrategy poolLeaseStrategy;\n\n  public DefaultChannelPool(int maxIdleTime,//\n            int connectionTtl,//\n            PoolLeaseStrategy poolLeaseStrategy,//\n            Timer nettyTimer,//\n            int cleanerPeriod) {\n      this.maxIdleTime = maxIdleTime;\n      this.connectionTtl = connectionTtl;\n      connectionTtlEnabled = connectionTtl > 0;\n      channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;\n      this.nettyTimer = nettyTimer;\n      maxIdleTimeEnabled = maxIdleTime > 0;\n      this.poolLeaseStrategy = poolLeaseStrategy;\n      //在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的\n      this.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));\n      //如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测\n      if (connectionTtlEnabled || maxIdleTimeEnabled)\n          scheduleNewIdleChannelDetector(new IdleChannelDetector());\n  }\n\n  private void scheduleNewIdleChannelDetector(TimerTask task) {\n      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);\n  }\n\n  private final class IdleChannelDetector implements TimerTask {\n      //挖出已经不满足条件的channel\n      private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {\n          List<IdleChannel> idleTimeoutChannels = null;\n          for (IdleChannel idleChannel : partition) {\n              //空闲时间是否过期\n              boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);\n              //channel是否还活跃\n              boolean isRemotelyClosed = isRemotelyClosed(idleChannel.channel);\n              //存活时间是否过期\n              boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);\n              //满足其中一个条件，加入即将被关闭的channel队列\n              if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {\n                  if (idleTimeoutChannels == null)\n                      idleTimeoutChannels = new ArrayList<>(1);\n                  idleTimeoutChannels.add(idleChannel);\n              }\n          }\n          return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();\n      }\n      //关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列\n      private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {\n          List<IdleChannel> closedChannels = null;\n          for (int i = 0; i < candidates.size(); i++) {\n              IdleChannel idleChannel = candidates.get(i);\n              //如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中\n              if (idleChannel.takeOwnership()) {\n                  close(idleChannel.channel);\n                  if (closedChannels != null) {\n                      closedChannels.add(idleChannel);\n                  }\n              } //注意，这里只会被执行一次，closedChannels被实例化后不会再执行\n              else if (closedChannels == null) {\n                  closedChannels = new ArrayList<>(candidates.size());\n                  for (int j = 0; j < i; j++)\n                      closedChannels.add(candidates.get(j));\n              }\n          }\n          //如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回\n          //如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels\n          return closedChannels != null ? closedChannels : candidates;\n      }\n      public void run(Timeout timeout) throws Exception {\n          if (isClosed.get())\n              return;\n          //检测器的启动时间\n          long start = unpreciseMillisTime();\n          int closedCount = 0;\n          int totalCount = 0;\n          //遍历每个路由的被塞到ChannelPool的channel队列\n          for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {\n              List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));\n              //非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除\n              if (!closedChannels.isEmpty()) {\n                  if (connectionTtlEnabled) {\n                      for (IdleChannel closedChannel : closedChannels)\n                          channelId2Creation.remove(channelId(closedChannel.channel));\n                  }\n                  partition.removeAll(closedChannels);\n                  closedCount += closedChannels.size();\n              }\n          }\n          //退出并继续下一轮检测\n          scheduleNewIdleChannelDetector(timeout.task());\n      }\n  }\n\n  //存放空闲channel\n  private static final class IdleChannel {\n      final Channel channel;\n      final long start;\n      final AtomicBoolean owned = new AtomicBoolean(false);\n      IdleChannel(Channel channel, long start) {\n          this.channel = assertNotNull(channel, \"channel\");\n          this.start = start;\n      }\n      public boolean takeOwnership() {\n          return owned.compareAndSet(false, true);\n      }\n      @Override\n      public boolean equals(Object o) {...}\n      @Override\n      public int hashCode() {...}\n  }\n  //存放channel的创建时间\n  private static final class ChannelCreation {\n      final long creationTime;\n      final Object partitionKey;\n      ChannelCreation(long creationTime, Object partitionKey) {\n          this.creationTime = creationTime;\n          this.partitionKey = partitionKey;\n      }\n  }\n}\n```\n这里才是channel的终结！！！\n\nchannel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 **请求超时** 和 **读取超时**。\n每个`NettyResponseFuture`都持有一个`TimeoutsHolder`来计算 **requestTimeout** 和 **readTimeout** 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 **requestTimeout** 其实是包括了 **readTimeout**，如果请求剩余时间小于读取超时时间时，`startReadTimeout`是不会启动readTimeout定时器的。下面只贴上`TimeoutsHolder`的部分源码，`RequestTimeoutTimerTask`和`ReadTimeoutTimerTask`可以自行阅读。\n\n<font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font>\n``` java\npublic class TimeoutsHolder {\n  private final AtomicBoolean cancelled = new AtomicBoolean();\n\n  private final Timer nettyTimer;\n  private final NettyRequestSender requestSender;\n  private final long requestTimeoutMillisTime;\n  private final int readTimeoutValue;\n\n  private volatile NettyResponseFuture<?> nettyResponseFuture;\n  public final Timeout requestTimeout;\n  public volatile Timeout readTimeout;\n\n  public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config) {\n      this.nettyTimer = nettyTimer;\n      this.nettyResponseFuture = nettyResponseFuture;\n      this.requestSender = requestSender;\n      this.readTimeoutValue = config.getReadTimeout();\n      int requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();\n      //每个请求都可以独立设置请求超时时间\n      if (requestTimeoutInMs == 0) {\n          requestTimeoutInMs = config.getRequestTimeout();\n      }\n      if (requestTimeoutInMs != -1) {\n          //请求的到期时间，启动请求超时定时器\n          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;\n          requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);\n      } else {\n          requestTimeoutMillisTime = -1L;\n          requestTimeout = null;\n      }\n  }\n\n  public void startReadTimeout() {\n      if (readTimeoutValue != -1) {\n          startReadTimeout(null);\n      }\n  }\n  void startReadTimeout(ReadTimeoutTimerTask task) {\n      //如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间<请求剩余时间\n      if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {\n          if (task == null) {\n              task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);\n          }\n          Timeout readTimeout = newTimeout(task, readTimeoutValue);\n          this.readTimeout = readTimeout;\n      } else if (task != null) {\n          task.clean();\n      }\n  }\n}\n```\n\n最后最后最后。。。\n\n来总结一下ahc的连接池实现，很明显的一点整个过程都是对`Channel`的管理，而且对于连接的抢占则使用了`Semaphore`，这再方便不过了！！！对于信号量的释放，Netty的`ChannelGroup`有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的`HashedWheelTimer`，有机会专门来说说这一个。还有就是`DefaultChannelPool`对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。\n\n如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！\n","source":"_posts/20170403-asynchttpclient源码分析-基于Netty的连接池实现.md","raw":"---\ntitle: asynchttpclient源码分析-基于Netty的连接池实现\ndate: 2017-04-03 17:53:18\ntags:\n  - Netty\n  - 源码分析\n  - NIO\ncategories:\n  - Netty\n---\n\n最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！\n\n---\n\n**这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。**\n\n由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。\n\n\n先上一个简单的例子，事实上使用起来也不复杂。\n``` java\npublic class HttpTest {\n    static AsyncHttpClient asyncHttpClient = Dsl\n            //实例化所有池和检测器\n            .asyncHttpClient(\n                    Dsl.config()\n                    .setMaxConnections(500)\n                    .setMaxConnectionsPerHost(50)\n                    .setPooledConnectionIdleTimeout(6000)\n                    .setConnectionTtl(500)\n                    .setIoThreadsCount(100)\n                    .setConnectTimeout(60000)\n                    .setUseNativeTransport(\n                            System.getProperty(\"os.name\").toLowerCase().indexOf(\"linux\") > 0));\n\n    public static void main(String[] args) throws Exception {\n        List<Param> params = new ArrayList<>();\n        params.add(new Param(\"keyfrom\", \"XXX\"));\n\n        asyncHttpClient\n                .prepareGet(\"http://fanyi.youdao.com/openapi.do\")\n                .addQueryParams(params)\n                //这里进入发送请求阶段\n                .execute()\n                .toCompletableFuture()\n                //超时报错，或请求异常，做容错处理，抛出一个Response\n                .exceptionally(t -> {\n                    return new Response() {...};\n                })\n                .thenAccept(rep -> System.out.println(\"RESPONSE BODY\" + rep.getResponseBody()));\n    }\n}\n```\n\n先看看`DefaultAsyncHttpClientConfig`类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。\n``` java\n// timeouts\n//连接超时\nprivate final int connectTimeout;\n//请求超时\nprivate final int requestTimeout;\n//读取超时，含于请求时间\nprivate final int readTimeout;\n//关闭Client前的静默时间\nprivate final int shutdownQuietPeriod;\n//关闭超时\nprivate final int shutdownTimeout;\n\n// keep-alive\nprivate final boolean keepAlive;\n//连接池空闲时间\nprivate final int pooledConnectionIdleTimeout;\n//定时清理空闲连接的时间\nprivate final int connectionPoolCleanerPeriod;\n//连接存活时间\nprivate final int connectionTtl;\n//最大连接数\nprivate final int maxConnections;\n//每个路由的最大连接数\nprivate final int maxConnectionsPerHost;\n//用于channel超时处理\nprivate final ChannelPool channelPool;\nprivate final KeepAliveStrategy keepAliveStrategy;\n\n\n// internals\nprivate final String threadPoolName;\nprivate final int httpClientCodecMaxInitialLineLength;\nprivate final int httpClientCodecMaxHeaderSize;\nprivate final int httpClientCodecMaxChunkSize;\nprivate final int chunkedFileChunkSize;\nprivate final int webSocketMaxBufferSize;\nprivate final int webSocketMaxFrameSize;\nprivate final Map<ChannelOption<Object>, Object> channelOptions;\n//时间轮询组类型\nprivate final EventLoopGroup eventLoopGroup;\n//是否用epoll，仅linux系统支持\nprivate final boolean useNativeTransport;\n//用于Timeout处理，建议用默认Netty的HashedWheelTimer\nprivate final Timer nettyTimer;\nprivate final ThreadFactory threadFactory;\nprivate final AdditionalChannelInitializer httpAdditionalChannelInitializer;\nprivate final AdditionalChannelInitializer wsAdditionalChannelInitializer;\nprivate final ResponseBodyPartFactory responseBodyPartFactory;\n//其实就是EventLoopGroup指定的线程数\nprivate final int ioThreadsCount;\n```\n\n就从这里开始，开头主要实例化`ChannelManager`和`NettyRequestSender`以及`Timer`三个重要组件，`NettyRequestSender`用于发送请求以及向`ChannelManager`索取channel使用权，`Timer`则负责另外两个组件给他的检测任务。\n``` java\npublic final class Dsl {\n  public static AsyncHttpClient asyncHttpClient(DefaultAsyncHttpClientConfig.Builder configBuilder) {\n    //默认客户端\n    return new DefaultAsyncHttpClient(configBuilder.build());\n  }\n  //...\n  //...\n}\n\npublic class DefaultAsyncHttpClient implements AsyncHttpClient {\n  private final AsyncHttpClientConfig config;\n  private final AtomicBoolean closed = new AtomicBoolean(false);\n  //Netty初始化的起点，Bootstrap与Channel池管理都在这里声明\n  private final ChannelManager channelManager;\n  //发送请求，以及向ChannelManager索取channel的使用权\n  private final NettyRequestSender requestSender;\n  private final boolean allowStopNettyTimer;\n  //定时做超时处理\n  private final Timer nettyTimer;\n\n  public DefaultAsyncHttpClient(AsyncHttpClientConfig config) {\n\n    this.config = config;\n\n    allowStopNettyTimer = config.getNettyTimer() == null;\n    //默认使用HashedWheelTimer\n    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();\n    //下面两个是重点！！！\n    channelManager = new ChannelManager(config, nettyTimer);\n    requestSender = new NettyRequestSender(config, channelManager,nettyTimer, new AsyncHttpClientState(closed));\n    //给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器\n    channelManager.configureBootstraps(requestSender);\n  }\n  private Timer newNettyTimer() {\n    HashedWheelTimer timer = new HashedWheelTimer();\n    timer.start();\n    return timer;\n  }\n}\n```\n\n这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。\n``` java\npublic class ChannelManager {\n  private final AsyncHttpClientConfig config;\n  private final EventLoopGroup eventLoopGroup;\n  private final boolean allowReleaseEventLoopGroup;\n  private final Bootstrap httpBootstrap;\n  private final Bootstrap wsBootstrap;\n  private final long handshakeTimeout;\n  private final IOException tooManyConnections;\n  private final IOException tooManyConnectionsPerHost;\n\n  //定时清理不符合标准的channel\n  private final ChannelPool channelPool;\n  //netty自带的用于管理channel的管理器\n  private final ChannelGroup openChannels;\n  private final ConcurrentHashMap<Channel, Object> channelId2PartitionKey = new ConcurrentHashMap<>();\n  //是否开启最大总连接数\n  private final boolean maxTotalConnectionsEnabled;\n  //最大连接数\n  private final Semaphore freeChannels;\n  //是否开启每个路由最大连接数\n  private final boolean maxConnectionsPerHostEnabled;\n  //每个路由最大连接数\n  private final ConcurrentHashMap<Object, Semaphore> freeChannelsPerHost = new ConcurrentHashMap<>();\n\n  private AsyncHttpClientHandler wsHandler;\n\n  public ChannelManager(final AsyncHttpClientConfig config, Timer nettyTimer) {\n\n    this.config = config;\n    //忽略一小段关于ssl的\n    //ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉\n    ChannelPool channelPool = config.getChannelPool();\n    if (channelPool == null) {\n        if (config.isKeepAlive()) {\n            //这是默认使用的，事实上多数场景不需要我们自己实现\n            channelPool = new DefaultChannelPool(config, nettyTimer);\n        } else {\n            channelPool = NoopChannelPool.INSTANCE;\n        }\n    }\n    this.channelPool = channelPool;\n\n    tooManyConnections = trimStackTrace(new TooManyConnectionsException(config.getMaxConnections()));\n    tooManyConnectionsPerHost = trimStackTrace(new TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));\n    maxTotalConnectionsEnabled = config.getMaxConnections() > 0;\n    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() > 0;\n\n    if (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) {\n        //管理已经被实例化的channel\n        openChannels = new DefaultChannelGroup(\"asyncHttpClient\", GlobalEventExecutor.INSTANCE) {\n            //重写删除方法，因为删除channel时，需要释放信号量\n            @Override\n            public boolean remove(Object o) {\n                boolean removed = super.remove(o);\n                if (removed) {\n                    //释放总连接池的信号量\n                    if (maxTotalConnectionsEnabled)\n                        freeChannels.release();\n                    //释放路由连接池的信号量\n                    if (maxConnectionsPerHostEnabled) {\n                        Object partitionKey = channelId2PartitionKey.remove(Channel.class.cast(o));\n                        if (partitionKey != null) {\n                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);\n                            if (hostFreeChannels != null)\n                                hostFreeChannels.release();\n                        }\n                    }\n                }\n                return removed;\n            }\n        };\n        //信号量数为最大连接数\n        freeChannels = new Semaphore(config.getMaxConnections());\n    } else {\n        openChannels = new DefaultChannelGroup(\"asyncHttpClient\", GlobalEventExecutor.INSTANCE);\n        freeChannels = null;\n    }\n\n    handshakeTimeout = config.getHandshakeTimeout();\n\n    ThreadFactory threadFactory = config.getThreadFactory() != null ? config.getThreadFactory() : new DefaultThreadFactory(config.getThreadPoolName());\n    allowReleaseEventLoopGroup = config.getEventLoopGroup() == null;\n    ChannelFactory<? extends Channel> channelFactory;\n    if (allowReleaseEventLoopGroup) {\n        //这个只能在linux下使用\n        if (config.isUseNativeTransport()) {\n            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);\n            channelFactory = getEpollSocketChannelFactory();\n        } else {\n            //通常默认走这个！\n            eventLoopGroup = new NioEventLoopGroup(config.getIoThreadsCount(), //瞧！IO线程数就是时间轮询的线程数\n              threadFactory);\n            channelFactory = NioSocketChannelFactory.INSTANCE;\n        }\n    } else {\n        //...\n    }\n    //用于http请求的bootstrap\n    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);\n    //用于WebSocket请求的bootstrap\n    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);\n\n    httpBootstrap.option(ChannelOption.AUTO_READ, false);\n  }\n}\n```\n\n实例化完`ChannelManager`后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。\n``` java\npublic final class NettyRequestSender {\n  private final AsyncHttpClientConfig config;\n  private final ChannelManager channelManager;\n  private final Timer nettyTimer;\n  private final AsyncHttpClientState clientState;\n  private final NettyRequestFactory requestFactory;\n\n  public NettyRequestSender(AsyncHttpClientConfig config,//\n            ChannelManager channelManager,//\n            Timer nettyTimer,//\n            AsyncHttpClientState clientState) {\n      this.config = config;\n      this.channelManager = channelManager;\n      this.nettyTimer = nettyTimer;\n      this.clientState = clientState;\n      requestFactory = new NettyRequestFactory(config);\n  }\n}\n```\n\n再回来看看`ChannelManager`构造方法中使用的工厂方法`newBootstrap(channelFactory, eventLoopGroup, config)`，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！\n``` java\nprivate Bootstrap newBootstrap(ChannelFactory<? extends Channel> channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config) {\n    @SuppressWarnings(\"deprecation\")\n    Bootstrap bootstrap = new Bootstrap().channelFactory(channelFactory)\n            //客户端只有worker线程池，ServerBootstrap则需要boss和worker\n            .group(eventLoopGroup)\n            //设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化\n            .option(ChannelOption.ALLOCATOR, config.getAllocator() != null ? config.getAllocator() : ByteBufAllocator.DEFAULT)\n            //是否使用tcp的Nagle算法，文件传输可以选择使用\n            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())\n            //重复使用本地地址端口\n            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())//\n            .option(ChannelOption.AUTO_CLOSE, false);\n    if (config.getConnectTimeout() > 0) {\n        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());\n    }\n    if (config.getSoLinger() >= 0) {\n        //就是一个设置延迟关闭时间的参数，用于保证数据发送完成\n        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());\n    }\n    if (config.getSoSndBuf() >= 0) {\n        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());\n    }\n    if (config.getSoRcvBuf() >= 0) {\n        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());\n    }\n    //自定义配置\n    for (Entry<ChannelOption<Object>, Object> entry : config.getChannelOptions().entrySet()) {\n        bootstrap.option(entry.getKey(), entry.getValue());\n    }\n    return bootstrap;\n}\n\n//下面则是管道的配置\npublic void configureBootstraps(NettyRequestSender requestSender) {\n    //ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据\n    //我们自己获取数据后的核心业务逻辑，也在这里开始\n    final AsyncHttpClientHandler httpHandler = new HttpHandler(config, this, requestSender);\n    wsHandler = new WebSocketHandler(config, this, requestSender);\n    final NoopHandler pinnedEntry = new NoopHandler();\n\n    httpBootstrap.handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline()//\n                    .addLast(PINNED_ENTRY, pinnedEntry)//\n                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//\n                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())//\n                    .addLast(CHUNKED_WRITER_HANDLER, new ChunkedWriteHandler())//\n                    .addLast(AHC_HTTP_HANDLER, httpHandler);\n            if (config.getHttpAdditionalChannelInitializer() != null)\n                config.getHttpAdditionalChannelInitializer().initChannel(ch);\n        }\n    });\n\n    wsBootstrap.handler(new ChannelInitializer<Channel>() {\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            ChannelPipeline pipeline = ch.pipeline()//\n                    .addLast(PINNED_ENTRY, pinnedEntry)//\n                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())//\n                    .addLast(AHC_WS_HANDLER, wsHandler);\n            if (config.getWsAdditionalChannelInitializer() != null)\n                config.getWsAdditionalChannelInitializer().initChannel(ch);\n        }\n    });\n}\n```\n\n一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读`RequestBuilderBase`类。执行`execute()`方法，正式开始请求，往下看`DefaultAsyncHttpClient.executeRequest()`怎么创建连接的。\n``` java\npublic class BoundRequestBuilder extends RequestBuilderBase<BoundRequestBuilder> {\n  private final AsyncHttpClient client;\n  public ListenableFuture<Response> execute() {\n      return client.executeRequest(build(), new AsyncCompletionHandlerBase());\n  }\n}\n\npublic class DefaultAsyncHttpClient implements AsyncHttpClient {\n  @Override\n  public <T> ListenableFuture<T> executeRequest(Request request, AsyncHandler<T> handler) {\n      if (config.getRequestFilters().isEmpty()) {\n          return execute(request, handler);\n      } else {\n        //不考虑设置请求过滤器的情况\n      }\n  }\n  private <T> ListenableFuture<T> execute(Request request, final AsyncHandler<T> asyncHandler) {\n      try {\n          //把请求参数，和读取数据后的回调一同塞给请求发送器\n          return requestSender.sendRequest(request, asyncHandler, null, false);\n      } catch (Exception e) {\n          asyncHandler.onThrowable(e);\n          return new ListenableFuture.CompletedFailure<>(e);\n      }\n  }\n}\n```\n\nOK～～上面列出`NettyRequestSender`需要什么参数，现在再来看看怎么做的？\n下面的方法中，重点关注`sendRequestWithNewChannel`，它包括了如何新建channel、连接，抢占信号量\n``` java\npublic <T> ListenableFuture<T> sendRequest(final Request request,//\n            final AsyncHandler<T> asyncHandler,//\n            NettyResponseFuture<T> future,//\n            boolean performingNextRequest) {\n    //...\n    ProxyServer proxyServer = getProxyServer(config, request);\n    //使用SSL代理或者ws\n    if (proxyServer != null && (request.getUri().isSecured() || request.getUri().isWebSocket()) && !isConnectDone(request, future))\n        //暂时忽略另外两个创建连接的方式\n    else\n        //我们的例子用的是GET，所以执行该方法\n        return sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, false);\n}\n\nprivate <T> ListenableFuture<T> sendRequestWithCertainForceConnect(//\n            Request request,//\n            AsyncHandler<T> asyncHandler,//\n            NettyResponseFuture<T> future,//注意，这时候传进来是null\n            boolean performingNextRequest,//\n            ProxyServer proxyServer,//\n            boolean forceConnect) {\n    //把所有请求信息保证在一个响应回调对象里\n    NettyResponseFuture<T> newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);\n    //这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释\n    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);\n\n    if (Channels.isChannelValid(channel))\n        return sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);\n    else\n        return sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);\n}\nprivate Channel getOpenChannel(NettyResponseFuture<?> future, Request request, ProxyServer proxyServer, AsyncHandler<?> asyncHandler) {\n    //future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel\n    if (future != null && future.isReuseChannel() && Channels.isChannelValid(future.channel()))\n        return future.channel();\n    //视图在channelManager中找到可用对象\n    else\n        return pollPooledChannel(request, proxyServer, asyncHandler);\n}\n\nprivate <T> ListenableFuture<T> sendRequestWithOpenChannel(Request request, ProxyServer proxy, NettyResponseFuture<T> future, AsyncHandler<T> asyncHandler, Channel channel) {\n    if (asyncHandler instanceof AsyncHandlerExtensions)\n        AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionPooled(channel);\n    //启动请求超时，在writeRequest中，会启动读取超时\n    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);\n    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());\n    future.setChannelState(ChannelState.POOLED);\n    future.attachChannel(channel, false);\n\n    Channels.setAttribute(channel, future);\n    if (Channels.isChannelValid(channel)) {\n        writeRequest(future, channel);\n    } else {\n        handleUnexpectedClosedChannel(channel, future);\n    }\n    return future;\n}\n//把这里当作一个请求连接的开始\nprivate <T> ListenableFuture<T> sendRequestWithNewChannel(//\n            Request request,//\n            ProxyServer proxy,//\n            NettyResponseFuture<T> future,//\n            AsyncHandler<T> asyncHandler,//\n            boolean performingNextRequest) {\n\n    Realm realm = future.getRealm();\n    Realm proxyRealm = future.getProxyRealm();\n    //...\n    //为做连接做准备\n    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);\n    //用于索取channel\n    Object partitionKey = future.getPartitionKey();\n    final boolean acquireChannelLock = !performingNextRequest;\n\n    try {\n        //抢占信号量\n        if (acquireChannelLock) {\n            channelManager.acquireChannelLock(partitionKey);\n        }\n    } catch (Throwable t) {\n        abort(null, future, getCause(t));\n        return future;\n    }\n    //开启请求超时定时器\n    scheduleRequestTimeout(future);\n    //域名解析\n    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)//\n            .addListener(new SimpleFutureListener<List<InetSocketAddress>>() {\n                @Override\n                //域名解析后得到的IP地址列表\n                protected void onSuccess(List<InetSocketAddress> addresses) {\n                    NettyConnectListener<T> connectListener = new NettyConnectListener<>(future, NettyRequestSender.this, channelManager, acquireChannelLock, partitionKey);\n                    //不要怀疑！这里开始连接了！！！\n                    NettyChannelConnector connector = new NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);\n                    if (!future.isDone()) {\n                        connector.connect(bootstrap, connectListener);\n                    } else if (acquireChannelLock) {\n                        //如果future已经完成，则释放信号量\n                        channelManager.releaseChannelLock(partitionKey);\n                    }\n                }\n                @Override\n                protected void onFailure(Throwable cause) {\n                    //失败，释放信号\n                    if (acquireChannelLock) {\n                        channelManager.releaseChannelLock(partitionKey);\n                    }\n                    abort(null, future, getCause(cause));\n                }\n            });\n    return future;\n}\n```\n\n`NettyChannelConnector`负责对远程IP创建连接，一旦连接成功，`NettyConnectListener`就会调用requestSender向服务端发送数据。\n``` java\npublic class NettyChannelConnector {\n  public void connect(final Bootstrap bootstrap, final NettyConnectListener<?> connectListener) {\n      //获取DNS后的IP地址\n      final InetSocketAddress remoteAddress = remoteAddresses.get(i);\n      if (asyncHandlerExtensions != null)\n          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);\n      try {\n          connect0(bootstrap, connectListener, remoteAddress);\n      } catch (RejectedExecutionException e) {\n          if (clientState.isClosed()) {\n              connectListener.onFailure(null, e);\n          }\n      }\n  }\n\n  private void connect0(Bootstrap bootstrap, final NettyConnectListener<?> connectListener, InetSocketAddress remoteAddress) {\n      bootstrap.connect(remoteAddress, localAddress)//\n              .addListener(new SimpleChannelFutureListener() {\n                  @Override\n                  public void onSuccess(Channel channel) {\n                      if (asyncHandlerExtensions != null) {\n                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);\n                      }\n                      //如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到\n                      if (connectionTtlEnabled) {\n                          Channels.initChannelId(channel);\n                      }\n                      connectListener.onSuccess(channel, remoteAddress);\n                  }\n                  @Override\n                  public void onFailure(Channel channel, Throwable t) {\n                      if (asyncHandlerExtensions != null)\n                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);\n                      //如果连接失败，则尝试连接下一个IP\n                      boolean retry = pickNextRemoteAddress();\n                      if (retry)\n                          NettyChannelConnector.this.connect(bootstrap, connectListener);\n                      else\n                          connectListener.onFailure(channel, t);\n                  }\n              });\n  }\n}\n```\n\n连接成功，就来到这里，拿到channel，准备向服务器发送数据！\n``` java\npublic final class NettyConnectListener<T> {\n  public void onSuccess(Channel channel, InetSocketAddress remoteAddress) {\n\n      Channels.setInactiveToken(channel);\n      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();\n      if (futureIsAlreadyCancelled(channel)) {\n          return;\n      }\n      Request request = future.getTargetRequest();\n      Uri uri = request.getUri();\n      timeoutsHolder.initRemoteAddress(remoteAddress);\n\n      if (future.getProxyServer() == null && uri.isSecured()) {\n        //直接无视\n      } else {\n          writeRequest(channel);\n      }\n  }\n\n  private void writeRequest(Channel channel) {\n      if (futureIsAlreadyCancelled(channel)) {\n          return;\n      }\n      //在这设置属性，在读取服务器数据的httphandler里面有用到\n      Channels.setAttribute(channel, future);\n      //注册到ChannelGroup中\n      channelManager.registerOpenChannel(channel, partitionKey);\n      //设置为不复用channel\n      future.attachChannel(channel, false);\n      //发送请求数据\n      //这个方法就不贴上来了，没什么意思\n      //方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据\n      requestSender.writeRequest(future, channel);\n  }\n}\n```\n读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！\n``` java\npublic final class HttpHandler extends AsyncHttpClientHandler {\n  private void finishUpdate(final NettyResponseFuture<?> future, Channel channel, boolean expectOtherChunks) throws IOException {\n      future.cancelTimeouts();\n      boolean keepAlive = future.isKeepAlive();\n      //这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法\n      if (expectOtherChunks && keepAlive)\n          channelManager.drainChannelAndOffer(channel, future);\n      else\n          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());\n      try {\n          future.done();\n      } catch (Exception t) {}\n  }\n}\n```\n\n**tryToOfferChannelToPool** 是`ChannelManager`的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！\n``` java\npublic final void tryToOfferChannelToPool(Channel channel, AsyncHandler<?> asyncHandler, boolean keepAlive, Object partitionKey) {\n    //长连接，或者依然活跃的\n    if (channel.isActive() && keepAlive) {\n        //丢弃被设置的属性\n        Channels.setDiscard(channel);\n        if (asyncHandler instanceof AsyncHandlerExtensions)\n            AsyncHandlerExtensions.class.cast(asyncHandler).onConnectionOffer(channel);\n            //尝试塞进pool里\n        if (channelPool.offer(channel, partitionKey)) {\n            if (maxConnectionsPerHostEnabled)\n                //我没明白这个映射到底是干嘛用的\n                channelId2PartitionKey.putIfAbsent(channel, partitionKey);\n        } else {\n          //被pool驳回，就直接关闭掉！！\n            closeChannel(channel);\n        }\n    } else {\n      //已经死亡或者不是长连接，直接关闭！！\n        closeChannel(channel);\n    }\n}\n```\n\n<font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 **ChannelGroup** 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 **ChannelGroup** 时已经将`remove(channel)`重写，可以倒回去看是不是已经释放了信号量，也可以看看 **ChannelGroup** 源码是不是在`add`时候添加了监听器。</font>\n\n不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 **ChannelPool** 进行生命的倒计时。\n``` java\npublic final class DefaultChannelPool implements ChannelPool {\n  private final ConcurrentHashMap<Object, ConcurrentLinkedDeque<IdleChannel>> partitions = new ConcurrentHashMap<>();\n  private final ConcurrentHashMap<ChannelId, ChannelCreation> channelId2Creation;\n  private final AtomicBoolean isClosed = new AtomicBoolean(false);\n  private final Timer nettyTimer;\n  private final int connectionTtl;\n  private final boolean connectionTtlEnabled;\n  private final int maxIdleTime;\n  private final boolean maxIdleTimeEnabled;\n  private final long cleanerPeriod;\n  private final PoolLeaseStrategy poolLeaseStrategy;\n\n  public DefaultChannelPool(int maxIdleTime,//\n            int connectionTtl,//\n            PoolLeaseStrategy poolLeaseStrategy,//\n            Timer nettyTimer,//\n            int cleanerPeriod) {\n      this.maxIdleTime = maxIdleTime;\n      this.connectionTtl = connectionTtl;\n      connectionTtlEnabled = connectionTtl > 0;\n      channelId2Creation = connectionTtlEnabled ? new ConcurrentHashMap<>() : null;\n      this.nettyTimer = nettyTimer;\n      maxIdleTimeEnabled = maxIdleTime > 0;\n      this.poolLeaseStrategy = poolLeaseStrategy;\n      //在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的\n      this.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));\n      //如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测\n      if (connectionTtlEnabled || maxIdleTimeEnabled)\n          scheduleNewIdleChannelDetector(new IdleChannelDetector());\n  }\n\n  private void scheduleNewIdleChannelDetector(TimerTask task) {\n      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);\n  }\n\n  private final class IdleChannelDetector implements TimerTask {\n      //挖出已经不满足条件的channel\n      private List<IdleChannel> expiredChannels(ConcurrentLinkedDeque<IdleChannel> partition, long now) {\n          List<IdleChannel> idleTimeoutChannels = null;\n          for (IdleChannel idleChannel : partition) {\n              //空闲时间是否过期\n              boolean isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);\n              //channel是否还活跃\n              boolean isRemotelyClosed = isRemotelyClosed(idleChannel.channel);\n              //存活时间是否过期\n              boolean isTtlExpired = isTtlExpired(idleChannel.channel, now);\n              //满足其中一个条件，加入即将被关闭的channel队列\n              if (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) {\n                  if (idleTimeoutChannels == null)\n                      idleTimeoutChannels = new ArrayList<>(1);\n                  idleTimeoutChannels.add(idleChannel);\n              }\n          }\n          return idleTimeoutChannels != null ? idleTimeoutChannels : Collections.<IdleChannel> emptyList();\n      }\n      //关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列\n      private List<IdleChannel> closeChannels(List<IdleChannel> candidates) {\n          List<IdleChannel> closedChannels = null;\n          for (int i = 0; i < candidates.size(); i++) {\n              IdleChannel idleChannel = candidates.get(i);\n              //如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中\n              if (idleChannel.takeOwnership()) {\n                  close(idleChannel.channel);\n                  if (closedChannels != null) {\n                      closedChannels.add(idleChannel);\n                  }\n              } //注意，这里只会被执行一次，closedChannels被实例化后不会再执行\n              else if (closedChannels == null) {\n                  closedChannels = new ArrayList<>(candidates.size());\n                  for (int j = 0; j < i; j++)\n                      closedChannels.add(candidates.get(j));\n              }\n          }\n          //如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回\n          //如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels\n          return closedChannels != null ? closedChannels : candidates;\n      }\n      public void run(Timeout timeout) throws Exception {\n          if (isClosed.get())\n              return;\n          //检测器的启动时间\n          long start = unpreciseMillisTime();\n          int closedCount = 0;\n          int totalCount = 0;\n          //遍历每个路由的被塞到ChannelPool的channel队列\n          for (ConcurrentLinkedDeque<IdleChannel> partition : partitions.values()) {\n              List<IdleChannel> closedChannels = closeChannels(expiredChannels(partition, start));\n              //非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除\n              if (!closedChannels.isEmpty()) {\n                  if (connectionTtlEnabled) {\n                      for (IdleChannel closedChannel : closedChannels)\n                          channelId2Creation.remove(channelId(closedChannel.channel));\n                  }\n                  partition.removeAll(closedChannels);\n                  closedCount += closedChannels.size();\n              }\n          }\n          //退出并继续下一轮检测\n          scheduleNewIdleChannelDetector(timeout.task());\n      }\n  }\n\n  //存放空闲channel\n  private static final class IdleChannel {\n      final Channel channel;\n      final long start;\n      final AtomicBoolean owned = new AtomicBoolean(false);\n      IdleChannel(Channel channel, long start) {\n          this.channel = assertNotNull(channel, \"channel\");\n          this.start = start;\n      }\n      public boolean takeOwnership() {\n          return owned.compareAndSet(false, true);\n      }\n      @Override\n      public boolean equals(Object o) {...}\n      @Override\n      public int hashCode() {...}\n  }\n  //存放channel的创建时间\n  private static final class ChannelCreation {\n      final long creationTime;\n      final Object partitionKey;\n      ChannelCreation(long creationTime, Object partitionKey) {\n          this.creationTime = creationTime;\n          this.partitionKey = partitionKey;\n      }\n  }\n}\n```\n这里才是channel的终结！！！\n\nchannel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 **请求超时** 和 **读取超时**。\n每个`NettyResponseFuture`都持有一个`TimeoutsHolder`来计算 **requestTimeout** 和 **readTimeout** 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 **requestTimeout** 其实是包括了 **readTimeout**，如果请求剩余时间小于读取超时时间时，`startReadTimeout`是不会启动readTimeout定时器的。下面只贴上`TimeoutsHolder`的部分源码，`RequestTimeoutTimerTask`和`ReadTimeoutTimerTask`可以自行阅读。\n\n<font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font>\n``` java\npublic class TimeoutsHolder {\n  private final AtomicBoolean cancelled = new AtomicBoolean();\n\n  private final Timer nettyTimer;\n  private final NettyRequestSender requestSender;\n  private final long requestTimeoutMillisTime;\n  private final int readTimeoutValue;\n\n  private volatile NettyResponseFuture<?> nettyResponseFuture;\n  public final Timeout requestTimeout;\n  public volatile Timeout readTimeout;\n\n  public TimeoutsHolder(Timer nettyTimer, NettyResponseFuture<?> nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config) {\n      this.nettyTimer = nettyTimer;\n      this.nettyResponseFuture = nettyResponseFuture;\n      this.requestSender = requestSender;\n      this.readTimeoutValue = config.getReadTimeout();\n      int requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();\n      //每个请求都可以独立设置请求超时时间\n      if (requestTimeoutInMs == 0) {\n          requestTimeoutInMs = config.getRequestTimeout();\n      }\n      if (requestTimeoutInMs != -1) {\n          //请求的到期时间，启动请求超时定时器\n          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;\n          requestTimeout = newTimeout(new RequestTimeoutTimerTask(nettyResponseFuture, requestSender, this, requestTimeoutInMs), requestTimeoutInMs);\n      } else {\n          requestTimeoutMillisTime = -1L;\n          requestTimeout = null;\n      }\n  }\n\n  public void startReadTimeout() {\n      if (readTimeoutValue != -1) {\n          startReadTimeout(null);\n      }\n  }\n  void startReadTimeout(ReadTimeoutTimerTask task) {\n      //如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间<请求剩余时间\n      if (requestTimeout == null || (!requestTimeout.isExpired() && readTimeoutValue < (requestTimeoutMillisTime - unpreciseMillisTime()))) {\n          if (task == null) {\n              task = new ReadTimeoutTimerTask(nettyResponseFuture, requestSender, this, readTimeoutValue);\n          }\n          Timeout readTimeout = newTimeout(task, readTimeoutValue);\n          this.readTimeout = readTimeout;\n      } else if (task != null) {\n          task.clean();\n      }\n  }\n}\n```\n\n最后最后最后。。。\n\n来总结一下ahc的连接池实现，很明显的一点整个过程都是对`Channel`的管理，而且对于连接的抢占则使用了`Semaphore`，这再方便不过了！！！对于信号量的释放，Netty的`ChannelGroup`有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的`HashedWheelTimer`，有机会专门来说说这一个。还有就是`DefaultChannelPool`对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。\n\n如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！\n","slug":"20170403-asynchttpclient源码分析-基于Netty的连接池实现","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7sw002p4ejdfefg0oj8","content":"<p>最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！</p>\n<hr>\n<p><strong>这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。</strong></p>\n<p>由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。</p>\n<p>先上一个简单的例子，事实上使用起来也不复杂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AsyncHttpClient asyncHttpClient = Dsl</span><br><span class=\"line\">            <span class=\"comment\">//实例化所有池和检测器</span></span><br><span class=\"line\">            .asyncHttpClient(</span><br><span class=\"line\">                    Dsl.config()</span><br><span class=\"line\">                    .setMaxConnections(<span class=\"number\">500</span>)</span><br><span class=\"line\">                    .setMaxConnectionsPerHost(<span class=\"number\">50</span>)</span><br><span class=\"line\">                    .setPooledConnectionIdleTimeout(<span class=\"number\">6000</span>)</span><br><span class=\"line\">                    .setConnectionTtl(<span class=\"number\">500</span>)</span><br><span class=\"line\">                    .setIoThreadsCount(<span class=\"number\">100</span>)</span><br><span class=\"line\">                    .setConnectTimeout(<span class=\"number\">60000</span>)</span><br><span class=\"line\">                    .setUseNativeTransport(</span><br><span class=\"line\">                            System.getProperty(<span class=\"string\">\"os.name\"</span>).toLowerCase().indexOf(<span class=\"string\">\"linux\"</span>) &gt; <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;Param&gt; params = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"keyword\">new</span> Param(<span class=\"string\">\"keyfrom\"</span>, <span class=\"string\">\"XXX\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncHttpClient</span><br><span class=\"line\">                .prepareGet(<span class=\"string\">\"http://fanyi.youdao.com/openapi.do\"</span>)</span><br><span class=\"line\">                .addQueryParams(params)</span><br><span class=\"line\">                <span class=\"comment\">//这里进入发送请求阶段</span></span><br><span class=\"line\">                .execute()</span><br><span class=\"line\">                .toCompletableFuture()</span><br><span class=\"line\">                <span class=\"comment\">//超时报错，或请求异常，做容错处理，抛出一个Response</span></span><br><span class=\"line\">                .exceptionally(t -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response() &#123;...&#125;;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .thenAccept(rep -&gt; System.out.println(<span class=\"string\">\"RESPONSE BODY\"</span> + rep.getResponseBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看看<code>DefaultAsyncHttpClientConfig</code>类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// timeouts</span></span><br><span class=\"line\"><span class=\"comment\">//连接超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectTimeout;</span><br><span class=\"line\"><span class=\"comment\">//请求超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestTimeout;</span><br><span class=\"line\"><span class=\"comment\">//读取超时，含于请求时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeout;</span><br><span class=\"line\"><span class=\"comment\">//关闭Client前的静默时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> shutdownQuietPeriod;</span><br><span class=\"line\"><span class=\"comment\">//关闭超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> shutdownTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// keep-alive</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> keepAlive;</span><br><span class=\"line\"><span class=\"comment\">//连接池空闲时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pooledConnectionIdleTimeout;</span><br><span class=\"line\"><span class=\"comment\">//定时清理空闲连接的时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionPoolCleanerPeriod;</span><br><span class=\"line\"><span class=\"comment\">//连接存活时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionTtl;</span><br><span class=\"line\"><span class=\"comment\">//最大连接数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConnections;</span><br><span class=\"line\"><span class=\"comment\">//每个路由的最大连接数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConnectionsPerHost;</span><br><span class=\"line\"><span class=\"comment\">//用于channel超时处理</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelPool channelPool;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> KeepAliveStrategy keepAliveStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// internals</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String threadPoolName;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxInitialLineLength;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxHeaderSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxChunkSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> chunkedFileChunkSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> webSocketMaxBufferSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> webSocketMaxFrameSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;Object&gt;, Object&gt; channelOptions;</span><br><span class=\"line\"><span class=\"comment\">//时间轮询组类型</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventLoopGroup eventLoopGroup;</span><br><span class=\"line\"><span class=\"comment\">//是否用epoll，仅linux系统支持</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> useNativeTransport;</span><br><span class=\"line\"><span class=\"comment\">//用于Timeout处理，建议用默认Netty的HashedWheelTimer</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadFactory threadFactory;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AdditionalChannelInitializer httpAdditionalChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AdditionalChannelInitializer wsAdditionalChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ResponseBodyPartFactory responseBodyPartFactory;</span><br><span class=\"line\"><span class=\"comment\">//其实就是EventLoopGroup指定的线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ioThreadsCount;</span><br></pre></td></tr></table></figure>\n\n<p>就从这里开始，开头主要实例化<code>ChannelManager</code>和<code>NettyRequestSender</code>以及<code>Timer</code>三个重要组件，<code>NettyRequestSender</code>用于发送请求以及向<code>ChannelManager</code>索取channel使用权，<code>Timer</code>则负责另外两个组件给他的检测任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dsl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AsyncHttpClient <span class=\"title\">asyncHttpClient</span><span class=\"params\">(DefaultAsyncHttpClientConfig.Builder configBuilder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认客户端</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultAsyncHttpClient(configBuilder.build());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAsyncHttpClient</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHttpClient</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean closed = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"comment\">//Netty初始化的起点，Bootstrap与Channel池管理都在这里声明</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelManager channelManager;</span><br><span class=\"line\">  <span class=\"comment\">//发送请求，以及向ChannelManager索取channel的使用权</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestSender requestSender;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowStopNettyTimer;</span><br><span class=\"line\">  <span class=\"comment\">//定时做超时处理</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultAsyncHttpClient</span><span class=\"params\">(AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\"></span><br><span class=\"line\">    allowStopNettyTimer = config.getNettyTimer() == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//默认使用HashedWheelTimer</span></span><br><span class=\"line\">    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();</span><br><span class=\"line\">    <span class=\"comment\">//下面两个是重点！！！</span></span><br><span class=\"line\">    channelManager = <span class=\"keyword\">new</span> ChannelManager(config, nettyTimer);</span><br><span class=\"line\">    requestSender = <span class=\"keyword\">new</span> NettyRequestSender(config, channelManager,nettyTimer, <span class=\"keyword\">new</span> AsyncHttpClientState(closed));</span><br><span class=\"line\">    <span class=\"comment\">//给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器</span></span><br><span class=\"line\">    channelManager.configureBootstraps(requestSender);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> Timer <span class=\"title\">newNettyTimer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HashedWheelTimer timer = <span class=\"keyword\">new</span> HashedWheelTimer();</span><br><span class=\"line\">    timer.start();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChannelManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventLoopGroup eventLoopGroup;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowReleaseEventLoopGroup;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Bootstrap httpBootstrap;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Bootstrap wsBootstrap;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> handshakeTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IOException tooManyConnections;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IOException tooManyConnectionsPerHost;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//定时清理不符合标准的channel</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelPool channelPool;</span><br><span class=\"line\">  <span class=\"comment\">//netty自带的用于管理channel的管理器</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelGroup openChannels;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Channel, Object&gt; channelId2PartitionKey = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//是否开启最大总连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxTotalConnectionsEnabled;</span><br><span class=\"line\">  <span class=\"comment\">//最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore freeChannels;</span><br><span class=\"line\">  <span class=\"comment\">//是否开启每个路由最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxConnectionsPerHostEnabled;</span><br><span class=\"line\">  <span class=\"comment\">//每个路由最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Object, Semaphore&gt; freeChannelsPerHost = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> AsyncHttpClientHandler wsHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChannelManager</span><span class=\"params\">(<span class=\"keyword\">final</span> AsyncHttpClientConfig config, Timer nettyTimer)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">    <span class=\"comment\">//忽略一小段关于ssl的</span></span><br><span class=\"line\">    <span class=\"comment\">//ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉</span></span><br><span class=\"line\">    ChannelPool channelPool = config.getChannelPool();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channelPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config.isKeepAlive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这是默认使用的，事实上多数场景不需要我们自己实现</span></span><br><span class=\"line\">            channelPool = <span class=\"keyword\">new</span> DefaultChannelPool(config, nettyTimer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            channelPool = NoopChannelPool.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channelPool = channelPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    tooManyConnections = trimStackTrace(<span class=\"keyword\">new</span> TooManyConnectionsException(config.getMaxConnections()));</span><br><span class=\"line\">    tooManyConnectionsPerHost = trimStackTrace(<span class=\"keyword\">new</span> TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));</span><br><span class=\"line\">    maxTotalConnectionsEnabled = config.getMaxConnections() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//管理已经被实例化的channel</span></span><br><span class=\"line\">        openChannels = <span class=\"keyword\">new</span> DefaultChannelGroup(<span class=\"string\">\"asyncHttpClient\"</span>, GlobalEventExecutor.INSTANCE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//重写删除方法，因为删除channel时，需要释放信号量</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">super</span>.remove(o);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (removed) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放总连接池的信号量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (maxTotalConnectionsEnabled)</span><br><span class=\"line\">                        freeChannels.release();</span><br><span class=\"line\">                    <span class=\"comment\">//释放路由连接池的信号量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (maxConnectionsPerHostEnabled) &#123;</span><br><span class=\"line\">                        Object partitionKey = channelId2PartitionKey.remove(Channel<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">o</span>))</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (partitionKey != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hostFreeChannels != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hostFreeChannels.release();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//信号量数为最大连接数</span></span><br><span class=\"line\">        freeChannels = <span class=\"keyword\">new</span> Semaphore(config.getMaxConnections());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        openChannels = <span class=\"keyword\">new</span> DefaultChannelGroup(<span class=\"string\">\"asyncHttpClient\"</span>, GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\">        freeChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handshakeTimeout = config.getHandshakeTimeout();</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadFactory threadFactory = config.getThreadFactory() != <span class=\"keyword\">null</span> ? config.getThreadFactory() : <span class=\"keyword\">new</span> DefaultThreadFactory(config.getThreadPoolName());</span><br><span class=\"line\">    allowReleaseEventLoopGroup = config.getEventLoopGroup() == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    ChannelFactory&lt;? extends Channel&gt; channelFactory;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowReleaseEventLoopGroup) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个只能在linux下使用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config.isUseNativeTransport()) &#123;</span><br><span class=\"line\">            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);</span><br><span class=\"line\">            channelFactory = getEpollSocketChannelFactory();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通常默认走这个！</span></span><br><span class=\"line\">            eventLoopGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(config.getIoThreadsCount(), <span class=\"comment\">//瞧！IO线程数就是时间轮询的线程数</span></span><br><span class=\"line\">              threadFactory);</span><br><span class=\"line\">            channelFactory = NioSocketChannelFactory.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于http请求的bootstrap</span></span><br><span class=\"line\">    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class=\"line\">    <span class=\"comment\">//用于WebSocket请求的bootstrap</span></span><br><span class=\"line\">    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class=\"line\"></span><br><span class=\"line\">    httpBootstrap.option(ChannelOption.AUTO_READ, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例化完<code>ChannelManager</code>后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyRequestSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelManager channelManager;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientState clientState;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestFactory requestFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NettyRequestSender</span><span class=\"params\">(AsyncHttpClientConfig config,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ChannelManager channelManager,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Timer nettyTimer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHttpClientState clientState)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.channelManager = channelManager;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.clientState = clientState;</span><br><span class=\"line\">      requestFactory = <span class=\"keyword\">new</span> NettyRequestFactory(config);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回来看看<code>ChannelManager</code>构造方法中使用的工厂方法<code>newBootstrap(channelFactory, eventLoopGroup, config)</code>，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bootstrap <span class=\"title\">newBootstrap</span><span class=\"params\">(ChannelFactory&lt;? extends Channel&gt; channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"deprecation\"</span>)</span><br><span class=\"line\">    Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap().channelFactory(channelFactory)</span><br><span class=\"line\">            <span class=\"comment\">//客户端只有worker线程池，ServerBootstrap则需要boss和worker</span></span><br><span class=\"line\">            .group(eventLoopGroup)</span><br><span class=\"line\">            <span class=\"comment\">//设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化</span></span><br><span class=\"line\">            .option(ChannelOption.ALLOCATOR, config.getAllocator() != <span class=\"keyword\">null</span> ? config.getAllocator() : ByteBufAllocator.DEFAULT)</span><br><span class=\"line\">            <span class=\"comment\">//是否使用tcp的Nagle算法，文件传输可以选择使用</span></span><br><span class=\"line\">            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())</span><br><span class=\"line\">            <span class=\"comment\">//重复使用本地地址端口</span></span><br><span class=\"line\">            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())<span class=\"comment\">//</span></span><br><span class=\"line\">            .option(ChannelOption.AUTO_CLOSE, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getConnectTimeout() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoLinger() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//就是一个设置延迟关闭时间的参数，用于保证数据发送完成</span></span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoSndBuf() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoRcvBuf() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//自定义配置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;ChannelOption&lt;Object&gt;, Object&gt; entry : config.getChannelOptions().entrySet()) &#123;</span><br><span class=\"line\">        bootstrap.option(entry.getKey(), entry.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bootstrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面则是管道的配置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configureBootstraps</span><span class=\"params\">(NettyRequestSender requestSender)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据</span></span><br><span class=\"line\">    <span class=\"comment\">//我们自己获取数据后的核心业务逻辑，也在这里开始</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> AsyncHttpClientHandler httpHandler = <span class=\"keyword\">new</span> HttpHandler(config, <span class=\"keyword\">this</span>, requestSender);</span><br><span class=\"line\">    wsHandler = <span class=\"keyword\">new</span> WebSocketHandler(config, <span class=\"keyword\">this</span>, requestSender);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> NoopHandler pinnedEntry = <span class=\"keyword\">new</span> NoopHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">    httpBootstrap.handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            ChannelPipeline pipeline = ch.pipeline()<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(CHUNKED_WRITER_HANDLER, <span class=\"keyword\">new</span> ChunkedWriteHandler())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(AHC_HTTP_HANDLER, httpHandler);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (config.getHttpAdditionalChannelInitializer() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                config.getHttpAdditionalChannelInitializer().initChannel(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wsBootstrap.handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            ChannelPipeline pipeline = ch.pipeline()<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(AHC_WS_HANDLER, wsHandler);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (config.getWsAdditionalChannelInitializer() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                config.getWsAdditionalChannelInitializer().initChannel(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读<code>RequestBuilderBase</code>类。执行<code>execute()</code>方法，正式开始请求，往下看<code>DefaultAsyncHttpClient.executeRequest()</code>怎么创建连接的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundRequestBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RequestBuilderBase</span>&lt;<span class=\"title\">BoundRequestBuilder</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClient client;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ListenableFuture&lt;Response&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> client.executeRequest(build(), <span class=\"keyword\">new</span> AsyncCompletionHandlerBase());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAsyncHttpClient</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHttpClient</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">executeRequest</span><span class=\"params\">(Request request, AsyncHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (config.getRequestFilters().isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> execute(request, handler);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不考虑设置请求过滤器的情况</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">(Request request, <span class=\"keyword\">final</span> AsyncHandler&lt;T&gt; asyncHandler)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//把请求参数，和读取数据后的回调一同塞给请求发送器</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> requestSender.sendRequest(request, asyncHandler, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          asyncHandler.onThrowable(e);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListenableFuture.CompletedFailure&lt;&gt;(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK～～上面列出<code>NettyRequestSender</code>需要什么参数，现在再来看看怎么做的？<br>下面的方法中，重点关注<code>sendRequestWithNewChannel</code>，它包括了如何新建channel、连接，抢占信号量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">final</span> AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ProxyServer proxyServer = getProxyServer(config, request);</span><br><span class=\"line\">    <span class=\"comment\">//使用SSL代理或者ws</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (proxyServer != <span class=\"keyword\">null</span> &amp;&amp; (request.getUri().isSecured() || request.getUri().isWebSocket()) &amp;&amp; !isConnectDone(request, future))</span><br><span class=\"line\">        <span class=\"comment\">//暂时忽略另外两个创建连接的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//我们的例子用的是GET，所以执行该方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithCertainForceConnect</span><span class=\"params\">(//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//注意，这时候传进来是<span class=\"keyword\">null</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProxyServer proxyServer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> forceConnect)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把所有请求信息保证在一个响应回调对象里</span></span><br><span class=\"line\">    NettyResponseFuture&lt;T&gt; newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);</span><br><span class=\"line\">    <span class=\"comment\">//这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释</span></span><br><span class=\"line\">    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Channels.isChannelValid(channel))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Channel <span class=\"title\">getOpenChannel</span><span class=\"params\">(NettyResponseFuture&lt;?&gt; future, Request request, ProxyServer proxyServer, AsyncHandler&lt;?&gt; asyncHandler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (future != <span class=\"keyword\">null</span> &amp;&amp; future.isReuseChannel() &amp;&amp; Channels.isChannelValid(future.channel()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> future.channel();</span><br><span class=\"line\">    <span class=\"comment\">//视图在channelManager中找到可用对象</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pollPooledChannel(request, proxyServer, asyncHandler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithOpenChannel</span><span class=\"params\">(Request request, ProxyServer proxy, NettyResponseFuture&lt;T&gt; future, AsyncHandler&lt;T&gt; asyncHandler, Channel channel)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (asyncHandler <span class=\"keyword\">instanceof</span> AsyncHandlerExtensions)</span><br><span class=\"line\">        AsyncHandlerExtensions<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">asyncHandler</span>).<span class=\"title\">onConnectionPooled</span>(<span class=\"title\">channel</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//启动请求超时，在writeRequest中，会启动读取超时</span></span><br><span class=\"line\">    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);</span><br><span class=\"line\">    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());</span><br><span class=\"line\">    future.setChannelState(ChannelState.POOLED);</span><br><span class=\"line\">    future.attachChannel(channel, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Channels.setAttribute(channel, future);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Channels.isChannelValid(channel)) &#123;</span><br><span class=\"line\">        writeRequest(future, channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handleUnexpectedClosedChannel(channel, future);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把这里当作一个请求连接的开始</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithNewChannel</span><span class=\"params\">(//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProxyServer proxy,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Realm realm = future.getRealm();</span><br><span class=\"line\">    Realm proxyRealm = future.getProxyRealm();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//为做连接做准备</span></span><br><span class=\"line\">    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);</span><br><span class=\"line\">    <span class=\"comment\">//用于索取channel</span></span><br><span class=\"line\">    Object partitionKey = future.getPartitionKey();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> acquireChannelLock = !performingNextRequest;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//抢占信号量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">            channelManager.acquireChannelLock(partitionKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        abort(<span class=\"keyword\">null</span>, future, getCause(t));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//开启请求超时定时器</span></span><br><span class=\"line\">    scheduleRequestTimeout(future);</span><br><span class=\"line\">    <span class=\"comment\">//域名解析</span></span><br><span class=\"line\">    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)<span class=\"comment\">//</span></span><br><span class=\"line\">            .addListener(<span class=\"keyword\">new</span> SimpleFutureListener&lt;List&lt;InetSocketAddress&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"comment\">//域名解析后得到的IP地址列表</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(List&lt;InetSocketAddress&gt; addresses)</span> </span>&#123;</span><br><span class=\"line\">                    NettyConnectListener&lt;T&gt; connectListener = <span class=\"keyword\">new</span> NettyConnectListener&lt;&gt;(future, NettyRequestSender.<span class=\"keyword\">this</span>, channelManager, acquireChannelLock, partitionKey);</span><br><span class=\"line\">                    <span class=\"comment\">//不要怀疑！这里开始连接了！！！</span></span><br><span class=\"line\">                    NettyChannelConnector connector = <span class=\"keyword\">new</span> NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!future.isDone()) &#123;</span><br><span class=\"line\">                        connector.connect(bootstrap, connectListener);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//如果future已经完成，则释放信号量</span></span><br><span class=\"line\">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//失败，释放信号</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    abort(<span class=\"keyword\">null</span>, future, getCause(cause));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>NettyChannelConnector</code>负责对远程IP创建连接，一旦连接成功，<code>NettyConnectListener</code>就会调用requestSender向服务端发送数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyChannelConnector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">final</span> Bootstrap bootstrap, <span class=\"keyword\">final</span> NettyConnectListener&lt;?&gt; connectListener)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取DNS后的IP地址</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> InetSocketAddress remoteAddress = remoteAddresses.get(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          connect0(bootstrap, connectListener, remoteAddress);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (clientState.isClosed()) &#123;</span><br><span class=\"line\">              connectListener.onFailure(<span class=\"keyword\">null</span>, e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">connect0</span><span class=\"params\">(Bootstrap bootstrap, <span class=\"keyword\">final</span> NettyConnectListener&lt;?&gt; connectListener, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class=\"line\">      bootstrap.connect(remoteAddress, localAddress)<span class=\"comment\">//</span></span><br><span class=\"line\">              .addListener(<span class=\"keyword\">new</span> SimpleChannelFutureListener() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      <span class=\"comment\">//如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到</span></span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (connectionTtlEnabled) &#123;</span><br><span class=\"line\">                          Channels.initChannelId(channel);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      connectListener.onSuccess(channel, remoteAddress);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Channel channel, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);</span><br><span class=\"line\">                      <span class=\"comment\">//如果连接失败，则尝试连接下一个IP</span></span><br><span class=\"line\">                      <span class=\"keyword\">boolean</span> retry = pickNextRemoteAddress();</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (retry)</span><br><span class=\"line\">                          NettyChannelConnector.<span class=\"keyword\">this</span>.connect(bootstrap, connectListener);</span><br><span class=\"line\">                      <span class=\"keyword\">else</span></span><br><span class=\"line\">                          connectListener.onFailure(channel, t);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>连接成功，就来到这里，拿到channel，准备向服务器发送数据！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyConnectListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Channel channel, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      Channels.setInactiveToken(channel);</span><br><span class=\"line\">      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Request request = future.getTargetRequest();</span><br><span class=\"line\">      Uri uri = request.getUri();</span><br><span class=\"line\">      timeoutsHolder.initRemoteAddress(remoteAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (future.getProxyServer() == <span class=\"keyword\">null</span> &amp;&amp; uri.isSecured()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接无视</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          writeRequest(channel);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//在这设置属性，在读取服务器数据的httphandler里面有用到</span></span><br><span class=\"line\">      Channels.setAttribute(channel, future);</span><br><span class=\"line\">      <span class=\"comment\">//注册到ChannelGroup中</span></span><br><span class=\"line\">      channelManager.registerOpenChannel(channel, partitionKey);</span><br><span class=\"line\">      <span class=\"comment\">//设置为不复用channel</span></span><br><span class=\"line\">      future.attachChannel(channel, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">//发送请求数据</span></span><br><span class=\"line\">      <span class=\"comment\">//这个方法就不贴上来了，没什么意思</span></span><br><span class=\"line\">      <span class=\"comment\">//方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据</span></span><br><span class=\"line\">      requestSender.writeRequest(future, channel);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncHttpClientHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishUpdate</span><span class=\"params\">(<span class=\"keyword\">final</span> NettyResponseFuture&lt;?&gt; future, Channel channel, <span class=\"keyword\">boolean</span> expectOtherChunks)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">      future.cancelTimeouts();</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> keepAlive = future.isKeepAlive();</span><br><span class=\"line\">      <span class=\"comment\">//这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (expectOtherChunks &amp;&amp; keepAlive)</span><br><span class=\"line\">          channelManager.drainChannelAndOffer(channel, future);</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          future.done();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception t) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tryToOfferChannelToPool</strong> 是<code>ChannelManager</code>的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryToOfferChannelToPool</span><span class=\"params\">(Channel channel, AsyncHandler&lt;?&gt; asyncHandler, <span class=\"keyword\">boolean</span> keepAlive, Object partitionKey)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//长连接，或者依然活跃的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel.isActive() &amp;&amp; keepAlive) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//丢弃被设置的属性</span></span><br><span class=\"line\">        Channels.setDiscard(channel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asyncHandler <span class=\"keyword\">instanceof</span> AsyncHandlerExtensions)</span><br><span class=\"line\">            AsyncHandlerExtensions<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">asyncHandler</span>).<span class=\"title\">onConnectionOffer</span>(<span class=\"title\">channel</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">//尝试塞进pool里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelPool.offer(channel, partitionKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxConnectionsPerHostEnabled)</span><br><span class=\"line\">                <span class=\"comment\">//我没明白这个映射到底是干嘛用的</span></span><br><span class=\"line\">                channelId2PartitionKey.putIfAbsent(channel, partitionKey);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//被pool驳回，就直接关闭掉！！</span></span><br><span class=\"line\">            closeChannel(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//已经死亡或者不是长连接，直接关闭！！</span></span><br><span class=\"line\">        closeChannel(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 <strong>ChannelGroup</strong> 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 <strong>ChannelGroup</strong> 时已经将<code>remove(channel)</code>重写，可以倒回去看是不是已经释放了信号量，也可以看看 <strong>ChannelGroup</strong> 源码是不是在<code>add</code>时候添加了监听器。</font></p>\n<p>不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 <strong>ChannelPool</strong> 进行生命的倒计时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultChannelPool</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelPool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Object, ConcurrentLinkedDeque&lt;IdleChannel&gt;&gt; partitions = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;ChannelId, ChannelCreation&gt; channelId2Creation;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean isClosed = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionTtl;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> connectionTtlEnabled;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleTime;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxIdleTimeEnabled;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> cleanerPeriod;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PoolLeaseStrategy poolLeaseStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultChannelPool</span><span class=\"params\">(<span class=\"keyword\">int</span> maxIdleTime,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> connectionTtl,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PoolLeaseStrategy poolLeaseStrategy,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Timer nettyTimer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> cleanerPeriod)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxIdleTime = maxIdleTime;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.connectionTtl = connectionTtl;</span><br><span class=\"line\">      connectionTtlEnabled = connectionTtl &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">      channelId2Creation = connectionTtlEnabled ? <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      maxIdleTimeEnabled = maxIdleTime &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.poolLeaseStrategy = poolLeaseStrategy;</span><br><span class=\"line\">      <span class=\"comment\">//在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));</span><br><span class=\"line\">      <span class=\"comment\">//如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connectionTtlEnabled || maxIdleTimeEnabled)</span><br><span class=\"line\">          scheduleNewIdleChannelDetector(<span class=\"keyword\">new</span> IdleChannelDetector());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleNewIdleChannelDetector</span><span class=\"params\">(TimerTask task)</span> </span>&#123;</span><br><span class=\"line\">      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdleChannelDetector</span> <span class=\"keyword\">implements</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//挖出已经不满足条件的channel</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> List&lt;IdleChannel&gt; <span class=\"title\">expiredChannels</span><span class=\"params\">(ConcurrentLinkedDeque&lt;IdleChannel&gt; partition, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">          List&lt;IdleChannel&gt; idleTimeoutChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (IdleChannel idleChannel : partition) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//空闲时间是否过期</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);</span><br><span class=\"line\">              <span class=\"comment\">//channel是否还活跃</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isRemotelyClosed = isRemotelyClosed(idleChannel.channel);</span><br><span class=\"line\">              <span class=\"comment\">//存活时间是否过期</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isTtlExpired = isTtlExpired(idleChannel.channel, now);</span><br><span class=\"line\">              <span class=\"comment\">//满足其中一个条件，加入即将被关闭的channel队列</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (idleTimeoutChannels == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                      idleTimeoutChannels = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">                  idleTimeoutChannels.add(idleChannel);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> idleTimeoutChannels != <span class=\"keyword\">null</span> ? idleTimeoutChannels : Collections.&lt;IdleChannel&gt; emptyList();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> List&lt;IdleChannel&gt; <span class=\"title\">closeChannels</span><span class=\"params\">(List&lt;IdleChannel&gt; candidates)</span> </span>&#123;</span><br><span class=\"line\">          List&lt;IdleChannel&gt; closedChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.size(); i++) &#123;</span><br><span class=\"line\">              IdleChannel idleChannel = candidates.get(i);</span><br><span class=\"line\">              <span class=\"comment\">//如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (idleChannel.takeOwnership()) &#123;</span><br><span class=\"line\">                  close(idleChannel.channel);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (closedChannels != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      closedChannels.add(idleChannel);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"comment\">//注意，这里只会被执行一次，closedChannels被实例化后不会再执行</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (closedChannels == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  closedChannels = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(candidates.size());</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">                      closedChannels.add(candidates.get(j));</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回</span></span><br><span class=\"line\">          <span class=\"comment\">//如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> closedChannels != <span class=\"keyword\">null</span> ? closedChannels : candidates;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Timeout timeout)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isClosed.get())</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          <span class=\"comment\">//检测器的启动时间</span></span><br><span class=\"line\">          <span class=\"keyword\">long</span> start = unpreciseMillisTime();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> closedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> totalCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"comment\">//遍历每个路由的被塞到ChannelPool的channel队列</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span> (ConcurrentLinkedDeque&lt;IdleChannel&gt; partition : partitions.values()) &#123;</span><br><span class=\"line\">              List&lt;IdleChannel&gt; closedChannels = closeChannels(expiredChannels(partition, start));</span><br><span class=\"line\">              <span class=\"comment\">//非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!closedChannels.isEmpty()) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (connectionTtlEnabled) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">for</span> (IdleChannel closedChannel : closedChannels)</span><br><span class=\"line\">                          channelId2Creation.remove(channelId(closedChannel.channel));</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  partition.removeAll(closedChannels);</span><br><span class=\"line\">                  closedCount += closedChannels.size();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//退出并继续下一轮检测</span></span><br><span class=\"line\">          scheduleNewIdleChannelDetector(timeout.task());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//存放空闲channel</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdleChannel</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> Channel channel;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> AtomicBoolean owned = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      IdleChannel(Channel channel, <span class=\"keyword\">long</span> start) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.channel = assertNotNull(channel, <span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">takeOwnership</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> owned.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;...&#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//存放channel的创建时间</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChannelCreation</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> creationTime;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> Object partitionKey;</span><br><span class=\"line\">      ChannelCreation(<span class=\"keyword\">long</span> creationTime, Object partitionKey) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.creationTime = creationTime;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.partitionKey = partitionKey;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里才是channel的终结！！！</p>\n<p>channel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 <strong>请求超时</strong> 和 <strong>读取超时</strong>。<br>每个<code>NettyResponseFuture</code>都持有一个<code>TimeoutsHolder</code>来计算 <strong>requestTimeout</strong> 和 <strong>readTimeout</strong> 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 <strong>requestTimeout</strong> 其实是包括了 <strong>readTimeout</strong>，如果请求剩余时间小于读取超时时间时，<code>startReadTimeout</code>是不会启动readTimeout定时器的。下面只贴上<code>TimeoutsHolder</code>的部分源码，<code>RequestTimeoutTimerTask</code>和<code>ReadTimeoutTimerTask</code>可以自行阅读。</p>\n<p><font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeoutsHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean cancelled = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestSender requestSender;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> requestTimeoutMillisTime;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeoutValue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> NettyResponseFuture&lt;?&gt; nettyResponseFuture;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Timeout requestTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> Timeout readTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimeoutsHolder</span><span class=\"params\">(Timer nettyTimer, NettyResponseFuture&lt;?&gt; nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyResponseFuture = nettyResponseFuture;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.requestSender = requestSender;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.readTimeoutValue = config.getReadTimeout();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();</span><br><span class=\"line\">      <span class=\"comment\">//每个请求都可以独立设置请求超时时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeoutInMs == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          requestTimeoutInMs = config.getRequestTimeout();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeoutInMs != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//请求的到期时间，启动请求超时定时器</span></span><br><span class=\"line\">          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;</span><br><span class=\"line\">          requestTimeout = newTimeout(<span class=\"keyword\">new</span> RequestTimeoutTimerTask(nettyResponseFuture, requestSender, <span class=\"keyword\">this</span>, requestTimeoutInMs), requestTimeoutInMs);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          requestTimeoutMillisTime = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">          requestTimeout = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startReadTimeout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (readTimeoutValue != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          startReadTimeout(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startReadTimeout</span><span class=\"params\">(ReadTimeoutTimerTask task)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间&lt;请求剩余时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeout == <span class=\"keyword\">null</span> || (!requestTimeout.isExpired() &amp;&amp; readTimeoutValue &lt; (requestTimeoutMillisTime - unpreciseMillisTime()))) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              task = <span class=\"keyword\">new</span> ReadTimeoutTimerTask(nettyResponseFuture, requestSender, <span class=\"keyword\">this</span>, readTimeoutValue);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          Timeout readTimeout = newTimeout(task, readTimeoutValue);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.readTimeout = readTimeout;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          task.clean();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后最后最后。。。</p>\n<p>来总结一下ahc的连接池实现，很明显的一点整个过程都是对<code>Channel</code>的管理，而且对于连接的抢占则使用了<code>Semaphore</code>，这再方便不过了！！！对于信号量的释放，Netty的<code>ChannelGroup</code>有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的<code>HashedWheelTimer</code>，有机会专门来说说这一个。还有就是<code>DefaultChannelPool</code>对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。</p>\n<p>如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近项目重构，有了个机会更多接触一个有别于HttpAsyncClient的异步网络框架AsyncHttpClient，是个基于Netty的支持Http(s)或WebSocket协议的客户端。这东西有很多有趣的地方，特别是连接池的实现简单易懂，没有apache.hc的连接池实现那么蛋疼。如果想深入了解Netty用法的话，这是个不错的案例，很值得深究！</p>\n<hr>\n<p><strong>这里暂且仅关注连接池的实现，部分涉及Netty的channel输入输出处理、哈希轮定时器算法、事件轮询方式的区别，又或者信号量的使用等等，以后有机会会单独拿出来详解。</strong></p>\n<p>由于是基Netty的实现的，所以连接池实际上就是对channel的管理控制，有趣的是整个管理只用到了信号量+一个定时检测器，略微复杂的也就定时检测的逻辑，其实现方式简单且很好理解，不像httpclient里各种队列各种信号量难以理解。</p>\n<p>先上一个简单的例子，事实上使用起来也不复杂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AsyncHttpClient asyncHttpClient = Dsl</span><br><span class=\"line\">            <span class=\"comment\">//实例化所有池和检测器</span></span><br><span class=\"line\">            .asyncHttpClient(</span><br><span class=\"line\">                    Dsl.config()</span><br><span class=\"line\">                    .setMaxConnections(<span class=\"number\">500</span>)</span><br><span class=\"line\">                    .setMaxConnectionsPerHost(<span class=\"number\">50</span>)</span><br><span class=\"line\">                    .setPooledConnectionIdleTimeout(<span class=\"number\">6000</span>)</span><br><span class=\"line\">                    .setConnectionTtl(<span class=\"number\">500</span>)</span><br><span class=\"line\">                    .setIoThreadsCount(<span class=\"number\">100</span>)</span><br><span class=\"line\">                    .setConnectTimeout(<span class=\"number\">60000</span>)</span><br><span class=\"line\">                    .setUseNativeTransport(</span><br><span class=\"line\">                            System.getProperty(<span class=\"string\">\"os.name\"</span>).toLowerCase().indexOf(<span class=\"string\">\"linux\"</span>) &gt; <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        List&lt;Param&gt; params = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        params.add(<span class=\"keyword\">new</span> Param(<span class=\"string\">\"keyfrom\"</span>, <span class=\"string\">\"XXX\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        asyncHttpClient</span><br><span class=\"line\">                .prepareGet(<span class=\"string\">\"http://fanyi.youdao.com/openapi.do\"</span>)</span><br><span class=\"line\">                .addQueryParams(params)</span><br><span class=\"line\">                <span class=\"comment\">//这里进入发送请求阶段</span></span><br><span class=\"line\">                .execute()</span><br><span class=\"line\">                .toCompletableFuture()</span><br><span class=\"line\">                <span class=\"comment\">//超时报错，或请求异常，做容错处理，抛出一个Response</span></span><br><span class=\"line\">                .exceptionally(t -&gt; &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Response() &#123;...&#125;;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .thenAccept(rep -&gt; System.out.println(<span class=\"string\">\"RESPONSE BODY\"</span> + rep.getResponseBody()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先看看<code>DefaultAsyncHttpClientConfig</code>类的配置参数，这里只列出本文所需要的参数。有一点值得提一下，如果想了解Java怎么像clojure或者scala一样创建不可变对象，可以看看这个类的写法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// timeouts</span></span><br><span class=\"line\"><span class=\"comment\">//连接超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectTimeout;</span><br><span class=\"line\"><span class=\"comment\">//请求超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> requestTimeout;</span><br><span class=\"line\"><span class=\"comment\">//读取超时，含于请求时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeout;</span><br><span class=\"line\"><span class=\"comment\">//关闭Client前的静默时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> shutdownQuietPeriod;</span><br><span class=\"line\"><span class=\"comment\">//关闭超时</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> shutdownTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// keep-alive</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> keepAlive;</span><br><span class=\"line\"><span class=\"comment\">//连接池空闲时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> pooledConnectionIdleTimeout;</span><br><span class=\"line\"><span class=\"comment\">//定时清理空闲连接的时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionPoolCleanerPeriod;</span><br><span class=\"line\"><span class=\"comment\">//连接存活时间</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionTtl;</span><br><span class=\"line\"><span class=\"comment\">//最大连接数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConnections;</span><br><span class=\"line\"><span class=\"comment\">//每个路由的最大连接数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxConnectionsPerHost;</span><br><span class=\"line\"><span class=\"comment\">//用于channel超时处理</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelPool channelPool;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> KeepAliveStrategy keepAliveStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// internals</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String threadPoolName;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxInitialLineLength;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxHeaderSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> httpClientCodecMaxChunkSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> chunkedFileChunkSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> webSocketMaxBufferSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> webSocketMaxFrameSize;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;ChannelOption&lt;Object&gt;, Object&gt; channelOptions;</span><br><span class=\"line\"><span class=\"comment\">//时间轮询组类型</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventLoopGroup eventLoopGroup;</span><br><span class=\"line\"><span class=\"comment\">//是否用epoll，仅linux系统支持</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> useNativeTransport;</span><br><span class=\"line\"><span class=\"comment\">//用于Timeout处理，建议用默认Netty的HashedWheelTimer</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadFactory threadFactory;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AdditionalChannelInitializer httpAdditionalChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AdditionalChannelInitializer wsAdditionalChannelInitializer;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ResponseBodyPartFactory responseBodyPartFactory;</span><br><span class=\"line\"><span class=\"comment\">//其实就是EventLoopGroup指定的线程数</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ioThreadsCount;</span><br></pre></td></tr></table></figure>\n\n<p>就从这里开始，开头主要实例化<code>ChannelManager</code>和<code>NettyRequestSender</code>以及<code>Timer</code>三个重要组件，<code>NettyRequestSender</code>用于发送请求以及向<code>ChannelManager</code>索取channel使用权，<code>Timer</code>则负责另外两个组件给他的检测任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dsl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AsyncHttpClient <span class=\"title\">asyncHttpClient</span><span class=\"params\">(DefaultAsyncHttpClientConfig.Builder configBuilder)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认客户端</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultAsyncHttpClient(configBuilder.build());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAsyncHttpClient</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHttpClient</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean closed = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"comment\">//Netty初始化的起点，Bootstrap与Channel池管理都在这里声明</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelManager channelManager;</span><br><span class=\"line\">  <span class=\"comment\">//发送请求，以及向ChannelManager索取channel的使用权</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestSender requestSender;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowStopNettyTimer;</span><br><span class=\"line\">  <span class=\"comment\">//定时做超时处理</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultAsyncHttpClient</span><span class=\"params\">(AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\"></span><br><span class=\"line\">    allowStopNettyTimer = config.getNettyTimer() == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//默认使用HashedWheelTimer</span></span><br><span class=\"line\">    nettyTimer = allowStopNettyTimer ? newNettyTimer() :config.getNettyTimer();</span><br><span class=\"line\">    <span class=\"comment\">//下面两个是重点！！！</span></span><br><span class=\"line\">    channelManager = <span class=\"keyword\">new</span> ChannelManager(config, nettyTimer);</span><br><span class=\"line\">    requestSender = <span class=\"keyword\">new</span> NettyRequestSender(config, channelManager,nettyTimer, <span class=\"keyword\">new</span> AsyncHttpClientState(closed));</span><br><span class=\"line\">    <span class=\"comment\">//给Bootstraps配置解析器，以及处理接收服务端发送的消息的处理器</span></span><br><span class=\"line\">    channelManager.configureBootstraps(requestSender);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> Timer <span class=\"title\">newNettyTimer</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    HashedWheelTimer timer = <span class=\"keyword\">new</span> HashedWheelTimer();</span><br><span class=\"line\">    timer.start();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> timer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里是重中之重，网络配置、连接池、IO线程池、轮询方式都是在这儿产生的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChannelManager</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventLoopGroup eventLoopGroup;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> allowReleaseEventLoopGroup;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Bootstrap httpBootstrap;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Bootstrap wsBootstrap;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> handshakeTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IOException tooManyConnections;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> IOException tooManyConnectionsPerHost;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//定时清理不符合标准的channel</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelPool channelPool;</span><br><span class=\"line\">  <span class=\"comment\">//netty自带的用于管理channel的管理器</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelGroup openChannels;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Channel, Object&gt; channelId2PartitionKey = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//是否开启最大总连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxTotalConnectionsEnabled;</span><br><span class=\"line\">  <span class=\"comment\">//最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore freeChannels;</span><br><span class=\"line\">  <span class=\"comment\">//是否开启每个路由最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxConnectionsPerHostEnabled;</span><br><span class=\"line\">  <span class=\"comment\">//每个路由最大连接数</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Object, Semaphore&gt; freeChannelsPerHost = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> AsyncHttpClientHandler wsHandler;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ChannelManager</span><span class=\"params\">(<span class=\"keyword\">final</span> AsyncHttpClientConfig config, Timer nettyTimer)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">    <span class=\"comment\">//忽略一小段关于ssl的</span></span><br><span class=\"line\">    <span class=\"comment\">//ChannelPool是用于检测已经实例化的channel的健康状况，如果不合格会直接close掉</span></span><br><span class=\"line\">    ChannelPool channelPool = config.getChannelPool();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channelPool == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config.isKeepAlive()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//这是默认使用的，事实上多数场景不需要我们自己实现</span></span><br><span class=\"line\">            channelPool = <span class=\"keyword\">new</span> DefaultChannelPool(config, nettyTimer);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            channelPool = NoopChannelPool.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.channelPool = channelPool;</span><br><span class=\"line\"></span><br><span class=\"line\">    tooManyConnections = trimStackTrace(<span class=\"keyword\">new</span> TooManyConnectionsException(config.getMaxConnections()));</span><br><span class=\"line\">    tooManyConnectionsPerHost = trimStackTrace(<span class=\"keyword\">new</span> TooManyConnectionsPerHostException(config.getMaxConnectionsPerHost()));</span><br><span class=\"line\">    maxTotalConnectionsEnabled = config.getMaxConnections() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    maxConnectionsPerHostEnabled = config.getMaxConnectionsPerHost() &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxTotalConnectionsEnabled || maxConnectionsPerHostEnabled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//管理已经被实例化的channel</span></span><br><span class=\"line\">        openChannels = <span class=\"keyword\">new</span> DefaultChannelGroup(<span class=\"string\">\"asyncHttpClient\"</span>, GlobalEventExecutor.INSTANCE) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//重写删除方法，因为删除channel时，需要释放信号量</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> removed = <span class=\"keyword\">super</span>.remove(o);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (removed) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//释放总连接池的信号量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (maxTotalConnectionsEnabled)</span><br><span class=\"line\">                        freeChannels.release();</span><br><span class=\"line\">                    <span class=\"comment\">//释放路由连接池的信号量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (maxConnectionsPerHostEnabled) &#123;</span><br><span class=\"line\">                        Object partitionKey = channelId2PartitionKey.remove(Channel<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">o</span>))</span>;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (partitionKey != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                            Semaphore hostFreeChannels = freeChannelsPerHost.get(partitionKey);</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> (hostFreeChannels != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                                hostFreeChannels.release();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> removed;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//信号量数为最大连接数</span></span><br><span class=\"line\">        freeChannels = <span class=\"keyword\">new</span> Semaphore(config.getMaxConnections());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        openChannels = <span class=\"keyword\">new</span> DefaultChannelGroup(<span class=\"string\">\"asyncHttpClient\"</span>, GlobalEventExecutor.INSTANCE);</span><br><span class=\"line\">        freeChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    handshakeTimeout = config.getHandshakeTimeout();</span><br><span class=\"line\"></span><br><span class=\"line\">    ThreadFactory threadFactory = config.getThreadFactory() != <span class=\"keyword\">null</span> ? config.getThreadFactory() : <span class=\"keyword\">new</span> DefaultThreadFactory(config.getThreadPoolName());</span><br><span class=\"line\">    allowReleaseEventLoopGroup = config.getEventLoopGroup() == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    ChannelFactory&lt;? extends Channel&gt; channelFactory;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (allowReleaseEventLoopGroup) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个只能在linux下使用</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (config.isUseNativeTransport()) &#123;</span><br><span class=\"line\">            eventLoopGroup = newEpollEventLoopGroup(config.getIoThreadsCount(), threadFactory);</span><br><span class=\"line\">            channelFactory = getEpollSocketChannelFactory();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//通常默认走这个！</span></span><br><span class=\"line\">            eventLoopGroup = <span class=\"keyword\">new</span> NioEventLoopGroup(config.getIoThreadsCount(), <span class=\"comment\">//瞧！IO线程数就是时间轮询的线程数</span></span><br><span class=\"line\">              threadFactory);</span><br><span class=\"line\">            channelFactory = NioSocketChannelFactory.INSTANCE;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//用于http请求的bootstrap</span></span><br><span class=\"line\">    httpBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class=\"line\">    <span class=\"comment\">//用于WebSocket请求的bootstrap</span></span><br><span class=\"line\">    wsBootstrap = newBootstrap(channelFactory, eventLoopGroup, config);</span><br><span class=\"line\"></span><br><span class=\"line\">    httpBootstrap.option(ChannelOption.AUTO_READ, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例化完<code>ChannelManager</code>后，就轮到请求发送器，这里先看看所需要的参数，具体执行的方法在后面说。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyRequestSender</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientConfig config;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ChannelManager channelManager;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClientState clientState;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestFactory requestFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NettyRequestSender</span><span class=\"params\">(AsyncHttpClientConfig config,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ChannelManager channelManager,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Timer nettyTimer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHttpClientState clientState)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.config = config;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.channelManager = channelManager;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.clientState = clientState;</span><br><span class=\"line\">      requestFactory = <span class=\"keyword\">new</span> NettyRequestFactory(config);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回来看看<code>ChannelManager</code>构造方法中使用的工厂方法<code>newBootstrap(channelFactory, eventLoopGroup, config)</code>，这是支持整个ahc运作的代码，对于用Netty实现网络客户端来说，这个配置很有参考价值，所以也贴上来一起观赏！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Bootstrap <span class=\"title\">newBootstrap</span><span class=\"params\">(ChannelFactory&lt;? extends Channel&gt; channelFactory, EventLoopGroup eventLoopGroup, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"deprecation\"</span>)</span><br><span class=\"line\">    Bootstrap bootstrap = <span class=\"keyword\">new</span> Bootstrap().channelFactory(channelFactory)</span><br><span class=\"line\">            <span class=\"comment\">//客户端只有worker线程池，ServerBootstrap则需要boss和worker</span></span><br><span class=\"line\">            .group(eventLoopGroup)</span><br><span class=\"line\">            <span class=\"comment\">//设置内存分配器，我的理解是关于堆内存模型的，可用于对Netty的优化</span></span><br><span class=\"line\">            .option(ChannelOption.ALLOCATOR, config.getAllocator() != <span class=\"keyword\">null</span> ? config.getAllocator() : ByteBufAllocator.DEFAULT)</span><br><span class=\"line\">            <span class=\"comment\">//是否使用tcp的Nagle算法，文件传输可以选择使用</span></span><br><span class=\"line\">            .option(ChannelOption.TCP_NODELAY, config.isTcpNoDelay())</span><br><span class=\"line\">            <span class=\"comment\">//重复使用本地地址端口</span></span><br><span class=\"line\">            .option(ChannelOption.SO_REUSEADDR, config.isSoReuseAddress())<span class=\"comment\">//</span></span><br><span class=\"line\">            .option(ChannelOption.AUTO_CLOSE, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getConnectTimeout() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, config.getConnectTimeout());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoLinger() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//就是一个设置延迟关闭时间的参数，用于保证数据发送完成</span></span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_LINGER, config.getSoLinger());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoSndBuf() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_SNDBUF, config.getSoSndBuf());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.getSoRcvBuf() &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        bootstrap.option(ChannelOption.SO_RCVBUF, config.getSoRcvBuf());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//自定义配置</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;ChannelOption&lt;Object&gt;, Object&gt; entry : config.getChannelOptions().entrySet()) &#123;</span><br><span class=\"line\">        bootstrap.option(entry.getKey(), entry.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bootstrap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面则是管道的配置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configureBootstraps</span><span class=\"params\">(NettyRequestSender requestSender)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//ahc自定义的ChannelInboundHandler，异步方式获取服务端返回的数据</span></span><br><span class=\"line\">    <span class=\"comment\">//我们自己获取数据后的核心业务逻辑，也在这里开始</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> AsyncHttpClientHandler httpHandler = <span class=\"keyword\">new</span> HttpHandler(config, <span class=\"keyword\">this</span>, requestSender);</span><br><span class=\"line\">    wsHandler = <span class=\"keyword\">new</span> WebSocketHandler(config, <span class=\"keyword\">this</span>, requestSender);</span><br><span class=\"line\">    <span class=\"keyword\">final</span> NoopHandler pinnedEntry = <span class=\"keyword\">new</span> NoopHandler();</span><br><span class=\"line\"></span><br><span class=\"line\">    httpBootstrap.handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            ChannelPipeline pipeline = ch.pipeline()<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(INFLATER_HANDLER, newHttpContentDecompressor())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(CHUNKED_WRITER_HANDLER, <span class=\"keyword\">new</span> ChunkedWriteHandler())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(AHC_HTTP_HANDLER, httpHandler);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (config.getHttpAdditionalChannelInitializer() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                config.getHttpAdditionalChannelInitializer().initChannel(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    wsBootstrap.handler(<span class=\"keyword\">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initChannel</span><span class=\"params\">(Channel ch)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            ChannelPipeline pipeline = ch.pipeline()<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(PINNED_ENTRY, pinnedEntry)<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(HTTP_CLIENT_CODEC, newHttpClientCodec())<span class=\"comment\">//</span></span><br><span class=\"line\">                    .addLast(AHC_WS_HANDLER, wsHandler);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (config.getWsAdditionalChannelInitializer() != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                config.getWsAdditionalChannelInitializer().initChannel(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一切工作准备就绪，现在可以请求了！怎么构建请求就不打算讲了，可以自行阅读<code>RequestBuilderBase</code>类。执行<code>execute()</code>方法，正式开始请求，往下看<code>DefaultAsyncHttpClient.executeRequest()</code>怎么创建连接的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundRequestBuilder</span> <span class=\"keyword\">extends</span> <span class=\"title\">RequestBuilderBase</span>&lt;<span class=\"title\">BoundRequestBuilder</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AsyncHttpClient client;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ListenableFuture&lt;Response&gt; <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> client.executeRequest(build(), <span class=\"keyword\">new</span> AsyncCompletionHandlerBase());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultAsyncHttpClient</span> <span class=\"keyword\">implements</span> <span class=\"title\">AsyncHttpClient</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">executeRequest</span><span class=\"params\">(Request request, AsyncHandler&lt;T&gt; handler)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (config.getRequestFilters().isEmpty()) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> execute(request, handler);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//不考虑设置请求过滤器的情况</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">execute</span><span class=\"params\">(Request request, <span class=\"keyword\">final</span> AsyncHandler&lt;T&gt; asyncHandler)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//把请求参数，和读取数据后的回调一同塞给请求发送器</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> requestSender.sendRequest(request, asyncHandler, <span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          asyncHandler.onThrowable(e);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ListenableFuture.CompletedFailure&lt;&gt;(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>OK～～上面列出<code>NettyRequestSender</code>需要什么参数，现在再来看看怎么做的？<br>下面的方法中，重点关注<code>sendRequestWithNewChannel</code>，它包括了如何新建channel、连接，抢占信号量</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">final</span> AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    ProxyServer proxyServer = getProxyServer(config, request);</span><br><span class=\"line\">    <span class=\"comment\">//使用SSL代理或者ws</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (proxyServer != <span class=\"keyword\">null</span> &amp;&amp; (request.getUri().isSecured() || request.getUri().isWebSocket()) &amp;&amp; !isConnectDone(request, future))</span><br><span class=\"line\">        <span class=\"comment\">//暂时忽略另外两个创建连接的方式</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//我们的例子用的是GET，所以执行该方法</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithCertainForceConnect(request, asyncHandler, future, performingNextRequest, proxyServer, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithCertainForceConnect</span><span class=\"params\">(//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//注意，这时候传进来是<span class=\"keyword\">null</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProxyServer proxyServer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> forceConnect)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//把所有请求信息保证在一个响应回调对象里</span></span><br><span class=\"line\">    NettyResponseFuture&lt;T&gt; newFuture = newNettyRequestAndResponseFuture(request, asyncHandler, future, proxyServer, forceConnect);</span><br><span class=\"line\">    <span class=\"comment\">//这里视图根据这个请求去拿去channel，过程有点漫长，回头再来解释</span></span><br><span class=\"line\">    Channel channel = getOpenChannel(future, request, proxyServer, asyncHandler);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Channels.isChannelValid(channel))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithOpenChannel(request, proxyServer, newFuture, asyncHandler, channel);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sendRequestWithNewChannel(request, proxyServer, newFuture, asyncHandler, performingNextRequest);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Channel <span class=\"title\">getOpenChannel</span><span class=\"params\">(NettyResponseFuture&lt;?&gt; future, Request request, ProxyServer proxyServer, AsyncHandler&lt;?&gt; asyncHandler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//future并没有channel，对于什么时候channel是可复用的，一直没搞明白，所以我基本默认每次都要新建一个channel</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (future != <span class=\"keyword\">null</span> &amp;&amp; future.isReuseChannel() &amp;&amp; Channels.isChannelValid(future.channel()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> future.channel();</span><br><span class=\"line\">    <span class=\"comment\">//视图在channelManager中找到可用对象</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> pollPooledChannel(request, proxyServer, asyncHandler);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithOpenChannel</span><span class=\"params\">(Request request, ProxyServer proxy, NettyResponseFuture&lt;T&gt; future, AsyncHandler&lt;T&gt; asyncHandler, Channel channel)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (asyncHandler <span class=\"keyword\">instanceof</span> AsyncHandlerExtensions)</span><br><span class=\"line\">        AsyncHandlerExtensions<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">asyncHandler</span>).<span class=\"title\">onConnectionPooled</span>(<span class=\"title\">channel</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//启动请求超时，在writeRequest中，会启动读取超时</span></span><br><span class=\"line\">    TimeoutsHolder timeoutsHolder = scheduleRequestTimeout(future);</span><br><span class=\"line\">    timeoutsHolder.initRemoteAddress((InetSocketAddress) channel.remoteAddress());</span><br><span class=\"line\">    future.setChannelState(ChannelState.POOLED);</span><br><span class=\"line\">    future.attachChannel(channel, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Channels.setAttribute(channel, future);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Channels.isChannelValid(channel)) &#123;</span><br><span class=\"line\">        writeRequest(future, channel);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        handleUnexpectedClosedChannel(channel, future);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//把这里当作一个请求连接的开始</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> &lt;T&gt; <span class=\"function\">ListenableFuture&lt;T&gt; <span class=\"title\">sendRequestWithNewChannel</span><span class=\"params\">(//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Request request,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            ProxyServer proxy,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            NettyResponseFuture&lt;T&gt; future,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AsyncHandler&lt;T&gt; asyncHandler,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">boolean</span> performingNextRequest)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Realm realm = future.getRealm();</span><br><span class=\"line\">    Realm proxyRealm = future.getProxyRealm();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"comment\">//为做连接做准备</span></span><br><span class=\"line\">    Bootstrap bootstrap = channelManager.getBootstrap(request.getUri(), proxy);</span><br><span class=\"line\">    <span class=\"comment\">//用于索取channel</span></span><br><span class=\"line\">    Object partitionKey = future.getPartitionKey();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> acquireChannelLock = !performingNextRequest;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//抢占信号量</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">            channelManager.acquireChannelLock(partitionKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">        abort(<span class=\"keyword\">null</span>, future, getCause(t));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//开启请求超时定时器</span></span><br><span class=\"line\">    scheduleRequestTimeout(future);</span><br><span class=\"line\">    <span class=\"comment\">//域名解析</span></span><br><span class=\"line\">    RequestHostnameResolver.INSTANCE.resolve(request, proxy, asyncHandler)<span class=\"comment\">//</span></span><br><span class=\"line\">            .addListener(<span class=\"keyword\">new</span> SimpleFutureListener&lt;List&lt;InetSocketAddress&gt;&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"comment\">//域名解析后得到的IP地址列表</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(List&lt;InetSocketAddress&gt; addresses)</span> </span>&#123;</span><br><span class=\"line\">                    NettyConnectListener&lt;T&gt; connectListener = <span class=\"keyword\">new</span> NettyConnectListener&lt;&gt;(future, NettyRequestSender.<span class=\"keyword\">this</span>, channelManager, acquireChannelLock, partitionKey);</span><br><span class=\"line\">                    <span class=\"comment\">//不要怀疑！这里开始连接了！！！</span></span><br><span class=\"line\">                    NettyChannelConnector connector = <span class=\"keyword\">new</span> NettyChannelConnector(request.getLocalAddress(), addresses, asyncHandler, clientState, config);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!future.isDone()) &#123;</span><br><span class=\"line\">                        connector.connect(bootstrap, connectListener);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">                        <span class=\"comment\">//如果future已经完成，则释放信号量</span></span><br><span class=\"line\">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Throwable cause)</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//失败，释放信号</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (acquireChannelLock) &#123;</span><br><span class=\"line\">                        channelManager.releaseChannelLock(partitionKey);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    abort(<span class=\"keyword\">null</span>, future, getCause(cause));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> future;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>NettyChannelConnector</code>负责对远程IP创建连接，一旦连接成功，<code>NettyConnectListener</code>就会调用requestSender向服务端发送数据。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyChannelConnector</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">final</span> Bootstrap bootstrap, <span class=\"keyword\">final</span> NettyConnectListener&lt;?&gt; connectListener)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取DNS后的IP地址</span></span><br><span class=\"line\">      <span class=\"keyword\">final</span> InetSocketAddress remoteAddress = remoteAddresses.get(i);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">          asyncHandlerExtensions.onTcpConnectAttempt(remoteAddress);</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          connect0(bootstrap, connectListener, remoteAddress);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (RejectedExecutionException e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (clientState.isClosed()) &#123;</span><br><span class=\"line\">              connectListener.onFailure(<span class=\"keyword\">null</span>, e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">connect0</span><span class=\"params\">(Bootstrap bootstrap, <span class=\"keyword\">final</span> NettyConnectListener&lt;?&gt; connectListener, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class=\"line\">      bootstrap.connect(remoteAddress, localAddress)<span class=\"comment\">//</span></span><br><span class=\"line\">              .addListener(<span class=\"keyword\">new</span> SimpleChannelFutureListener() &#123;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                          asyncHandlerExtensions.onTcpConnectSuccess(remoteAddress, channel);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      <span class=\"comment\">//如果有设置连接的存活时间，则初始化channelId，在ChannelPool中自检有用到</span></span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (connectionTtlEnabled) &#123;</span><br><span class=\"line\">                          Channels.initChannelId(channel);</span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      connectListener.onSuccess(channel, remoteAddress);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"meta\">@Override</span></span><br><span class=\"line\">                  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onFailure</span><span class=\"params\">(Channel channel, Throwable t)</span> </span>&#123;</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (asyncHandlerExtensions != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                          asyncHandlerExtensions.onTcpConnectFailure(remoteAddress, t);</span><br><span class=\"line\">                      <span class=\"comment\">//如果连接失败，则尝试连接下一个IP</span></span><br><span class=\"line\">                      <span class=\"keyword\">boolean</span> retry = pickNextRemoteAddress();</span><br><span class=\"line\">                      <span class=\"keyword\">if</span> (retry)</span><br><span class=\"line\">                          NettyChannelConnector.<span class=\"keyword\">this</span>.connect(bootstrap, connectListener);</span><br><span class=\"line\">                      <span class=\"keyword\">else</span></span><br><span class=\"line\">                          connectListener.onFailure(channel, t);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>连接成功，就来到这里，拿到channel，准备向服务器发送数据！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NettyConnectListener</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onSuccess</span><span class=\"params\">(Channel channel, InetSocketAddress remoteAddress)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      Channels.setInactiveToken(channel);</span><br><span class=\"line\">      TimeoutsHolder timeoutsHolder = future.getTimeoutsHolder();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      Request request = future.getTargetRequest();</span><br><span class=\"line\">      Uri uri = request.getUri();</span><br><span class=\"line\">      timeoutsHolder.initRemoteAddress(remoteAddress);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (future.getProxyServer() == <span class=\"keyword\">null</span> &amp;&amp; uri.isSecured()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接无视</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          writeRequest(channel);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">writeRequest</span><span class=\"params\">(Channel channel)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (futureIsAlreadyCancelled(channel)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//在这设置属性，在读取服务器数据的httphandler里面有用到</span></span><br><span class=\"line\">      Channels.setAttribute(channel, future);</span><br><span class=\"line\">      <span class=\"comment\">//注册到ChannelGroup中</span></span><br><span class=\"line\">      channelManager.registerOpenChannel(channel, partitionKey);</span><br><span class=\"line\">      <span class=\"comment\">//设置为不复用channel</span></span><br><span class=\"line\">      future.attachChannel(channel, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">      <span class=\"comment\">//发送请求数据</span></span><br><span class=\"line\">      <span class=\"comment\">//这个方法就不贴上来了，没什么意思</span></span><br><span class=\"line\">      <span class=\"comment\">//方法里最后将启动读取超时scheduleReadTimeout(future);意味将进入HttpHandler读取服务端数据</span></span><br><span class=\"line\">      requestSender.writeRequest(future, channel);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>读取数据一切顺利后，就会走下面这个私有方法，将channel送入channelpool里，等待生命的结束！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">AsyncHttpClientHandler</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishUpdate</span><span class=\"params\">(<span class=\"keyword\">final</span> NettyResponseFuture&lt;?&gt; future, Channel channel, <span class=\"keyword\">boolean</span> expectOtherChunks)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">      future.cancelTimeouts();</span><br><span class=\"line\">      <span class=\"keyword\">boolean</span> keepAlive = future.isKeepAlive();</span><br><span class=\"line\">      <span class=\"comment\">//这里继续读取后面的数据块，最后channel被设置了回调，依然调用下面的tryToOfferChannelToPool方法</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (expectOtherChunks &amp;&amp; keepAlive)</span><br><span class=\"line\">          channelManager.drainChannelAndOffer(channel, future);</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">          channelManager.tryToOfferChannelToPool(channel, future.getAsyncHandler(), keepAlive, future.getPartitionKey());</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          future.done();</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (Exception t) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>tryToOfferChannelToPool</strong> 是<code>ChannelManager</code>的方法，主要将依然活跃的channel送入生命倒数器中，还记得connectionTtl么，这个参数在这就起作用了！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">tryToOfferChannelToPool</span><span class=\"params\">(Channel channel, AsyncHandler&lt;?&gt; asyncHandler, <span class=\"keyword\">boolean</span> keepAlive, Object partitionKey)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//长连接，或者依然活跃的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (channel.isActive() &amp;&amp; keepAlive) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//丢弃被设置的属性</span></span><br><span class=\"line\">        Channels.setDiscard(channel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (asyncHandler <span class=\"keyword\">instanceof</span> AsyncHandlerExtensions)</span><br><span class=\"line\">            AsyncHandlerExtensions<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">cast</span>(<span class=\"title\">asyncHandler</span>).<span class=\"title\">onConnectionOffer</span>(<span class=\"title\">channel</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">//尝试塞进pool里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channelPool.offer(channel, partitionKey)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (maxConnectionsPerHostEnabled)</span><br><span class=\"line\">                <span class=\"comment\">//我没明白这个映射到底是干嘛用的</span></span><br><span class=\"line\">                channelId2PartitionKey.putIfAbsent(channel, partitionKey);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">//被pool驳回，就直接关闭掉！！</span></span><br><span class=\"line\">            closeChannel(channel);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//已经死亡或者不是长连接，直接关闭！！</span></span><br><span class=\"line\">        closeChannel(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><font color=#f28080>到这里，关于channel已经接近尾声了，细心的童鞋可能发现，信号量呢？！不用释放么？！其实在关闭channel的时候，已经释放了，这是因为 <strong>ChannelGroup</strong> 的作用，在将channel注册(add方法)到group的时候，已经在其上面加了关闭的监听器，一旦close就执行remove，实例化 <strong>ChannelGroup</strong> 时已经将<code>remove(channel)</code>重写，可以倒回去看是不是已经释放了信号量，也可以看看 <strong>ChannelGroup</strong> 源码是不是在<code>add</code>时候添加了监听器。</font></p>\n<p>不过，这里只是接近尾声，没意味就结束了，还有存活的channel被塞到 <strong>ChannelPool</strong> 进行生命的倒计时。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultChannelPool</span> <span class=\"keyword\">implements</span> <span class=\"title\">ChannelPool</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;Object, ConcurrentLinkedDeque&lt;IdleChannel&gt;&gt; partitions = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentHashMap&lt;ChannelId, ChannelCreation&gt; channelId2Creation;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean isClosed = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> connectionTtl;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> connectionTtlEnabled;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> maxIdleTime;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> maxIdleTimeEnabled;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> cleanerPeriod;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> PoolLeaseStrategy poolLeaseStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DefaultChannelPool</span><span class=\"params\">(<span class=\"keyword\">int</span> maxIdleTime,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> connectionTtl,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            PoolLeaseStrategy poolLeaseStrategy,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            Timer nettyTimer,//</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            <span class=\"keyword\">int</span> cleanerPeriod)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.maxIdleTime = maxIdleTime;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.connectionTtl = connectionTtl;</span><br><span class=\"line\">      connectionTtlEnabled = connectionTtl &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">      channelId2Creation = connectionTtlEnabled ? <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;() : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      maxIdleTimeEnabled = maxIdleTime &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.poolLeaseStrategy = poolLeaseStrategy;</span><br><span class=\"line\">      <span class=\"comment\">//在cleanerPeriod清理周期时间、connectionTtl连接存活时间、maxIdleTime最大空闲时间中选择最小的</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cleanerPeriod = Math.min(cleanerPeriod定时清理周期, Math.min(connectionTtlEnabled ? connectionTtl : Integer.MAX_VALUE, maxIdleTimeEnabled ? maxIdleTime : Integer.MAX_VALUE));</span><br><span class=\"line\">      <span class=\"comment\">//如果开启了连接存活时间，或者最大空闲时间，则实例化空闲channel检测</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (connectionTtlEnabled || maxIdleTimeEnabled)</span><br><span class=\"line\">          scheduleNewIdleChannelDetector(<span class=\"keyword\">new</span> IdleChannelDetector());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">scheduleNewIdleChannelDetector</span><span class=\"params\">(TimerTask task)</span> </span>&#123;</span><br><span class=\"line\">      nettyTimer.newTimeout(task, cleanerPeriod, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdleChannelDetector</span> <span class=\"keyword\">implements</span> <span class=\"title\">TimerTask</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//挖出已经不满足条件的channel</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> List&lt;IdleChannel&gt; <span class=\"title\">expiredChannels</span><span class=\"params\">(ConcurrentLinkedDeque&lt;IdleChannel&gt; partition, <span class=\"keyword\">long</span> now)</span> </span>&#123;</span><br><span class=\"line\">          List&lt;IdleChannel&gt; idleTimeoutChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (IdleChannel idleChannel : partition) &#123;</span><br><span class=\"line\">              <span class=\"comment\">//空闲时间是否过期</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isIdleTimeoutExpired = isIdleTimeoutExpired(idleChannel, now);</span><br><span class=\"line\">              <span class=\"comment\">//channel是否还活跃</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isRemotelyClosed = isRemotelyClosed(idleChannel.channel);</span><br><span class=\"line\">              <span class=\"comment\">//存活时间是否过期</span></span><br><span class=\"line\">              <span class=\"keyword\">boolean</span> isTtlExpired = isTtlExpired(idleChannel.channel, now);</span><br><span class=\"line\">              <span class=\"comment\">//满足其中一个条件，加入即将被关闭的channel队列</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (isIdleTimeoutExpired || isRemotelyClosed || isTtlExpired) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (idleTimeoutChannels == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                      idleTimeoutChannels = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\">                  idleTimeoutChannels.add(idleChannel);</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> idleTimeoutChannels != <span class=\"keyword\">null</span> ? idleTimeoutChannels : Collections.&lt;IdleChannel&gt; emptyList();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">//关闭expiredChannels筛选出来的队列，并返回一个已被close的channel队列</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">private</span> List&lt;IdleChannel&gt; <span class=\"title\">closeChannels</span><span class=\"params\">(List&lt;IdleChannel&gt; candidates)</span> </span>&#123;</span><br><span class=\"line\">          List&lt;IdleChannel&gt; closedChannels = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; candidates.size(); i++) &#123;</span><br><span class=\"line\">              IdleChannel idleChannel = candidates.get(i);</span><br><span class=\"line\">              <span class=\"comment\">//如果未被占有，则直接close；如果中间出现有被占有的channel，实例化closedChannels，并将之前被close的channel塞进其中</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (idleChannel.takeOwnership()) &#123;</span><br><span class=\"line\">                  close(idleChannel.channel);</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (closedChannels != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                      closedChannels.add(idleChannel);</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">              &#125; <span class=\"comment\">//注意，这里只会被执行一次，closedChannels被实例化后不会再执行</span></span><br><span class=\"line\">              <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (closedChannels == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                  closedChannels = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(candidates.size());</span><br><span class=\"line\">                  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++)</span><br><span class=\"line\">                      closedChannels.add(candidates.get(j));</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//如果closedChannels为null，代表已经关闭candidates所有channel，原封不动返回</span></span><br><span class=\"line\">          <span class=\"comment\">//如果closedChannels非null，代表被占用的channel没有close并继续存活在candidates，所以返回被close了的channel队列closedChannels</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> closedChannels != <span class=\"keyword\">null</span> ? closedChannels : candidates;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(Timeout timeout)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (isClosed.get())</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          <span class=\"comment\">//检测器的启动时间</span></span><br><span class=\"line\">          <span class=\"keyword\">long</span> start = unpreciseMillisTime();</span><br><span class=\"line\">          <span class=\"keyword\">int</span> closedCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">int</span> totalCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"comment\">//遍历每个路由的被塞到ChannelPool的channel队列</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span> (ConcurrentLinkedDeque&lt;IdleChannel&gt; partition : partitions.values()) &#123;</span><br><span class=\"line\">              List&lt;IdleChannel&gt; closedChannels = closeChannels(expiredChannels(partition, start));</span><br><span class=\"line\">              <span class=\"comment\">//非空且开启了连接存活时间的channel且被close的channel，全部从channelId2Creation和partition中去除</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!closedChannels.isEmpty()) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">if</span> (connectionTtlEnabled) &#123;</span><br><span class=\"line\">                      <span class=\"keyword\">for</span> (IdleChannel closedChannel : closedChannels)</span><br><span class=\"line\">                          channelId2Creation.remove(channelId(closedChannel.channel));</span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  partition.removeAll(closedChannels);</span><br><span class=\"line\">                  closedCount += closedChannels.size();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//退出并继续下一轮检测</span></span><br><span class=\"line\">          scheduleNewIdleChannelDetector(timeout.task());</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//存放空闲channel</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdleChannel</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> Channel channel;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> start;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> AtomicBoolean owned = <span class=\"keyword\">new</span> AtomicBoolean(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">      IdleChannel(Channel channel, <span class=\"keyword\">long</span> start) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.channel = assertNotNull(channel, <span class=\"string\">\"channel\"</span>);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">takeOwnership</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> owned.compareAndSet(<span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;...&#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//存放channel的创建时间</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChannelCreation</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> creationTime;</span><br><span class=\"line\">      <span class=\"keyword\">final</span> Object partitionKey;</span><br><span class=\"line\">      ChannelCreation(<span class=\"keyword\">long</span> creationTime, Object partitionKey) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.creationTime = creationTime;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.partitionKey = partitionKey;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里才是channel的终结！！！</p>\n<p>channel被终结了，但有些还存活的channel还在请求的路上，还有很重要的两点没说到，就是 <strong>请求超时</strong> 和 <strong>读取超时</strong>。<br>每个<code>NettyResponseFuture</code>都持有一个<code>TimeoutsHolder</code>来计算 <strong>requestTimeout</strong> 和 <strong>readTimeout</strong> 是否过期。在ResponseFuture获取连接后，以及获取成功向服务器发送数据后，都会分别启动请求超时和读取超时两个定时器。通过阅读源码，可以发现 <strong>requestTimeout</strong> 其实是包括了 <strong>readTimeout</strong>，如果请求剩余时间小于读取超时时间时，<code>startReadTimeout</code>是不会启动readTimeout定时器的。下面只贴上<code>TimeoutsHolder</code>的部分源码，<code>RequestTimeoutTimerTask</code>和<code>ReadTimeoutTimerTask</code>可以自行阅读。</p>\n<p><font color=#f28080>对于这两个参数，需要说明一点就是，一旦超时过期，channel和future都会被close掉，如果读超设置比请超长则是无意义的，只会以requestTimeout为准。</font></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeoutsHolder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicBoolean cancelled = <span class=\"keyword\">new</span> AtomicBoolean();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Timer nettyTimer;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> NettyRequestSender requestSender;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> requestTimeoutMillisTime;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> readTimeoutValue;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> NettyResponseFuture&lt;?&gt; nettyResponseFuture;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Timeout requestTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> Timeout readTimeout;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TimeoutsHolder</span><span class=\"params\">(Timer nettyTimer, NettyResponseFuture&lt;?&gt; nettyResponseFuture, NettyRequestSender requestSender, AsyncHttpClientConfig config)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyTimer = nettyTimer;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.nettyResponseFuture = nettyResponseFuture;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.requestSender = requestSender;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.readTimeoutValue = config.getReadTimeout();</span><br><span class=\"line\">      <span class=\"keyword\">int</span> requestTimeoutInMs = nettyResponseFuture.getTargetRequest().getRequestTimeout();</span><br><span class=\"line\">      <span class=\"comment\">//每个请求都可以独立设置请求超时时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeoutInMs == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          requestTimeoutInMs = config.getRequestTimeout();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeoutInMs != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//请求的到期时间，启动请求超时定时器</span></span><br><span class=\"line\">          requestTimeoutMillisTime = unpreciseMillisTime() + requestTimeoutInMs;</span><br><span class=\"line\">          requestTimeout = newTimeout(<span class=\"keyword\">new</span> RequestTimeoutTimerTask(nettyResponseFuture, requestSender, <span class=\"keyword\">this</span>, requestTimeoutInMs), requestTimeoutInMs);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          requestTimeoutMillisTime = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">          requestTimeout = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startReadTimeout</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (readTimeoutValue != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">          startReadTimeout(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">startReadTimeout</span><span class=\"params\">(ReadTimeoutTimerTask task)</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果requestTimeout不为null，或者requestTimeout还没有过期并且读取超时时间&lt;请求剩余时间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (requestTimeout == <span class=\"keyword\">null</span> || (!requestTimeout.isExpired() &amp;&amp; readTimeoutValue &lt; (requestTimeoutMillisTime - unpreciseMillisTime()))) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">              task = <span class=\"keyword\">new</span> ReadTimeoutTimerTask(nettyResponseFuture, requestSender, <span class=\"keyword\">this</span>, readTimeoutValue);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          Timeout readTimeout = newTimeout(task, readTimeoutValue);</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.readTimeout = readTimeout;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (task != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          task.clean();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后最后最后。。。</p>\n<p>来总结一下ahc的连接池实现，很明显的一点整个过程都是对<code>Channel</code>的管理，而且对于连接的抢占则使用了<code>Semaphore</code>，这再方便不过了！！！对于信号量的释放，Netty的<code>ChannelGroup</code>有很大的功劳，它提供了最优雅的方式关闭channel并且释放信号量。除此之外，一堆的超时限制任务需要一个定时任务容器执行，Netty又提供了一个在面对大量任务依然稳坐泰山的<code>HashedWheelTimer</code>，有机会专门来说说这一个。还有就是<code>DefaultChannelPool</code>对存活时间的检测，实在是通俗易懂，而且基于前面说的几点，实现起来也相当方便。</p>\n<p>如果遇到基于netty的网络编程开发，对于连接资源的管理ahc确实提供了一套不错的思路，不仅对客户端，服务端也是可以试一试的！</p>\n"},{"title":"【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致","date":"2018-09-02T08:01:41.000Z","_content":"\n开始啃Dubbo时候，对其功能多样被吓到，若干功能由xml配置可任意组装，担心其复杂度过高，源码难啃。当我开始啃启动步骤的代码后，发现`ExtensionLoader`经常出现在较重要实例化的地方。\n是的，`ExtensionLoader、@SPI、@Adaptive、@Activate`可以说是Dubbo的核心，`Cluster、Protocol、Filter`等接口都被声明为SPI，什么作用呢？能根据配置动态调用被声明为SPI接口的实现类，dubbo提供了URL方式作为参数配置。\n\n---\n\n其实SPI的应用跟实现逻辑是相当简单的，但很巧妙，正文的源码分析部分只罗列出主要方法，以及简单说明其作用。\n\n- 先来看@SPI\n\n每个要成为拓展点的接口都需要被声明SPI，ExtensionLoader只加载有该注解的接口，SPI可以设置一个默认值，指向META-INF中拓展点文件的key值，如果你在url所配的参数找不到会走默认。\n\n- @Adaptive\n\n该注解能作用在类型与方法：作用于方法，默认URL作为匹配方法；作用于类型，可自定义匹配方式，不一定要URL。\n\n\n``` java\nimport com.alibaba.dubbo.common.URL;\nimport com.alibaba.dubbo.common.extension.Adaptive;\nimport com.alibaba.dubbo.common.extension.SPI;\n/**\n * SPI(\"默认值\")\n */\n@SPI(\"default_1\")\npublic interface TestAdaptiveExt {\n  /*\n   * Adaptive({参数名数组})\n   */\n  @Adaptive({\"key_name_1\"})\n  String getChlidInfo(URL url);\n}\n\npublic class TestAdaptiveExtImpl1 implements TestAdaptiveExt {\n  public String getChlidInfo(URL url) {\n    return \"test1\";\n  }\n}\npublic class TestAdaptiveExtImpl2 implements TestAdaptiveExt {\n  public String getChlidInfo(URL url) {\n    return \"test2\";\n  }\n}\n\n@Test\npublic void testAdaptive() {\n  ExtensionLoader<TestAdaptiveExt> loader = ExtensionLoader.getExtensionLoader(TestAdaptiveExt.class);\n  TestAdaptiveExt testAdaptiveExt = loader.getAdaptiveExtension();\n  /**\n   * 控制台输出：test2\n   */\n  URL url = URL.valueOf(\"test://localhost/test?Adaptive_key_name=default_2\");\n  System.out.println(testAdaptiveExt.getChlidInfo(url));\n}\n```\nresources/META-INF/dubbo/internal/com.hongframe.extension.TestAdaptiveExt\n\n``` properties\ndefault_1=com.hongframe.extension.impl.TestAdaptiveExtImpl1\ndefault_2=com.hongframe.extension.impl.TestAdaptiveExtImpl2\n```\n\n- @Activate\n\nActivate提供了`group、value、before、after、order`，除前两个用来筛选外，其余三个均排序，该注解只能作用于类型，方法无效。\n\n``` java\n@SPI\npublic interface TestActivateExt {\n  String print();\n}\n\n@Activate(value = \"key_name_1\", group = \"xxx_group\")\npublic class TestActivateExtImpl1 implements TestActivateExt {\n  public String print() {\n    return \"TestActivateExtImpl1\";\n  }\n}\n\n@Activate(\"key_name_2\")\npublic class TestActivateExtImpl2 implements TestActivateExt {\n  public String print() {\n    return \"TestActivateExtImpl2\";\n  }\n}\n\n@Test\npublic void testActivate() {\n  ExtensionLoader<TestActivateExt> testActivateExtExtensionLoader = ExtensionLoader.getExtensionLoader(TestActivateExt.class);\n  URL url = URL.valueOf(\"test://localhost/test\");\n  /*\n   * 此处，对于Activate，URI的key=value只能被key激活，但对相同key的Adaptive方法能达到组合效果\n   * 参考CacheFilter与CacheFactory的用法\n   */\n  /*\n   * 这里有个值得注意的地方：\n   * 如果给url添加key_name_1=<-default,...,...>作为参数的话，是不匹配Activate.value的，转而匹配配置文件中的key，例如active1，active2\n   */\n  url = url.addParameter(\"key_name_1\", \"default_1\");\n  List<TestActivateExt> testActivateExts = testActivateExtExtensionLoader.getActivateExtension(url, \"key_name_1\");\n  for(TestActivateExt ext : testActivateExts)\n   System.out.println(ext.print());\n}\n```\n\nresources/META-INF/dubbo/internal/com.hongframe.extension.TestActivateExt\n``` properties\nactive1=com.hongframe.extension.impl.TestActivateExtImpl1\nactive2=com.hongframe.extension.impl.TestActivateExtImpl2\n```\n\n- 正题，源码分析\n\nDubbo为每个拓展点准备一个ExtensionLoader，将DUBBO_INTERNAL_DIRECTORY、SERVICES_DIRECTORY下的配置文件全部缓存到以下成员变量中。\n\n\n``` java\npublic class ExtensionLoader<T> {\n  //一个拓展点一个ExtensionLoader\n  private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();\n  //拓展点实现类的实例化\n  private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<Class<?>, Object>();\n\n  // ==============================\n  //拓展点\n  private final Class<?> type;\n  private final ExtensionFactory objectFactory;\n  //缓存拓展点实现的名称\n  private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();\n  //缓存拓展点的实现类\n  private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();\n  //实现类的Activate注解配置\n  private final Map<String, Activate> cachedActivates = new ConcurrentHashMap<String, Activate>();\n  private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<String, Holder<Object>>();\n  //至关重要的，通过代码注入后得到实例化\n  private final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();\n  //拓展点实现类被声明为Adaptive，至多一个\n  private volatile Class<?> cachedAdaptiveClass = null;\n  //SPI(\"cachedDefaultName\") 默认实现类key值\n  private String cachedDefaultName;\n  private volatile Throwable createAdaptiveInstanceError;\n  //拓展点包装类\n  private Set<Class<?>> cachedWrapperClasses;\n\n  public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n    if (type == null)\n      //非空\n    if (!type.isInterface()) {\n      //必须是接口\n    }\n    if (!withExtensionAnnotation(type)) {\n        //必须声明@SPI\n    }\n    ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    if (loader == null) {\n        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n        loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    }\n    return loader;\n  }\n}\n```\n\n`getAdaptiveExtension`获取拓展点实例化对象，这里会动态实例化一个拓展点实现，将其set入Holder，这个对象包装了拓展点基础的实现类，成为一个动态代理。\n\n``` java\npublic T getAdaptiveExtension() {\n  Object instance = cachedAdaptiveInstance.get();\n  if (instance == null) {\n    if (createAdaptiveInstanceError == null) {\n      synchronized (cachedAdaptiveInstance) {\n        instance = cachedAdaptiveInstance.get();\n        if (instance == null) {\n          try {\n            //创建Adaptive拓展点接口的实例对象\n            instance = createAdaptiveExtension();\n            cachedAdaptiveInstance.set(instance);\n          } catch (Throwable t) {\n            createAdaptiveInstanceError = t;\n            throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n          }\n        }\n      }\n    } else {\n      //IllegalStateException\n    }\n  }\n  return (T) instance;\n}\n\nprivate T createAdaptiveExtension() {\n  try {\n    //向拓展点的成员变量注入对象\n    return injectExtension(\n        //加载，动态生成code，编译，实例化\n        (T) getAdaptiveExtensionClass().newInstance());\n  } catch (Exception e) {\n    throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n  }\n}\nprivate Class<?> getAdaptiveExtensionClass() {\n  //加载成员变量type指定的配置文件\n  getExtensionClasses();\n  if (cachedAdaptiveClass != null) {\n    return cachedAdaptiveClass;\n  }\n  //初始化：生成拓展点实现类代码，以TestAdaptiveExt为例\n  return cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n```\n\n`createAdaptiveExtensionClass()`方法生成的TestAdaptiveExt实现类，详细逻辑自行阅读`createAdaptiveExtensionClassCode()`。\n``` java\npackage com.hongframe.extension;\n\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\n\npublic class TestAdaptiveExt$Adaptive implements com.hongframe.extension.TestAdaptiveExt {\n\npublic java.lang.String getChlidInfo(com.alibaba.dubbo.common.URL arg0) {\n\n\tif (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n\tcom.alibaba.dubbo.common.URL url = arg0;\n\tString extName = url.getParameter(\"key_name_1\", url.getParameter(\"key_name_2\"));\n\tif(extName == null) throw new IllegalStateException(\"Fail to get extension(com.hongframe.extension.TestAdaptiveExt) name from url(\" + url.toString() + \") use keys([key_name_1, key_name_2])\");\n\tcom.hongframe.extension.TestAdaptiveExt extension =\n\t\t\t\t\t(com.hongframe.extension.TestAdaptiveExt)ExtensionLoader\n\t\t\t\t\t\t\t\t.getExtensionLoader(com.hongframe.extension.TestAdaptiveExt.class).getExtension(extName);\n\treturn extension.getChlidInfo(arg0);\n\t}\n}\n```\n\n下面是加载拓展点实现类的代码，主要通过META-INF里的配置文件找到相应的类。\n``` java\nprivate Map<String, Class<?>> getExtensionClasses() {\n  //省略单例双检代码\n  //\n  classes = loadExtensionClasses();\n  cachedClasses.set(classes);\n  return classes;\n}\n\n// synchronized in getExtensionClasses\nprivate Map<String, Class<?>> loadExtensionClasses() {\n  final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n  if (defaultAnnotation != null) {\n    String value = defaultAnnotation.value();\n    if ((value = value.trim()).length() > 0) {\n      //至多一个默认拓展实现类名\n      String[] names = NAME_SEPARATOR.split(value);\n      if (names.length > 1) {\n        //IllegalStateException\n      }\n      if (names.length == 1) cachedDefaultName = names[0];\n    }\n  }\n\n  Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n  //load配置文件\n  //其中loadResource是很简单的词法解析器，loadClass则负责将实现类缓存在成员变量\n  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);//\"META-INF/dubbo/internal/\"\n  loadDirectory(extensionClasses, DUBBO_DIRECTORY);//\"META-INF/dubbo/\"\n  loadDirectory(extensionClasses, SERVICES_DIRECTORY);//\"META-INF/services/\"\n  return extensionClasses;\n}\n\nprivate void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL,//抛异常用的，没什么实际用处\nClass<?> clazz,//配置文件中的value\n//配置文件中的key\nString name) throws NoSuchMethodException {\n  //是否拓展点type的实现类\n  if (!type.isAssignableFrom(clazz)) {\n    //IllegalStateException\n  }\n  //该拓展点实现类是否被声明为Adaptive\n  if (clazz.isAnnotationPresent(Adaptive.class)) {\n    if (cachedAdaptiveClass == null) {\n      cachedAdaptiveClass = clazz;\n    } else if (!cachedAdaptiveClass.equals(clazz)) {\n      //IllegalStateException，只能声明一个实现类\n    }\n    //是否为包装类\n  } else if (isWrapperClass(clazz)) {\n    Set<Class<?>> wrappers = cachedWrapperClasses;\n    if (wrappers == null) {\n      cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n      wrappers = cachedWrapperClasses;\n    }\n    wrappers.add(clazz);\n  } else {\n    //这一步是加载被声明为Activate的实现累的\n    clazz.getConstructor();\n    if (name == null || name.length() == 0) {\n      //其中涉及到一个过期的注解@Extension\n      //如果配置文件没有设置key值，将实现类simplename作为默认\n      name = findAnnotationName(clazz);\n      if (name.length() == 0) {\n        //IllegalStateException\n      }\n    }\n    String[] names = NAME_SEPARATOR.split(name);\n    if (names != null && names.length > 0) {\n      Activate activate = clazz.getAnnotation(Activate.class);\n      if (activate != null) {\n        cachedActivates.put(names[0], activate);\n      }\n      for (String n : names) {\n        if (!cachedNames.containsKey(clazz)) {\n          cachedNames.put(clazz, n);\n        }\n        Class<?> c = extensionClasses.get(n);\n        if (c == null) {\n          //把不同key相同class全都塞进去\n          extensionClasses.put(n, clazz);\n        } else if (c != clazz) {\n          //IllegalStateException\n        }\n      }\n    }\n  }\n}\n```\n\n下面是获取Activate拓展实现的列表方法，通常这类拓展都是需要AOP来处理事情的，类似Filter接口。\n\n``` java\npublic List<T> getActivateExtension(URL url,\n//url的param-key列表\nString[] values, String group) {\n  List<T> exts = new ArrayList<T>();\n  List<String> names = values == null ? new ArrayList<String>(0) : Arrays.asList(values);\n  //这部分从url中拿去参数，匹配符合条件的拓展点\n  //如果key=value，后者出现-default，则表示不走匹配URL的方式\n  if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n    getExtensionClasses();\n    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {\n      String name = entry.getKey();\n      Activate activate = entry.getValue();\n      if (isMatchGroup(group, activate.group())) {\n        T ext = getExtension(name);\n        if (!names.contains(name)\n              && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)\n              && isActive(activate, url)) {\n          exts.add(ext);\n        }\n      }\n    }\n    //根据before、after、order优先级依次排序\n    Collections.sort(exts, ActivateComparator.COMPARATOR);\n  }\n  //遍历values给到的参数\n  List<T> usrs = new ArrayList<T>();\n  for (int i = 0; i < names.size(); i++) {\n      String name = names.get(i);\n      //跳过被标记-的拓展点\n      if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n              && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n          if (Constants.DEFAULT_KEY.equals(name)) {\n              if (!usrs.isEmpty()) {\n                exts.addAll(0, usrs);\n                usrs.clear();\n              }\n          } else {\n            //注意，这里的name是配置文件中的key\n            T ext = getExtension(name);\n            usrs.add(ext);\n          }\n      }\n  }\n  if (!usrs.isEmpty()) {\n    exts.addAll(usrs);\n  }\n  return exts;\n}\n```\n\n- 总结\n\n其实没多少可以总结的，dubbo的微内核其实就一个ExtensionLoader类，但弄清之后，可以较为清晰的研究dubbo各种功能的源码，因为其功能也是拓展点之一，只要找到对于实现即可。\n","source":"_posts/20180902-【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致.md","raw":"---\ntitle: 【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致\ndate: 2018-09-02 16:01:41\ntags:\n  - java　\n  - Dubbo\n  - SPI\n  - 反射\n  - rpc\ncategories:\n  - rpc框架\n---\n\n开始啃Dubbo时候，对其功能多样被吓到，若干功能由xml配置可任意组装，担心其复杂度过高，源码难啃。当我开始啃启动步骤的代码后，发现`ExtensionLoader`经常出现在较重要实例化的地方。\n是的，`ExtensionLoader、@SPI、@Adaptive、@Activate`可以说是Dubbo的核心，`Cluster、Protocol、Filter`等接口都被声明为SPI，什么作用呢？能根据配置动态调用被声明为SPI接口的实现类，dubbo提供了URL方式作为参数配置。\n\n---\n\n其实SPI的应用跟实现逻辑是相当简单的，但很巧妙，正文的源码分析部分只罗列出主要方法，以及简单说明其作用。\n\n- 先来看@SPI\n\n每个要成为拓展点的接口都需要被声明SPI，ExtensionLoader只加载有该注解的接口，SPI可以设置一个默认值，指向META-INF中拓展点文件的key值，如果你在url所配的参数找不到会走默认。\n\n- @Adaptive\n\n该注解能作用在类型与方法：作用于方法，默认URL作为匹配方法；作用于类型，可自定义匹配方式，不一定要URL。\n\n\n``` java\nimport com.alibaba.dubbo.common.URL;\nimport com.alibaba.dubbo.common.extension.Adaptive;\nimport com.alibaba.dubbo.common.extension.SPI;\n/**\n * SPI(\"默认值\")\n */\n@SPI(\"default_1\")\npublic interface TestAdaptiveExt {\n  /*\n   * Adaptive({参数名数组})\n   */\n  @Adaptive({\"key_name_1\"})\n  String getChlidInfo(URL url);\n}\n\npublic class TestAdaptiveExtImpl1 implements TestAdaptiveExt {\n  public String getChlidInfo(URL url) {\n    return \"test1\";\n  }\n}\npublic class TestAdaptiveExtImpl2 implements TestAdaptiveExt {\n  public String getChlidInfo(URL url) {\n    return \"test2\";\n  }\n}\n\n@Test\npublic void testAdaptive() {\n  ExtensionLoader<TestAdaptiveExt> loader = ExtensionLoader.getExtensionLoader(TestAdaptiveExt.class);\n  TestAdaptiveExt testAdaptiveExt = loader.getAdaptiveExtension();\n  /**\n   * 控制台输出：test2\n   */\n  URL url = URL.valueOf(\"test://localhost/test?Adaptive_key_name=default_2\");\n  System.out.println(testAdaptiveExt.getChlidInfo(url));\n}\n```\nresources/META-INF/dubbo/internal/com.hongframe.extension.TestAdaptiveExt\n\n``` properties\ndefault_1=com.hongframe.extension.impl.TestAdaptiveExtImpl1\ndefault_2=com.hongframe.extension.impl.TestAdaptiveExtImpl2\n```\n\n- @Activate\n\nActivate提供了`group、value、before、after、order`，除前两个用来筛选外，其余三个均排序，该注解只能作用于类型，方法无效。\n\n``` java\n@SPI\npublic interface TestActivateExt {\n  String print();\n}\n\n@Activate(value = \"key_name_1\", group = \"xxx_group\")\npublic class TestActivateExtImpl1 implements TestActivateExt {\n  public String print() {\n    return \"TestActivateExtImpl1\";\n  }\n}\n\n@Activate(\"key_name_2\")\npublic class TestActivateExtImpl2 implements TestActivateExt {\n  public String print() {\n    return \"TestActivateExtImpl2\";\n  }\n}\n\n@Test\npublic void testActivate() {\n  ExtensionLoader<TestActivateExt> testActivateExtExtensionLoader = ExtensionLoader.getExtensionLoader(TestActivateExt.class);\n  URL url = URL.valueOf(\"test://localhost/test\");\n  /*\n   * 此处，对于Activate，URI的key=value只能被key激活，但对相同key的Adaptive方法能达到组合效果\n   * 参考CacheFilter与CacheFactory的用法\n   */\n  /*\n   * 这里有个值得注意的地方：\n   * 如果给url添加key_name_1=<-default,...,...>作为参数的话，是不匹配Activate.value的，转而匹配配置文件中的key，例如active1，active2\n   */\n  url = url.addParameter(\"key_name_1\", \"default_1\");\n  List<TestActivateExt> testActivateExts = testActivateExtExtensionLoader.getActivateExtension(url, \"key_name_1\");\n  for(TestActivateExt ext : testActivateExts)\n   System.out.println(ext.print());\n}\n```\n\nresources/META-INF/dubbo/internal/com.hongframe.extension.TestActivateExt\n``` properties\nactive1=com.hongframe.extension.impl.TestActivateExtImpl1\nactive2=com.hongframe.extension.impl.TestActivateExtImpl2\n```\n\n- 正题，源码分析\n\nDubbo为每个拓展点准备一个ExtensionLoader，将DUBBO_INTERNAL_DIRECTORY、SERVICES_DIRECTORY下的配置文件全部缓存到以下成员变量中。\n\n\n``` java\npublic class ExtensionLoader<T> {\n  //一个拓展点一个ExtensionLoader\n  private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();\n  //拓展点实现类的实例化\n  private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<Class<?>, Object>();\n\n  // ==============================\n  //拓展点\n  private final Class<?> type;\n  private final ExtensionFactory objectFactory;\n  //缓存拓展点实现的名称\n  private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<Class<?>, String>();\n  //缓存拓展点的实现类\n  private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<Map<String, Class<?>>>();\n  //实现类的Activate注解配置\n  private final Map<String, Activate> cachedActivates = new ConcurrentHashMap<String, Activate>();\n  private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<String, Holder<Object>>();\n  //至关重要的，通过代码注入后得到实例化\n  private final Holder<Object> cachedAdaptiveInstance = new Holder<Object>();\n  //拓展点实现类被声明为Adaptive，至多一个\n  private volatile Class<?> cachedAdaptiveClass = null;\n  //SPI(\"cachedDefaultName\") 默认实现类key值\n  private String cachedDefaultName;\n  private volatile Throwable createAdaptiveInstanceError;\n  //拓展点包装类\n  private Set<Class<?>> cachedWrapperClasses;\n\n  public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n    if (type == null)\n      //非空\n    if (!type.isInterface()) {\n      //必须是接口\n    }\n    if (!withExtensionAnnotation(type)) {\n        //必须声明@SPI\n    }\n    ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    if (loader == null) {\n        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));\n        loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);\n    }\n    return loader;\n  }\n}\n```\n\n`getAdaptiveExtension`获取拓展点实例化对象，这里会动态实例化一个拓展点实现，将其set入Holder，这个对象包装了拓展点基础的实现类，成为一个动态代理。\n\n``` java\npublic T getAdaptiveExtension() {\n  Object instance = cachedAdaptiveInstance.get();\n  if (instance == null) {\n    if (createAdaptiveInstanceError == null) {\n      synchronized (cachedAdaptiveInstance) {\n        instance = cachedAdaptiveInstance.get();\n        if (instance == null) {\n          try {\n            //创建Adaptive拓展点接口的实例对象\n            instance = createAdaptiveExtension();\n            cachedAdaptiveInstance.set(instance);\n          } catch (Throwable t) {\n            createAdaptiveInstanceError = t;\n            throw new IllegalStateException(\"fail to create adaptive instance: \" + t.toString(), t);\n          }\n        }\n      }\n    } else {\n      //IllegalStateException\n    }\n  }\n  return (T) instance;\n}\n\nprivate T createAdaptiveExtension() {\n  try {\n    //向拓展点的成员变量注入对象\n    return injectExtension(\n        //加载，动态生成code，编译，实例化\n        (T) getAdaptiveExtensionClass().newInstance());\n  } catch (Exception e) {\n    throw new IllegalStateException(\"Can not create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n  }\n}\nprivate Class<?> getAdaptiveExtensionClass() {\n  //加载成员变量type指定的配置文件\n  getExtensionClasses();\n  if (cachedAdaptiveClass != null) {\n    return cachedAdaptiveClass;\n  }\n  //初始化：生成拓展点实现类代码，以TestAdaptiveExt为例\n  return cachedAdaptiveClass = createAdaptiveExtensionClass();\n}\n```\n\n`createAdaptiveExtensionClass()`方法生成的TestAdaptiveExt实现类，详细逻辑自行阅读`createAdaptiveExtensionClassCode()`。\n``` java\npackage com.hongframe.extension;\n\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\n\npublic class TestAdaptiveExt$Adaptive implements com.hongframe.extension.TestAdaptiveExt {\n\npublic java.lang.String getChlidInfo(com.alibaba.dubbo.common.URL arg0) {\n\n\tif (arg0 == null) throw new IllegalArgumentException(\"url == null\");\n\tcom.alibaba.dubbo.common.URL url = arg0;\n\tString extName = url.getParameter(\"key_name_1\", url.getParameter(\"key_name_2\"));\n\tif(extName == null) throw new IllegalStateException(\"Fail to get extension(com.hongframe.extension.TestAdaptiveExt) name from url(\" + url.toString() + \") use keys([key_name_1, key_name_2])\");\n\tcom.hongframe.extension.TestAdaptiveExt extension =\n\t\t\t\t\t(com.hongframe.extension.TestAdaptiveExt)ExtensionLoader\n\t\t\t\t\t\t\t\t.getExtensionLoader(com.hongframe.extension.TestAdaptiveExt.class).getExtension(extName);\n\treturn extension.getChlidInfo(arg0);\n\t}\n}\n```\n\n下面是加载拓展点实现类的代码，主要通过META-INF里的配置文件找到相应的类。\n``` java\nprivate Map<String, Class<?>> getExtensionClasses() {\n  //省略单例双检代码\n  //\n  classes = loadExtensionClasses();\n  cachedClasses.set(classes);\n  return classes;\n}\n\n// synchronized in getExtensionClasses\nprivate Map<String, Class<?>> loadExtensionClasses() {\n  final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n  if (defaultAnnotation != null) {\n    String value = defaultAnnotation.value();\n    if ((value = value.trim()).length() > 0) {\n      //至多一个默认拓展实现类名\n      String[] names = NAME_SEPARATOR.split(value);\n      if (names.length > 1) {\n        //IllegalStateException\n      }\n      if (names.length == 1) cachedDefaultName = names[0];\n    }\n  }\n\n  Map<String, Class<?>> extensionClasses = new HashMap<String, Class<?>>();\n  //load配置文件\n  //其中loadResource是很简单的词法解析器，loadClass则负责将实现类缓存在成员变量\n  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);//\"META-INF/dubbo/internal/\"\n  loadDirectory(extensionClasses, DUBBO_DIRECTORY);//\"META-INF/dubbo/\"\n  loadDirectory(extensionClasses, SERVICES_DIRECTORY);//\"META-INF/services/\"\n  return extensionClasses;\n}\n\nprivate void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL,//抛异常用的，没什么实际用处\nClass<?> clazz,//配置文件中的value\n//配置文件中的key\nString name) throws NoSuchMethodException {\n  //是否拓展点type的实现类\n  if (!type.isAssignableFrom(clazz)) {\n    //IllegalStateException\n  }\n  //该拓展点实现类是否被声明为Adaptive\n  if (clazz.isAnnotationPresent(Adaptive.class)) {\n    if (cachedAdaptiveClass == null) {\n      cachedAdaptiveClass = clazz;\n    } else if (!cachedAdaptiveClass.equals(clazz)) {\n      //IllegalStateException，只能声明一个实现类\n    }\n    //是否为包装类\n  } else if (isWrapperClass(clazz)) {\n    Set<Class<?>> wrappers = cachedWrapperClasses;\n    if (wrappers == null) {\n      cachedWrapperClasses = new ConcurrentHashSet<Class<?>>();\n      wrappers = cachedWrapperClasses;\n    }\n    wrappers.add(clazz);\n  } else {\n    //这一步是加载被声明为Activate的实现累的\n    clazz.getConstructor();\n    if (name == null || name.length() == 0) {\n      //其中涉及到一个过期的注解@Extension\n      //如果配置文件没有设置key值，将实现类simplename作为默认\n      name = findAnnotationName(clazz);\n      if (name.length() == 0) {\n        //IllegalStateException\n      }\n    }\n    String[] names = NAME_SEPARATOR.split(name);\n    if (names != null && names.length > 0) {\n      Activate activate = clazz.getAnnotation(Activate.class);\n      if (activate != null) {\n        cachedActivates.put(names[0], activate);\n      }\n      for (String n : names) {\n        if (!cachedNames.containsKey(clazz)) {\n          cachedNames.put(clazz, n);\n        }\n        Class<?> c = extensionClasses.get(n);\n        if (c == null) {\n          //把不同key相同class全都塞进去\n          extensionClasses.put(n, clazz);\n        } else if (c != clazz) {\n          //IllegalStateException\n        }\n      }\n    }\n  }\n}\n```\n\n下面是获取Activate拓展实现的列表方法，通常这类拓展都是需要AOP来处理事情的，类似Filter接口。\n\n``` java\npublic List<T> getActivateExtension(URL url,\n//url的param-key列表\nString[] values, String group) {\n  List<T> exts = new ArrayList<T>();\n  List<String> names = values == null ? new ArrayList<String>(0) : Arrays.asList(values);\n  //这部分从url中拿去参数，匹配符合条件的拓展点\n  //如果key=value，后者出现-default，则表示不走匹配URL的方式\n  if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) {\n    getExtensionClasses();\n    for (Map.Entry<String, Activate> entry : cachedActivates.entrySet()) {\n      String name = entry.getKey();\n      Activate activate = entry.getValue();\n      if (isMatchGroup(group, activate.group())) {\n        T ext = getExtension(name);\n        if (!names.contains(name)\n              && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)\n              && isActive(activate, url)) {\n          exts.add(ext);\n        }\n      }\n    }\n    //根据before、after、order优先级依次排序\n    Collections.sort(exts, ActivateComparator.COMPARATOR);\n  }\n  //遍历values给到的参数\n  List<T> usrs = new ArrayList<T>();\n  for (int i = 0; i < names.size(); i++) {\n      String name = names.get(i);\n      //跳过被标记-的拓展点\n      if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)\n              && !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) {\n          if (Constants.DEFAULT_KEY.equals(name)) {\n              if (!usrs.isEmpty()) {\n                exts.addAll(0, usrs);\n                usrs.clear();\n              }\n          } else {\n            //注意，这里的name是配置文件中的key\n            T ext = getExtension(name);\n            usrs.add(ext);\n          }\n      }\n  }\n  if (!usrs.isEmpty()) {\n    exts.addAll(usrs);\n  }\n  return exts;\n}\n```\n\n- 总结\n\n其实没多少可以总结的，dubbo的微内核其实就一个ExtensionLoader类，但弄清之后，可以较为清晰的研究dubbo各种功能的源码，因为其功能也是拓展点之一，只要找到对于实现即可。\n","slug":"20180902-【Dubbo源码分析】SPI机制，将URL与可插拔拓展融合到极致","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7t2002u4ejdb72xf5gx","content":"<p>开始啃Dubbo时候，对其功能多样被吓到，若干功能由xml配置可任意组装，担心其复杂度过高，源码难啃。当我开始啃启动步骤的代码后，发现<code>ExtensionLoader</code>经常出现在较重要实例化的地方。<br>是的，<code>ExtensionLoader、@SPI、@Adaptive、@Activate</code>可以说是Dubbo的核心，<code>Cluster、Protocol、Filter</code>等接口都被声明为SPI，什么作用呢？能根据配置动态调用被声明为SPI接口的实现类，dubbo提供了URL方式作为参数配置。</p>\n<hr>\n<p>其实SPI的应用跟实现逻辑是相当简单的，但很巧妙，正文的源码分析部分只罗列出主要方法，以及简单说明其作用。</p>\n<ul>\n<li>先来看@SPI</li>\n</ul>\n<p>每个要成为拓展点的接口都需要被声明SPI，ExtensionLoader只加载有该注解的接口，SPI可以设置一个默认值，指向META-INF中拓展点文件的key值，如果你在url所配的参数找不到会走默认。</p>\n<ul>\n<li>@Adaptive</li>\n</ul>\n<p>该注解能作用在类型与方法：作用于方法，默认URL作为匹配方法；作用于类型，可自定义匹配方式，不一定要URL。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.SPI;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SPI(\"默认值\")</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SPI</span>(<span class=\"string\">\"default_1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Adaptive(&#123;参数名数组&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Adaptive</span>(&#123;<span class=\"string\">\"key_name_1\"</span>&#125;)</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExtImpl1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test1\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExtImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test2\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAdaptive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ExtensionLoader&lt;TestAdaptiveExt&gt; loader = ExtensionLoader.getExtensionLoader(TestAdaptiveExt<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  TestAdaptiveExt testAdaptiveExt = loader.getAdaptiveExtension();</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 控制台输出：test2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  URL url = URL.valueOf(<span class=\"string\">\"test://localhost/test?Adaptive_key_name=default_2\"</span>);</span><br><span class=\"line\">  System.out.println(testAdaptiveExt.getChlidInfo(url));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestAdaptiveExt</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">default_1</span>=<span class=\"string\">com.hongframe.extension.impl.TestAdaptiveExtImpl1</span></span><br><span class=\"line\"><span class=\"attr\">default_2</span>=<span class=\"string\">com.hongframe.extension.impl.TestAdaptiveExtImpl2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@Activate</li>\n</ul>\n<p>Activate提供了<code>group、value、before、after、order</code>，除前两个用来筛选外，其余三个均排序，该注解只能作用于类型，方法无效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">print</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Activate</span>(value = <span class=\"string\">\"key_name_1\"</span>, group = <span class=\"string\">\"xxx_group\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestActivateExtImpl1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"TestActivateExtImpl1\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Activate</span>(<span class=\"string\">\"key_name_2\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestActivateExtImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"TestActivateExtImpl2\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testActivate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ExtensionLoader&lt;TestActivateExt&gt; testActivateExtExtensionLoader = ExtensionLoader.getExtensionLoader(TestActivateExt<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  URL url = URL.valueOf(<span class=\"string\">\"test://localhost/test\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 此处，对于Activate，URI的key=value只能被key激活，但对相同key的Adaptive方法能达到组合效果</span></span><br><span class=\"line\"><span class=\"comment\">   * 参考CacheFilter与CacheFactory的用法</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 这里有个值得注意的地方：</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果给url添加key_name_1=&lt;-default,...,...&gt;作为参数的话，是不匹配Activate.value的，转而匹配配置文件中的key，例如active1，active2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  url = url.addParameter(<span class=\"string\">\"key_name_1\"</span>, <span class=\"string\">\"default_1\"</span>);</span><br><span class=\"line\">  List&lt;TestActivateExt&gt; testActivateExts = testActivateExtExtensionLoader.getActivateExtension(url, <span class=\"string\">\"key_name_1\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(TestActivateExt ext : testActivateExts)</span><br><span class=\"line\">   System.out.println(ext.print());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestActivateExt</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">active1</span>=<span class=\"string\">com.hongframe.extension.impl.TestActivateExtImpl1</span></span><br><span class=\"line\"><span class=\"attr\">active2</span>=<span class=\"string\">com.hongframe.extension.impl.TestActivateExtImpl2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正题，源码分析</li>\n</ul>\n<p>Dubbo为每个拓展点准备一个ExtensionLoader，将DUBBO_INTERNAL_DIRECTORY、SERVICES_DIRECTORY下的配置文件全部缓存到以下成员变量中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtensionLoader</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一个拓展点一个ExtensionLoader</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//拓展点实现类的实例化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ==============================</span></span><br><span class=\"line\">  <span class=\"comment\">//拓展点</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; type;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExtensionFactory objectFactory;</span><br><span class=\"line\">  <span class=\"comment\">//缓存拓展点实现的名称</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//缓存拓展点的实现类</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class=\"keyword\">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//实现类的Activate注解配置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//至关重要的，通过代码注入后得到实例化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class=\"keyword\">new</span> Holder&lt;Object&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//拓展点实现类被声明为Adaptive，至多一个</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//SPI(\"cachedDefaultName\") 默认实现类key值</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String cachedDefaultName;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class=\"line\">  <span class=\"comment\">//拓展点包装类</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ExtensionLoader&lt;T&gt; <span class=\"title\">getExtensionLoader</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"comment\">//非空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isInterface()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//必须是接口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//必须声明@SPI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        EXTENSION_LOADERS.putIfAbsent(type, <span class=\"keyword\">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class=\"line\">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getAdaptiveExtension</code>获取拓展点实例化对象，这里会动态实例化一个拓展点实现，将其set入Holder，这个对象包装了拓展点基础的实现类，成为一个动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Object instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (createAdaptiveInstanceError == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class=\"line\">        instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建Adaptive拓展点接口的实例对象</span></span><br><span class=\"line\">            instance = createAdaptiveExtension();</span><br><span class=\"line\">            cachedAdaptiveInstance.set(instance);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            createAdaptiveInstanceError = t;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + t.toString(), t);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//向拓展点的成员变量注入对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> injectExtension(</span><br><span class=\"line\">        <span class=\"comment\">//加载，动态生成code，编译，实例化</span></span><br><span class=\"line\">        (T) getAdaptiveExtensionClass().newInstance());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Can not create adaptive extension \"</span> + type + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载成员变量type指定的配置文件</span></span><br><span class=\"line\">  getExtensionClasses();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cachedAdaptiveClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cachedAdaptiveClass;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//初始化：生成拓展点实现类代码，以TestAdaptiveExt为例</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createAdaptiveExtensionClass()</code>方法生成的TestAdaptiveExt实现类，详细逻辑自行阅读<code>createAdaptiveExtensionClassCode()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hongframe.extension;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExt</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">com</span>.<span class=\"title\">hongframe</span>.<span class=\"title\">extension</span>.<span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> java.lang.<span class=\"function\">String <span class=\"title\">getChlidInfo</span><span class=\"params\">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">\tcom.alibaba.dubbo.common.URL url = arg0;</span><br><span class=\"line\">\tString extName = url.getParameter(<span class=\"string\">\"key_name_1\"</span>, url.getParameter(<span class=\"string\">\"key_name_2\"</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(extName == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(com.hongframe.extension.TestAdaptiveExt) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([key_name_1, key_name_2])\"</span>);</span><br><span class=\"line\">\tcom.hongframe.extension.TestAdaptiveExt extension =</span><br><span class=\"line\">\t\t\t\t\t(com.hongframe.extension.TestAdaptiveExt)ExtensionLoader</span><br><span class=\"line\">\t\t\t\t\t\t\t\t.getExtensionLoader(com.hongframe.extension.TestAdaptiveExt<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">getExtension</span>(<span class=\"title\">extName</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> extension.getChlidInfo(arg0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是加载拓展点实现类的代码，主要通过META-INF里的配置文件找到相应的类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//省略单例双检代码</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  classes = loadExtensionClasses();</span><br><span class=\"line\">  cachedClasses.set(classes);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> classes;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// synchronized in getExtensionClasses</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (defaultAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    String value = defaultAnnotation.value();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//至多一个默认拓展实现类名</span></span><br><span class=\"line\">      String[] names = NAME_SEPARATOR.split(value);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (names.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (names.length == <span class=\"number\">1</span>) cachedDefaultName = names[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//load配置文件</span></span><br><span class=\"line\">  <span class=\"comment\">//其中loadResource是很简单的词法解析器，loadClass则负责将实现类缓存在成员变量</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);<span class=\"comment\">//\"META-INF/dubbo/internal/\"</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, DUBBO_DIRECTORY);<span class=\"comment\">//\"META-INF/dubbo/\"</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, SERVICES_DIRECTORY);<span class=\"comment\">//\"META-INF/services/\"</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> extensionClasses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadClass</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL,//抛异常用的，没什么实际用处</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">Class&lt;?&gt; clazz,//配置文件中的value</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">//配置文件中的key</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">String name)</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//是否拓展点type的实现类</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//该拓展点实现类是否被声明为Adaptive</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(Adaptive<span class=\"class\">.<span class=\"keyword\">class</span>)) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cachedAdaptiveClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cachedAdaptiveClass = clazz;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//IllegalStateException，只能声明一个实现类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否为包装类</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class=\"line\">    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wrappers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cachedWrapperClasses = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">      wrappers = cachedWrapperClasses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrappers.add(clazz);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这一步是加载被声明为Activate的实现累的</span></span><br><span class=\"line\">    clazz.getConstructor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//其中涉及到一个过期的注解@Extension</span></span><br><span class=\"line\">      <span class=\"comment\">//如果配置文件没有设置key值，将实现类simplename作为默认</span></span><br><span class=\"line\">      name = findAnnotationName(clazz);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String[] names = NAME_SEPARATOR.split(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (names != <span class=\"keyword\">null</span> &amp;&amp; names.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      Activate activate = clazz.getAnnotation(Activate<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (activate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cachedActivates.put(names[<span class=\"number\">0</span>], activate);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String n : names) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class=\"line\">          cachedNames.put(clazz, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//把不同key相同class全都塞进去</span></span><br><span class=\"line\">          extensionClasses.put(n, clazz);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c != clazz) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是获取Activate拓展实现的列表方法，通常这类拓展都是需要AOP来处理事情的，类似Filter接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;T&gt; <span class=\"title\">getActivateExtension</span><span class=\"params\">(URL url,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">//url的param-key列表</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">String[] values, String group)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; exts = <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">  List&lt;String&gt; names = values == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(<span class=\"number\">0</span>) : Arrays.asList(values);</span><br><span class=\"line\">  <span class=\"comment\">//这部分从url中拿去参数，匹配符合条件的拓展点</span></span><br><span class=\"line\">  <span class=\"comment\">//如果key=value，后者出现-default，则表示不走匹配URL的方式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class=\"line\">    getExtensionClasses();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class=\"line\">      String name = entry.getKey();</span><br><span class=\"line\">      Activate activate = entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class=\"line\">        T ext = getExtension(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!names.contains(name)</span><br><span class=\"line\">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class=\"line\">              &amp;&amp; isActive(activate, url)) &#123;</span><br><span class=\"line\">          exts.add(ext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据before、after、order优先级依次排序</span></span><br><span class=\"line\">    Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//遍历values给到的参数</span></span><br><span class=\"line\">  List&lt;T&gt; usrs = <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class=\"line\">      String name = names.get(i);</span><br><span class=\"line\">      <span class=\"comment\">//跳过被标记-的拓展点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class=\"line\">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!usrs.isEmpty()) &#123;</span><br><span class=\"line\">                exts.addAll(<span class=\"number\">0</span>, usrs);</span><br><span class=\"line\">                usrs.clear();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//注意，这里的name是配置文件中的key</span></span><br><span class=\"line\">            T ext = getExtension(name);</span><br><span class=\"line\">            usrs.add(ext);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!usrs.isEmpty()) &#123;</span><br><span class=\"line\">    exts.addAll(usrs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exts;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>总结</li>\n</ul>\n<p>其实没多少可以总结的，dubbo的微内核其实就一个ExtensionLoader类，但弄清之后，可以较为清晰的研究dubbo各种功能的源码，因为其功能也是拓展点之一，只要找到对于实现即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>开始啃Dubbo时候，对其功能多样被吓到，若干功能由xml配置可任意组装，担心其复杂度过高，源码难啃。当我开始啃启动步骤的代码后，发现<code>ExtensionLoader</code>经常出现在较重要实例化的地方。<br>是的，<code>ExtensionLoader、@SPI、@Adaptive、@Activate</code>可以说是Dubbo的核心，<code>Cluster、Protocol、Filter</code>等接口都被声明为SPI，什么作用呢？能根据配置动态调用被声明为SPI接口的实现类，dubbo提供了URL方式作为参数配置。</p>\n<hr>\n<p>其实SPI的应用跟实现逻辑是相当简单的，但很巧妙，正文的源码分析部分只罗列出主要方法，以及简单说明其作用。</p>\n<ul>\n<li>先来看@SPI</li>\n</ul>\n<p>每个要成为拓展点的接口都需要被声明SPI，ExtensionLoader只加载有该注解的接口，SPI可以设置一个默认值，指向META-INF中拓展点文件的key值，如果你在url所配的参数找不到会走默认。</p>\n<ul>\n<li>@Adaptive</li>\n</ul>\n<p>该注解能作用在类型与方法：作用于方法，默认URL作为匹配方法；作用于类型，可自定义匹配方式，不一定要URL。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.URL;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.SPI;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * SPI(\"默认值\")</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SPI</span>(<span class=\"string\">\"default_1\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * Adaptive(&#123;参数名数组&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"meta\">@Adaptive</span>(&#123;<span class=\"string\">\"key_name_1\"</span>&#125;)</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExtImpl1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test1\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExtImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getChlidInfo</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"test2\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testAdaptive</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ExtensionLoader&lt;TestAdaptiveExt&gt; loader = ExtensionLoader.getExtensionLoader(TestAdaptiveExt<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  TestAdaptiveExt testAdaptiveExt = loader.getAdaptiveExtension();</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 控制台输出：test2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  URL url = URL.valueOf(<span class=\"string\">\"test://localhost/test?Adaptive_key_name=default_2\"</span>);</span><br><span class=\"line\">  System.out.println(testAdaptiveExt.getChlidInfo(url));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestAdaptiveExt</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">default_1</span>=<span class=\"string\">com.hongframe.extension.impl.TestAdaptiveExtImpl1</span></span><br><span class=\"line\"><span class=\"attr\">default_2</span>=<span class=\"string\">com.hongframe.extension.impl.TestAdaptiveExtImpl2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@Activate</li>\n</ul>\n<p>Activate提供了<code>group、value、before、after、order</code>，除前两个用来筛选外，其余三个均排序，该注解只能作用于类型，方法无效。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">print</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Activate</span>(value = <span class=\"string\">\"key_name_1\"</span>, group = <span class=\"string\">\"xxx_group\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestActivateExtImpl1</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"TestActivateExtImpl1\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Activate</span>(<span class=\"string\">\"key_name_2\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestActivateExtImpl2</span> <span class=\"keyword\">implements</span> <span class=\"title\">TestActivateExt</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"TestActivateExtImpl2\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testActivate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  ExtensionLoader&lt;TestActivateExt&gt; testActivateExtExtensionLoader = ExtensionLoader.getExtensionLoader(TestActivateExt<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  URL url = URL.valueOf(<span class=\"string\">\"test://localhost/test\"</span>);</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 此处，对于Activate，URI的key=value只能被key激活，但对相同key的Adaptive方法能达到组合效果</span></span><br><span class=\"line\"><span class=\"comment\">   * 参考CacheFilter与CacheFactory的用法</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 这里有个值得注意的地方：</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果给url添加key_name_1=&lt;-default,...,...&gt;作为参数的话，是不匹配Activate.value的，转而匹配配置文件中的key，例如active1，active2</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  url = url.addParameter(<span class=\"string\">\"key_name_1\"</span>, <span class=\"string\">\"default_1\"</span>);</span><br><span class=\"line\">  List&lt;TestActivateExt&gt; testActivateExts = testActivateExtExtensionLoader.getActivateExtension(url, <span class=\"string\">\"key_name_1\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(TestActivateExt ext : testActivateExts)</span><br><span class=\"line\">   System.out.println(ext.print());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>resources/META-INF/dubbo/internal/com.hongframe.extension.TestActivateExt</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">active1</span>=<span class=\"string\">com.hongframe.extension.impl.TestActivateExtImpl1</span></span><br><span class=\"line\"><span class=\"attr\">active2</span>=<span class=\"string\">com.hongframe.extension.impl.TestActivateExtImpl2</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正题，源码分析</li>\n</ul>\n<p>Dubbo为每个拓展点准备一个ExtensionLoader，将DUBBO_INTERNAL_DIRECTORY、SERVICES_DIRECTORY下的配置文件全部缓存到以下成员变量中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtensionLoader</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//一个拓展点一个ExtensionLoader</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//拓展点实现类的实例化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ==============================</span></span><br><span class=\"line\">  <span class=\"comment\">//拓展点</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; type;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ExtensionFactory objectFactory;</span><br><span class=\"line\">  <span class=\"comment\">//缓存拓展点实现的名称</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//缓存拓展点的实现类</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class=\"keyword\">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//实现类的Activate注解配置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//至关重要的，通过代码注入后得到实例化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class=\"keyword\">new</span> Holder&lt;Object&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//拓展点实现类被声明为Adaptive，至多一个</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"comment\">//SPI(\"cachedDefaultName\") 默认实现类key值</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> String cachedDefaultName;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class=\"line\">  <span class=\"comment\">//拓展点包装类</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">ExtensionLoader&lt;T&gt; <span class=\"title\">getExtensionLoader</span><span class=\"params\">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">      <span class=\"comment\">//非空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!type.isInterface()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//必须是接口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//必须声明@SPI</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loader == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        EXTENSION_LOADERS.putIfAbsent(type, <span class=\"keyword\">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class=\"line\">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loader;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>getAdaptiveExtension</code>获取拓展点实例化对象，这里会动态实例化一个拓展点实现，将其set入Holder，这个对象包装了拓展点基础的实现类，成为一个动态代理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Object instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (createAdaptiveInstanceError == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class=\"line\">        instance = cachedAdaptiveInstance.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//创建Adaptive拓展点接口的实例对象</span></span><br><span class=\"line\">            instance = createAdaptiveExtension();</span><br><span class=\"line\">            cachedAdaptiveInstance.set(instance);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            createAdaptiveInstanceError = t;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"fail to create adaptive instance: \"</span> + t.toString(), t);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (T) instance;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//向拓展点的成员变量注入对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> injectExtension(</span><br><span class=\"line\">        <span class=\"comment\">//加载，动态生成code，编译，实例化</span></span><br><span class=\"line\">        (T) getAdaptiveExtensionClass().newInstance());</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Can not create adaptive extension \"</span> + type + <span class=\"string\">\", cause: \"</span> + e.getMessage(), e);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//加载成员变量type指定的配置文件</span></span><br><span class=\"line\">  getExtensionClasses();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cachedAdaptiveClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cachedAdaptiveClass;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//初始化：生成拓展点实现类代码，以TestAdaptiveExt为例</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>createAdaptiveExtensionClass()</code>方法生成的TestAdaptiveExt实现类，详细逻辑自行阅读<code>createAdaptiveExtensionClassCode()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.hongframe.extension;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestAdaptiveExt</span>$<span class=\"title\">Adaptive</span> <span class=\"keyword\">implements</span> <span class=\"title\">com</span>.<span class=\"title\">hongframe</span>.<span class=\"title\">extension</span>.<span class=\"title\">TestAdaptiveExt</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> java.lang.<span class=\"function\">String <span class=\"title\">getChlidInfo</span><span class=\"params\">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (arg0 == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"url == null\"</span>);</span><br><span class=\"line\">\tcom.alibaba.dubbo.common.URL url = arg0;</span><br><span class=\"line\">\tString extName = url.getParameter(<span class=\"string\">\"key_name_1\"</span>, url.getParameter(<span class=\"string\">\"key_name_2\"</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(extName == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Fail to get extension(com.hongframe.extension.TestAdaptiveExt) name from url(\"</span> + url.toString() + <span class=\"string\">\") use keys([key_name_1, key_name_2])\"</span>);</span><br><span class=\"line\">\tcom.hongframe.extension.TestAdaptiveExt extension =</span><br><span class=\"line\">\t\t\t\t\t(com.hongframe.extension.TestAdaptiveExt)ExtensionLoader</span><br><span class=\"line\">\t\t\t\t\t\t\t\t.getExtensionLoader(com.hongframe.extension.TestAdaptiveExt<span class=\"class\">.<span class=\"keyword\">class</span>).<span class=\"title\">getExtension</span>(<span class=\"title\">extName</span>)</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> extension.getChlidInfo(arg0);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是加载拓展点实现类的代码，主要通过META-INF里的配置文件找到相应的类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//省略单例双检代码</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  classes = loadExtensionClasses();</span><br><span class=\"line\">  cachedClasses.set(classes);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> classes;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// synchronized in getExtensionClasses</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> SPI defaultAnnotation = type.getAnnotation(SPI<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (defaultAnnotation != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    String value = defaultAnnotation.value();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((value = value.trim()).length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//至多一个默认拓展实现类名</span></span><br><span class=\"line\">      String[] names = NAME_SEPARATOR.split(value);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (names.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (names.length == <span class=\"number\">1</span>) cachedDefaultName = names[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class=\"keyword\">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class=\"line\">  <span class=\"comment\">//load配置文件</span></span><br><span class=\"line\">  <span class=\"comment\">//其中loadResource是很简单的词法解析器，loadClass则负责将实现类缓存在成员变量</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);<span class=\"comment\">//\"META-INF/dubbo/internal/\"</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, DUBBO_DIRECTORY);<span class=\"comment\">//\"META-INF/dubbo/\"</span></span><br><span class=\"line\">  loadDirectory(extensionClasses, SERVICES_DIRECTORY);<span class=\"comment\">//\"META-INF/services/\"</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> extensionClasses;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">loadClass</span><span class=\"params\">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL,//抛异常用的，没什么实际用处</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">Class&lt;?&gt; clazz,//配置文件中的value</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">//配置文件中的key</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">String name)</span> <span class=\"keyword\">throws</span> NoSuchMethodException </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//是否拓展点type的实现类</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//该拓展点实现类是否被声明为Adaptive</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (clazz.isAnnotationPresent(Adaptive<span class=\"class\">.<span class=\"keyword\">class</span>)) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cachedAdaptiveClass == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cachedAdaptiveClass = clazz;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//IllegalStateException，只能声明一个实现类</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//是否为包装类</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class=\"line\">    Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wrappers == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      cachedWrapperClasses = <span class=\"keyword\">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class=\"line\">      wrappers = cachedWrapperClasses;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wrappers.add(clazz);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这一步是加载被声明为Activate的实现累的</span></span><br><span class=\"line\">    clazz.getConstructor();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (name == <span class=\"keyword\">null</span> || name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//其中涉及到一个过期的注解@Extension</span></span><br><span class=\"line\">      <span class=\"comment\">//如果配置文件没有设置key值，将实现类simplename作为默认</span></span><br><span class=\"line\">      name = findAnnotationName(clazz);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (name.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String[] names = NAME_SEPARATOR.split(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (names != <span class=\"keyword\">null</span> &amp;&amp; names.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      Activate activate = clazz.getAnnotation(Activate<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (activate != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        cachedActivates.put(names[<span class=\"number\">0</span>], activate);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (String n : names) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class=\"line\">          cachedNames.put(clazz, n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//把不同key相同class全都塞进去</span></span><br><span class=\"line\">          extensionClasses.put(n, clazz);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (c != clazz) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//IllegalStateException</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面是获取Activate拓展实现的列表方法，通常这类拓展都是需要AOP来处理事情的，类似Filter接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;T&gt; <span class=\"title\">getActivateExtension</span><span class=\"params\">(URL url,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">//url的param-key列表</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">String[] values, String group)</span> </span>&#123;</span><br><span class=\"line\">  List&lt;T&gt; exts = <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">  List&lt;String&gt; names = values == <span class=\"keyword\">null</span> ? <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(<span class=\"number\">0</span>) : Arrays.asList(values);</span><br><span class=\"line\">  <span class=\"comment\">//这部分从url中拿去参数，匹配符合条件的拓展点</span></span><br><span class=\"line\">  <span class=\"comment\">//如果key=value，后者出现-default，则表示不走匹配URL的方式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;</span><br><span class=\"line\">    getExtensionClasses();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class=\"line\">      String name = entry.getKey();</span><br><span class=\"line\">      Activate activate = entry.getValue();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isMatchGroup(group, activate.group())) &#123;</span><br><span class=\"line\">        T ext = getExtension(name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!names.contains(name)</span><br><span class=\"line\">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)</span><br><span class=\"line\">              &amp;&amp; isActive(activate, url)) &#123;</span><br><span class=\"line\">          exts.add(ext);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//根据before、after、order优先级依次排序</span></span><br><span class=\"line\">    Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//遍历values给到的参数</span></span><br><span class=\"line\">  List&lt;T&gt; usrs = <span class=\"keyword\">new</span> ArrayList&lt;T&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; names.size(); i++) &#123;</span><br><span class=\"line\">      String name = names.get(i);</span><br><span class=\"line\">      <span class=\"comment\">//跳过被标记-的拓展点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class=\"line\">              &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!usrs.isEmpty()) &#123;</span><br><span class=\"line\">                exts.addAll(<span class=\"number\">0</span>, usrs);</span><br><span class=\"line\">                usrs.clear();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//注意，这里的name是配置文件中的key</span></span><br><span class=\"line\">            T ext = getExtension(name);</span><br><span class=\"line\">            usrs.add(ext);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!usrs.isEmpty()) &#123;</span><br><span class=\"line\">    exts.addAll(usrs);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> exts;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>总结</li>\n</ul>\n<p>其实没多少可以总结的，dubbo的微内核其实就一个ExtensionLoader类，但弄清之后，可以较为清晰的研究dubbo各种功能的源码，因为其功能也是拓展点之一，只要找到对于实现即可。</p>\n"},{"title":"【Spring源码分析】BeanFactory体系的作用","date":"2018-11-23T03:54:47.000Z","_content":"\n最近静下心开始研读spring源码，从容器开始，直入眼帘的就是BeanFactory这个终极boss。通过BeanFactory及其子接口能得知不同的注入方式与获取方式，在尝试拓展自己的实例化时，有必要的用处。\n\n---\n\n先看看`BeanFactory`的最终实现类`DefaultListableBeanFactory`，生成出来的类关系图，看起来相当的复杂。本文暂且只讨论`BeanFactory`本身，与一代子接口`AutowireCapableBeanFactory`、`HierarchicalBeanFactory`、`ListableBeanFactory`，还有个`ConfigurableBeanFactory`实在不想展开讲，东西有点多。\n\n![DefaultListableBeanFactory类图](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/DefaultListableBeanFactory.png)\n\n\n- BeanFactory顶级父类\n\n作为顶级接口，提供了工厂的一切基本操作，获取实例、判断实例种类、类型、是否存在\n\n``` Java\npublic interface BeanFactory {\n  //FactoryBean的转义附，一种在Spring中特色的Bean，后头会讲到\n  //这里未被转义的都是我们认知的普通Bean\n  String FACTORY_BEAN_PREFIX = \"&\";\n  /*\n   * 以下提供了5种获取Bean的方法：\n   * 1、通过BeanName，在获取xml中的bean id时比较常用，常常id唯一\n   * 2、通过BeanName与类型，通过类型校验，避免同名不同类的错误\n   * 3、通过BeanName与构造方法参数获取\n   * 4、通过类型获取，依然有可能出现多Bean的错误\n   * 5、通过类型与构造方法参数获取\n   * 带构造方法参数的获取方法，一般用在non-singleton的Bean\n   * 具体可以看@Scope的说明\n   */\n   Object getBean(String name) throws BeansException;\n   T> T getBean(String name, Class<T> requiredType) throws BeansException;\n   Object getBean(String name, Object... args) throws BeansException;\n   <T> T getBean(Class<T> requiredType) throws BeansException;\n   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n  /*\n   * ObjectProvider是spring 4.3提供的注入方式，针对构造方法依赖注入做的可选方式\n   */\n   <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n   <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\n\n  //查找是否存在Bean，本容器没有，会往上一层继续找\n  boolean containsBean(String name);\n  //是否单例\n  boolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n  //是否原型\n  boolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n  //是否有匹配的类型\n  boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n  boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n  @Nullable\n  Class<?> getType(String name) throws NoSuchBeanDefinitionException;\n  String[] getAliases(String name);\n\n}\n```\n\n- AutowireCapableBeanFactory，使spring容器外的实例对象可以优雅地使用容器内的任意一个Bean。\n\n该接口在用户代码中很少会用到，但由于需要集成其他框架时，可以优雅的实例化prototype，具体可以常见quartz的Job接口，Job的实现类不在容器中也能注入使用@Autowire。\n\n``` Java\npublic interface AutowireCapableBeanFactory extends BeanFactory {\n  //成员变量使用@Autowire，可以不指定注入模式\n  int AUTOWIRE_NO = 0;\n  //以下两种针对不使用注解与构造方法，必须有seter方法\n  int AUTOWIRE_BY_NAME = 1;\n  int AUTOWIRE_BY_TYPE = 2;\n  //通过没有注解且有构造器\n  int AUTOWIRE_CONSTRUCTOR = 3;\n\n  @Deprecated\n  int AUTOWIRE_AUTODETECT = 4;\n  String ORIGINAL_INSTANCE_SUFFIX = \".ORIGINAL\";\n  //以下方法均是装配existingBean，不同方法的实现可以阅读AbstractAutowireCapableBeanFactory\n  <T> T createBean(Class<T> beanClass) throws BeansException;\n  void autowireBean(Object existingBean) throws BeansException;\n  Object configureBean(Object existingBean, String beanName) throws BeansException;\n  Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;\n  Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;\n  void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException;\n  //以下是对实例化对象的后处理\n  Object initializeBean(Object existingBean, String beanName) throws BeansException;\n  Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException;\n  Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException;\n  void destroyBean(Object existingBean);\n\n}\n```\n\n- HierarchicalBeanFactory，获取上一层的容器\n\n该方法是为了容器的分层，差不多父xml与子xml的关系。\n\n``` Java\npublic interface HierarchicalBeanFactory extends BeanFactory {\n\n\t@Nullable\n\tBeanFactory getParentBeanFactory();\n\tboolean containsLocalBean(String name);\n\n}\n```\n\n- ListableBeanFactory，可列表化的工厂\n\n该接口提供的方法，都能让你简单粗暴地获取你想要的local bean，无需通过bean一个一个找。\n\n``` Java\npublic interface ListableBeanFactory extends BeanFactory {\n  //查找beanName是否存在\n  boolean containsBeanDefinition(String beanName);\n  //获取beanDefinitionMap.size()\n  int getBeanDefinitionCount();\n  //获取所有BeanName，在配置被冻结之前，获取的列表可能会变化\n  String[] getBeanDefinitionNames();\n  String[] getBeanNamesForType(ResolvableType type);\n  String[] getBeanNamesForType(@Nullable Class<?> type);\n  String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);\n  //获取beanName-bean的Map\n  //includeNonSingletons是否包含non-singleton的Bean\n  //allowEagerInit是否对懒加载的Bean进行初始化\n  <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException;\n  <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException;\n  //下面的均是找到对应注解的Bean\n  String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);\n  Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException;\n  @Nullable\n  <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException;\n\n}\n```\n\n因为Spring容器本身太复杂，所以本文就着BeanFactory接口，说明了不同接口的作用，还未深入具体其实现。\n希望后续的几篇文章能加快进度，尽快理清spring每个体系的关系。\n","source":"_posts/20181123-【Spring源码分析】BeanFactory体系的作用.md","raw":"---\ntitle: 【Spring源码分析】BeanFactory体系的作用\ndate: 2018-11-23 11:54:47\ntags:\n  - java　\n  - Spring\n  - AOP\n  - IOC控制反转\n  - BeanFactory\ncategories:\n    - Spring源码分析\n---\n\n最近静下心开始研读spring源码，从容器开始，直入眼帘的就是BeanFactory这个终极boss。通过BeanFactory及其子接口能得知不同的注入方式与获取方式，在尝试拓展自己的实例化时，有必要的用处。\n\n---\n\n先看看`BeanFactory`的最终实现类`DefaultListableBeanFactory`，生成出来的类关系图，看起来相当的复杂。本文暂且只讨论`BeanFactory`本身，与一代子接口`AutowireCapableBeanFactory`、`HierarchicalBeanFactory`、`ListableBeanFactory`，还有个`ConfigurableBeanFactory`实在不想展开讲，东西有点多。\n\n![DefaultListableBeanFactory类图](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/DefaultListableBeanFactory.png)\n\n\n- BeanFactory顶级父类\n\n作为顶级接口，提供了工厂的一切基本操作，获取实例、判断实例种类、类型、是否存在\n\n``` Java\npublic interface BeanFactory {\n  //FactoryBean的转义附，一种在Spring中特色的Bean，后头会讲到\n  //这里未被转义的都是我们认知的普通Bean\n  String FACTORY_BEAN_PREFIX = \"&\";\n  /*\n   * 以下提供了5种获取Bean的方法：\n   * 1、通过BeanName，在获取xml中的bean id时比较常用，常常id唯一\n   * 2、通过BeanName与类型，通过类型校验，避免同名不同类的错误\n   * 3、通过BeanName与构造方法参数获取\n   * 4、通过类型获取，依然有可能出现多Bean的错误\n   * 5、通过类型与构造方法参数获取\n   * 带构造方法参数的获取方法，一般用在non-singleton的Bean\n   * 具体可以看@Scope的说明\n   */\n   Object getBean(String name) throws BeansException;\n   T> T getBean(String name, Class<T> requiredType) throws BeansException;\n   Object getBean(String name, Object... args) throws BeansException;\n   <T> T getBean(Class<T> requiredType) throws BeansException;\n   <T> T getBean(Class<T> requiredType, Object... args) throws BeansException;\n\n  /*\n   * ObjectProvider是spring 4.3提供的注入方式，针对构造方法依赖注入做的可选方式\n   */\n   <T> ObjectProvider<T> getBeanProvider(Class<T> requiredType);\n   <T> ObjectProvider<T> getBeanProvider(ResolvableType requiredType);\n\n  //查找是否存在Bean，本容器没有，会往上一层继续找\n  boolean containsBean(String name);\n  //是否单例\n  boolean isSingleton(String name) throws NoSuchBeanDefinitionException;\n  //是否原型\n  boolean isPrototype(String name) throws NoSuchBeanDefinitionException;\n  //是否有匹配的类型\n  boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException;\n  boolean isTypeMatch(String name, Class<?> typeToMatch) throws NoSuchBeanDefinitionException;\n\n  @Nullable\n  Class<?> getType(String name) throws NoSuchBeanDefinitionException;\n  String[] getAliases(String name);\n\n}\n```\n\n- AutowireCapableBeanFactory，使spring容器外的实例对象可以优雅地使用容器内的任意一个Bean。\n\n该接口在用户代码中很少会用到，但由于需要集成其他框架时，可以优雅的实例化prototype，具体可以常见quartz的Job接口，Job的实现类不在容器中也能注入使用@Autowire。\n\n``` Java\npublic interface AutowireCapableBeanFactory extends BeanFactory {\n  //成员变量使用@Autowire，可以不指定注入模式\n  int AUTOWIRE_NO = 0;\n  //以下两种针对不使用注解与构造方法，必须有seter方法\n  int AUTOWIRE_BY_NAME = 1;\n  int AUTOWIRE_BY_TYPE = 2;\n  //通过没有注解且有构造器\n  int AUTOWIRE_CONSTRUCTOR = 3;\n\n  @Deprecated\n  int AUTOWIRE_AUTODETECT = 4;\n  String ORIGINAL_INSTANCE_SUFFIX = \".ORIGINAL\";\n  //以下方法均是装配existingBean，不同方法的实现可以阅读AbstractAutowireCapableBeanFactory\n  <T> T createBean(Class<T> beanClass) throws BeansException;\n  void autowireBean(Object existingBean) throws BeansException;\n  Object configureBean(Object existingBean, String beanName) throws BeansException;\n  Object createBean(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;\n  Object autowire(Class<?> beanClass, int autowireMode, boolean dependencyCheck) throws BeansException;\n  void autowireBeanProperties(Object existingBean, int autowireMode, boolean dependencyCheck)\n\t\t\tthrows BeansException;\n  //以下是对实例化对象的后处理\n  Object initializeBean(Object existingBean, String beanName) throws BeansException;\n  Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException;\n  Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)\n\t\t\tthrows BeansException;\n  void destroyBean(Object existingBean);\n\n}\n```\n\n- HierarchicalBeanFactory，获取上一层的容器\n\n该方法是为了容器的分层，差不多父xml与子xml的关系。\n\n``` Java\npublic interface HierarchicalBeanFactory extends BeanFactory {\n\n\t@Nullable\n\tBeanFactory getParentBeanFactory();\n\tboolean containsLocalBean(String name);\n\n}\n```\n\n- ListableBeanFactory，可列表化的工厂\n\n该接口提供的方法，都能让你简单粗暴地获取你想要的local bean，无需通过bean一个一个找。\n\n``` Java\npublic interface ListableBeanFactory extends BeanFactory {\n  //查找beanName是否存在\n  boolean containsBeanDefinition(String beanName);\n  //获取beanDefinitionMap.size()\n  int getBeanDefinitionCount();\n  //获取所有BeanName，在配置被冻结之前，获取的列表可能会变化\n  String[] getBeanDefinitionNames();\n  String[] getBeanNamesForType(ResolvableType type);\n  String[] getBeanNamesForType(@Nullable Class<?> type);\n  String[] getBeanNamesForType(@Nullable Class<?> type, boolean includeNonSingletons, boolean allowEagerInit);\n  //获取beanName-bean的Map\n  //includeNonSingletons是否包含non-singleton的Bean\n  //allowEagerInit是否对懒加载的Bean进行初始化\n  <T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException;\n  <T> Map<String, T> getBeansOfType(@Nullable Class<T> type, boolean includeNonSingletons, boolean allowEagerInit)\n\t\t\tthrows BeansException;\n  //下面的均是找到对应注解的Bean\n  String[] getBeanNamesForAnnotation(Class<? extends Annotation> annotationType);\n  Map<String, Object> getBeansWithAnnotation(Class<? extends Annotation> annotationType) throws BeansException;\n  @Nullable\n  <A extends Annotation> A findAnnotationOnBean(String beanName, Class<A> annotationType)\n\t\t\tthrows NoSuchBeanDefinitionException;\n\n}\n```\n\n因为Spring容器本身太复杂，所以本文就着BeanFactory接口，说明了不同接口的作用，还未深入具体其实现。\n希望后续的几篇文章能加快进度，尽快理清spring每个体系的关系。\n","slug":"20181123-【Spring源码分析】BeanFactory体系的作用","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7t3002x4ejd17qo3ahx","content":"<p>最近静下心开始研读spring源码，从容器开始，直入眼帘的就是BeanFactory这个终极boss。通过BeanFactory及其子接口能得知不同的注入方式与获取方式，在尝试拓展自己的实例化时，有必要的用处。</p>\n<hr>\n<p>先看看<code>BeanFactory</code>的最终实现类<code>DefaultListableBeanFactory</code>，生成出来的类关系图，看起来相当的复杂。本文暂且只讨论<code>BeanFactory</code>本身，与一代子接口<code>AutowireCapableBeanFactory</code>、<code>HierarchicalBeanFactory</code>、<code>ListableBeanFactory</code>，还有个<code>ConfigurableBeanFactory</code>实在不想展开讲，东西有点多。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<ul>\n<li>BeanFactory顶级父类</li>\n</ul>\n<p>作为顶级接口，提供了工厂的一切基本操作，获取实例、判断实例种类、类型、是否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//FactoryBean的转义附，一种在Spring中特色的Bean，后头会讲到</span></span><br><span class=\"line\">  <span class=\"comment\">//这里未被转义的都是我们认知的普通Bean</span></span><br><span class=\"line\">  String FACTORY_BEAN_PREFIX = <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 以下提供了5种获取Bean的方法：</span></span><br><span class=\"line\"><span class=\"comment\">   * 1、通过BeanName，在获取xml中的bean id时比较常用，常常id唯一</span></span><br><span class=\"line\"><span class=\"comment\">   * 2、通过BeanName与类型，通过类型校验，避免同名不同类的错误</span></span><br><span class=\"line\"><span class=\"comment\">   * 3、通过BeanName与构造方法参数获取</span></span><br><span class=\"line\"><span class=\"comment\">   * 4、通过类型获取，依然有可能出现多Bean的错误</span></span><br><span class=\"line\"><span class=\"comment\">   * 5、通过类型与构造方法参数获取</span></span><br><span class=\"line\"><span class=\"comment\">   * 带构造方法参数的获取方法，一般用在non-singleton的Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * 具体可以看@Scope的说明</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * ObjectProvider是spring 4.3提供的注入方式，针对构造方法依赖注入做的可选方式</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(ResolvableType requiredType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//查找是否存在Bean，本容器没有，会往上一层继续找</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否单例</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否原型</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否有匹配的类型</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, Class&lt;?&gt; typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  Class&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\">  String[] getAliases(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AutowireCapableBeanFactory，使spring容器外的实例对象可以优雅地使用容器内的任意一个Bean。</li>\n</ul>\n<p>该接口在用户代码中很少会用到，但由于需要集成其他框架时，可以优雅的实例化prototype，具体可以常见quartz的Job接口，Job的实现类不在容器中也能注入使用@Autowire。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AutowireCapableBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//成员变量使用@Autowire，可以不指定注入模式</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_NO = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下两种针对不使用注解与构造方法，必须有seter方法</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_BY_NAME = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_BY_TYPE = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//通过没有注解且有构造器</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_CONSTRUCTOR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_AUTODETECT = <span class=\"number\">4</span>;</span><br><span class=\"line\">  String ORIGINAL_INSTANCE_SUFFIX = <span class=\"string\">\".ORIGINAL\"</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下方法均是装配existingBean，不同方法的实现可以阅读AbstractAutowireCapableBeanFactory</span></span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">T <span class=\"title\">createBean</span><span class=\"params\">(Class&lt;T&gt; beanClass)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">autowireBean</span><span class=\"params\">(Object existingBean)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">configureBean</span><span class=\"params\">(Object existingBean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">createBean</span><span class=\"params\">(Class&lt;?&gt; beanClass, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">autowire</span><span class=\"params\">(Class&lt;?&gt; beanClass, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">autowireBeanProperties</span><span class=\"params\">(Object existingBean, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下是对实例化对象的后处理</span></span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">initializeBean</span><span class=\"params\">(Object existingBean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">applyBeanPostProcessorsBeforeInitialization</span><span class=\"params\">(Object existingBean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">applyBeanPostProcessorsAfterInitialization</span><span class=\"params\">(Object existingBean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyBean</span><span class=\"params\">(Object existingBean)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HierarchicalBeanFactory，获取上一层的容器</li>\n</ul>\n<p>该方法是为了容器的分层，差不多父xml与子xml的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HierarchicalBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\">BeanFactory <span class=\"title\">getParentBeanFactory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsLocalBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ListableBeanFactory，可列表化的工厂</li>\n</ul>\n<p>该接口提供的方法，都能让你简单粗暴地获取你想要的local bean，无需通过bean一个一个找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ListableBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//查找beanName是否存在</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBeanDefinition</span><span class=\"params\">(String beanName)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//获取beanDefinitionMap.size()</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBeanDefinitionCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//获取所有BeanName，在配置被冻结之前，获取的列表可能会变化</span></span><br><span class=\"line\">  String[] getBeanDefinitionNames();</span><br><span class=\"line\">  String[] getBeanNamesForType(ResolvableType type);</span><br><span class=\"line\">  String[] getBeanNamesForType(<span class=\"meta\">@Nullable</span> Class&lt;?&gt; type);</span><br><span class=\"line\">  String[] getBeanNamesForType(<span class=\"meta\">@Nullable</span> Class&lt;?&gt; type, <span class=\"keyword\">boolean</span> includeNonSingletons, <span class=\"keyword\">boolean</span> allowEagerInit);</span><br><span class=\"line\">  <span class=\"comment\">//获取beanName-bean的Map</span></span><br><span class=\"line\">  <span class=\"comment\">//includeNonSingletons是否包含non-singleton的Bean</span></span><br><span class=\"line\">  <span class=\"comment\">//allowEagerInit是否对懒加载的Bean进行初始化</span></span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">Map&lt;String, T&gt; <span class=\"title\">getBeansOfType</span><span class=\"params\">(@Nullable Class&lt;T&gt; type)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">Map&lt;String, T&gt; <span class=\"title\">getBeansOfType</span><span class=\"params\">(@Nullable Class&lt;T&gt; type, <span class=\"keyword\">boolean</span> includeNonSingletons, <span class=\"keyword\">boolean</span> allowEagerInit)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//下面的均是找到对应注解的Bean</span></span><br><span class=\"line\">  String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class=\"line\">  <span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getBeansWithAnnotation</span><span class=\"params\">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  &lt;A extends Annotation&gt; <span class=\"function\">A <span class=\"title\">findAnnotationOnBean</span><span class=\"params\">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为Spring容器本身太复杂，所以本文就着BeanFactory接口，说明了不同接口的作用，还未深入具体其实现。<br>希望后续的几篇文章能加快进度，尽快理清spring每个体系的关系。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近静下心开始研读spring源码，从容器开始，直入眼帘的就是BeanFactory这个终极boss。通过BeanFactory及其子接口能得知不同的注入方式与获取方式，在尝试拓展自己的实例化时，有必要的用处。</p>\n<hr>\n<p>先看看<code>BeanFactory</code>的最终实现类<code>DefaultListableBeanFactory</code>，生成出来的类关系图，看起来相当的复杂。本文暂且只讨论<code>BeanFactory</code>本身，与一代子接口<code>AutowireCapableBeanFactory</code>、<code>HierarchicalBeanFactory</code>、<code>ListableBeanFactory</code>，还有个<code>ConfigurableBeanFactory</code>实在不想展开讲，东西有点多。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/DefaultListableBeanFactory.png\" alt=\"DefaultListableBeanFactory类图\"></p>\n<ul>\n<li>BeanFactory顶级父类</li>\n</ul>\n<p>作为顶级接口，提供了工厂的一切基本操作，获取实例、判断实例种类、类型、是否存在</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//FactoryBean的转义附，一种在Spring中特色的Bean，后头会讲到</span></span><br><span class=\"line\">  <span class=\"comment\">//这里未被转义的都是我们认知的普通Bean</span></span><br><span class=\"line\">  String FACTORY_BEAN_PREFIX = <span class=\"string\">\"&amp;\"</span>;</span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * 以下提供了5种获取Bean的方法：</span></span><br><span class=\"line\"><span class=\"comment\">   * 1、通过BeanName，在获取xml中的bean id时比较常用，常常id唯一</span></span><br><span class=\"line\"><span class=\"comment\">   * 2、通过BeanName与类型，通过类型校验，避免同名不同类的错误</span></span><br><span class=\"line\"><span class=\"comment\">   * 3、通过BeanName与构造方法参数获取</span></span><br><span class=\"line\"><span class=\"comment\">   * 4、通过类型获取，依然有可能出现多Bean的错误</span></span><br><span class=\"line\"><span class=\"comment\">   * 5、通过类型与构造方法参数获取</span></span><br><span class=\"line\"><span class=\"comment\">   * 带构造方法参数的获取方法，一般用在non-singleton的Bean</span></span><br><span class=\"line\"><span class=\"comment\">   * 具体可以看@Scope的说明</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(String name, Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   <span class=\"function\">Object <span class=\"title\">getBean</span><span class=\"params\">(String name, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">T <span class=\"title\">getBean</span><span class=\"params\">(Class&lt;T&gt; requiredType, Object... args)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">   * ObjectProvider是spring 4.3提供的注入方式，针对构造方法依赖注入做的可选方式</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class=\"line\">   &lt;T&gt; <span class=\"function\">ObjectProvider&lt;T&gt; <span class=\"title\">getBeanProvider</span><span class=\"params\">(ResolvableType requiredType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//查找是否存在Bean，本容器没有，会往上一层继续找</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否单例</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSingleton</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否原型</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isPrototype</span><span class=\"params\">(String name)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//是否有匹配的类型</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, ResolvableType typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTypeMatch</span><span class=\"params\">(String name, Class&lt;?&gt; typeToMatch)</span> <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  Class&lt;?&gt; getType(String name) <span class=\"keyword\">throws</span> NoSuchBeanDefinitionException;</span><br><span class=\"line\">  String[] getAliases(String name);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>AutowireCapableBeanFactory，使spring容器外的实例对象可以优雅地使用容器内的任意一个Bean。</li>\n</ul>\n<p>该接口在用户代码中很少会用到，但由于需要集成其他框架时，可以优雅的实例化prototype，具体可以常见quartz的Job接口，Job的实现类不在容器中也能注入使用@Autowire。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AutowireCapableBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//成员变量使用@Autowire，可以不指定注入模式</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_NO = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下两种针对不使用注解与构造方法，必须有seter方法</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_BY_NAME = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_BY_TYPE = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"comment\">//通过没有注解且有构造器</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_CONSTRUCTOR = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Deprecated</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> AUTOWIRE_AUTODETECT = <span class=\"number\">4</span>;</span><br><span class=\"line\">  String ORIGINAL_INSTANCE_SUFFIX = <span class=\"string\">\".ORIGINAL\"</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下方法均是装配existingBean，不同方法的实现可以阅读AbstractAutowireCapableBeanFactory</span></span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">T <span class=\"title\">createBean</span><span class=\"params\">(Class&lt;T&gt; beanClass)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">autowireBean</span><span class=\"params\">(Object existingBean)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">configureBean</span><span class=\"params\">(Object existingBean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">createBean</span><span class=\"params\">(Class&lt;?&gt; beanClass, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">autowire</span><span class=\"params\">(Class&lt;?&gt; beanClass, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">autowireBeanProperties</span><span class=\"params\">(Object existingBean, <span class=\"keyword\">int</span> autowireMode, <span class=\"keyword\">boolean</span> dependencyCheck)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//以下是对实例化对象的后处理</span></span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">initializeBean</span><span class=\"params\">(Object existingBean, String beanName)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">applyBeanPostProcessorsBeforeInitialization</span><span class=\"params\">(Object existingBean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\">Object <span class=\"title\">applyBeanPostProcessorsAfterInitialization</span><span class=\"params\">(Object existingBean, String beanName)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">destroyBean</span><span class=\"params\">(Object existingBean)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>HierarchicalBeanFactory，获取上一层的容器</li>\n</ul>\n<p>该方法是为了容器的分层，差不多父xml与子xml的关系。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HierarchicalBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Nullable</span></span><br><span class=\"line\">\t<span class=\"function\">BeanFactory <span class=\"title\">getParentBeanFactory</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsLocalBean</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ListableBeanFactory，可列表化的工厂</li>\n</ul>\n<p>该接口提供的方法，都能让你简单粗暴地获取你想要的local bean，无需通过bean一个一个找。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ListableBeanFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">BeanFactory</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//查找beanName是否存在</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsBeanDefinition</span><span class=\"params\">(String beanName)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//获取beanDefinitionMap.size()</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getBeanDefinitionCount</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">//获取所有BeanName，在配置被冻结之前，获取的列表可能会变化</span></span><br><span class=\"line\">  String[] getBeanDefinitionNames();</span><br><span class=\"line\">  String[] getBeanNamesForType(ResolvableType type);</span><br><span class=\"line\">  String[] getBeanNamesForType(<span class=\"meta\">@Nullable</span> Class&lt;?&gt; type);</span><br><span class=\"line\">  String[] getBeanNamesForType(<span class=\"meta\">@Nullable</span> Class&lt;?&gt; type, <span class=\"keyword\">boolean</span> includeNonSingletons, <span class=\"keyword\">boolean</span> allowEagerInit);</span><br><span class=\"line\">  <span class=\"comment\">//获取beanName-bean的Map</span></span><br><span class=\"line\">  <span class=\"comment\">//includeNonSingletons是否包含non-singleton的Bean</span></span><br><span class=\"line\">  <span class=\"comment\">//allowEagerInit是否对懒加载的Bean进行初始化</span></span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">Map&lt;String, T&gt; <span class=\"title\">getBeansOfType</span><span class=\"params\">(@Nullable Class&lt;T&gt; type)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  &lt;T&gt; <span class=\"function\">Map&lt;String, T&gt; <span class=\"title\">getBeansOfType</span><span class=\"params\">(@Nullable Class&lt;T&gt; type, <span class=\"keyword\">boolean</span> includeNonSingletons, <span class=\"keyword\">boolean</span> allowEagerInit)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"comment\">//下面的均是找到对应注解的Bean</span></span><br><span class=\"line\">  String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class=\"line\">  <span class=\"function\">Map&lt;String, Object&gt; <span class=\"title\">getBeansWithAnnotation</span><span class=\"params\">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class=\"keyword\">throws</span> BeansException</span>;</span><br><span class=\"line\">  <span class=\"meta\">@Nullable</span></span><br><span class=\"line\">  &lt;A extends Annotation&gt; <span class=\"function\">A <span class=\"title\">findAnnotationOnBean</span><span class=\"params\">(String beanName, Class&lt;A&gt; annotationType)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为Spring容器本身太复杂，所以本文就着BeanFactory接口，说明了不同接口的作用，还未深入具体其实现。<br>希望后续的几篇文章能加快进度，尽快理清spring每个体系的关系。</p>\n"},{"title":"【Dubbo源码分析】四种负载均衡","date":"2018-09-06T04:26:37.000Z","_content":"\nDubbo选择在客户端做负载均衡，提供了四种选择：随机、轮询、最少活跃调用数、一致性Hash。四种算法简单且有趣，可以稍微研究以下。\n\n---\n\n首先`LoadBalance`接口是一个SPI，`select()`方法被声明为Adaptive，通过URL参数找到对应的负载均衡方式，如果以下四种无法满足，可以自行拓展。\n\n- AbstractLoadBalance的模版方法\n\n抽象类只提供了一个模版方法，具体的均衡策略由doSelect实现，`getWeight`是一个公用的计算权重方法。\n``` java\npublic abstract class AbstractLoadBalance implements LoadBalance {\n  static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n    //uptime：运行时间\n    //warmup：预热时间\n    //ww = 权重 * 运行时间／预热时间\n    //在预热时间内，ww与运行时间成正比，uptime越短，权重越小\n    //超出预热时间，返回预设权重\n    int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n    return ww < 1 ? 1 : (ww > weight ? weight : ww);\n  }\n  //模版方法\n  @Override\n  public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n    if (invokers == null || invokers.isEmpty())\n      return null;\n    if (invokers.size() == 1)\n      return invokers.get(0);\n    return doSelect(invokers, url, invocation);\n  }\n  protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n\n  protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n    if (weight > 0) {\n      //获取启动时间\n      long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n      if (timestamp > 0L) {\n        //获取运行时间\n        int uptime = (int) (System.currentTimeMillis() - timestamp);\n        //预热时间\n        int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n        //未达到预热时间，则根据运行时间长短重新计算权重\n        if (uptime > 0 && uptime < warmup) {\n          weight = calculateWarmupWeight(uptime, warmup, weight);\n        }\n      }\n    }\n    return weight;\n  }\n\n}\n```\n\n- RandomLoadBalance随机访问\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  int length = invokers.size(); //调用者数量\n  int totalWeight = 0; //权重总额\n  boolean sameWeight = true; //是否每个调用者的权重都是相等的\n  for (int i = 0; i < length; i++) {\n    int weight = getWeight(invokers.get(i), invocation);\n    totalWeight += weight; //求和\n    //出现相邻的调用者权重不等，则sameWeight为否\n    if (sameWeight && i > 0\n          && weight != getWeight(invokers.get(i - 1), invocation)) {\n      sameWeight = false;\n    }\n  }\n  //以下的逻辑需要列一个表，可能会清晰一些\n  if (totalWeight > 0 && !sameWeight) {\n    //得到一个【0, totalWeight)的随机数\n    int offset = random.nextInt(totalWeight);\n    //循环依次减去调用者权重，直到offset<0\n    for (int i = 0; i < length; i++) {\n      offset -= getWeight(invokers.get(i), invocation);\n      if (offset < 0) {\n        return invokers.get(i);\n      }\n    }\n  }\n  return invokers.get(random.nextInt(length));\n}\n```\n\n上面代码什么意思呢？我们稍微列一下。\n\n假设，ABC三个节点，权重分别是1，2，3，那totalWeight = 6，则offset取值范围是[0,6)。\n那么，\n```\noffset  A:1    B:2    C:3\n     0  0-1<0                选A\n     1  1-1=0\t 0-2<0\t       选B\n     2  2-1=1\t 1-2<0\t       选B\n     3  3-1=2\t 2-2=0\t0-3<0  选C\n     4  4-1=3\t 3-2=1\t1-3<0  选C\n     5  5-1=4  4-2=2\t2-3<0  选C\n```\n可见ABC被分配到的概率也是1、2、3。\n\n- RoundRobinLoadBalance权重比例轮训\n\n按照权重轮训，这个负载均衡的方式可以说是十分坑爹，按照文档里的说法是\n```\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n```\n就是会出现某台机子的活跃度非常高，而且还不断的把请求丢给这台机器。\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n  int length = invokers.size(); //调用者数量\n  int maxWeight = 0; //最大最小权重\n  int minWeight = Integer.MAX_VALUE;\n  final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();\n  int weightSum = 0;\n  for (int i = 0; i < length; i++) {\n    int weight = getWeight(invokers.get(i), invocation);\n    maxWeight = Math.max(maxWeight, weight);\n    minWeight = Math.min(minWeight, weight);//找出最大最小权重\n    if (weight > 0) {\n      invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n      weightSum += weight;\n    }\n  }\n  AtomicPositiveInteger sequence = sequences.get(key);\n  if (sequence == null) {\n    sequences.putIfAbsent(key, new AtomicPositiveInteger());\n    sequence = sequences.get(key);\n  }\n  //下面通过mod和weight不断递减1，依次轮训调用\n  //A:1 B:2 C:3 D:2，调用量：7\n  //则轮训调用A1次，B2次，C3次，D1次\n  int currentSequence = sequence.getAndIncrement();\n  if (maxWeight > 0 && minWeight < maxWeight) {\n    int mod = currentSequence % weightSum;\n    for (int i = 0; i < maxWeight; i++) {\n      for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n        final Invoker<T> k = each.getKey();\n        final IntegerWrapper v = each.getValue();\n        if (mod == 0 && v.getValue() > 0) {\n          return k;\n        }\n        if (v.getValue() > 0) {\n          v.decrement();\n          mod--;\n        }\n      }\n    }\n  }\n  return invokers.get(currentSequence % length);\n}\n```\n\n- LeastActiveLoadBalance最低活跃量\n\n这种方式需要配合`ActiveLimitFilter`一起使用，有一点要注意，这个活跃度是针对客户端而言，它并没有通过zk同步每个终端调用量来得到服务端的真实负载，这个拦截器仅仅作为客户端限流用的。\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  int length = invokers.size(); //调用者数量\n  int leastActive = -1; //最低活跃度\n  int leastCount = 0; //多少相同最低活跃度\n  int[] leastIndexs = new int[length]; //记录相等最低活跃度的调用者下标\n  int totalWeight = 0; //相同最低活跃度的权重总额\n  int firstWeight = 0; // Initial value, used for comparision\n  boolean sameWeight = true; //相同最低活跃度的调用者权重是否相等\n  for (int i = 0; i < length; i++) {\n    Invoker<T> invoker = invokers.get(i);\n    int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number\n    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight\n    if (leastActive == -1 || active < leastActive) { // Restart, when find a invoker having smaller least active value.\n      leastActive = active; //记录新的最低活跃度\n      leastCount = 1;\n      leastIndexs[0] = i; //重置\n      totalWeight = weight; //重置\n      firstWeight = weight; //重置\n      sameWeight = true; // 重置\n    } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.\n      leastIndexs[leastCount++] = i;\n      totalWeight += weight; //累加权重\n      if (sameWeight && i > 0\n            && weight != firstWeight) {\n        sameWeight = false;\n      }\n    }\n  }\n  //最低活跃度只有一个，那那肯定是它\n  if (leastCount == 1) {\n    return invokers.get(leastIndexs[0]);\n  }\n  //下面这一步不用多说了，与RandomLoadBalance一摸一样\n  //最低活跃度相同的调用这，以权重比例随机访问\n  if (!sameWeight && totalWeight > 0) {\n    int offsetWeight = random.nextInt(totalWeight);\n    for (int i = 0; i < leastCount; i++) {\n      int leastIndex = leastIndexs[i];\n      offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n      if (offsetWeight <= 0)\n        return invokers.get(leastIndex);\n    }\n  }\n  return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n}\n```\n\n- ConsistentHashLoadBalance一致性哈希\n\n这个其实没什么好说的，源码只是计算hash值\n```\n一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n```\n","source":"_posts/20180906-【Dubbo源码分析】四种负载均衡.md","raw":"---\ntitle: 【Dubbo源码分析】四种负载均衡\ndate: 2018-09-06 12:26:37\ntags:\n  - java　\n  - Dubbo\n  - 负载均衡\n  - LoadBalance\n  - rpc\ncategories:\n  - rpc框架\n---\n\nDubbo选择在客户端做负载均衡，提供了四种选择：随机、轮询、最少活跃调用数、一致性Hash。四种算法简单且有趣，可以稍微研究以下。\n\n---\n\n首先`LoadBalance`接口是一个SPI，`select()`方法被声明为Adaptive，通过URL参数找到对应的负载均衡方式，如果以下四种无法满足，可以自行拓展。\n\n- AbstractLoadBalance的模版方法\n\n抽象类只提供了一个模版方法，具体的均衡策略由doSelect实现，`getWeight`是一个公用的计算权重方法。\n``` java\npublic abstract class AbstractLoadBalance implements LoadBalance {\n  static int calculateWarmupWeight(int uptime, int warmup, int weight) {\n    //uptime：运行时间\n    //warmup：预热时间\n    //ww = 权重 * 运行时间／预热时间\n    //在预热时间内，ww与运行时间成正比，uptime越短，权重越小\n    //超出预热时间，返回预设权重\n    int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n    return ww < 1 ? 1 : (ww > weight ? weight : ww);\n  }\n  //模版方法\n  @Override\n  public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n    if (invokers == null || invokers.isEmpty())\n      return null;\n    if (invokers.size() == 1)\n      return invokers.get(0);\n    return doSelect(invokers, url, invocation);\n  }\n  protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);\n\n  protected int getWeight(Invoker<?> invoker, Invocation invocation) {\n    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n    if (weight > 0) {\n      //获取启动时间\n      long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n      if (timestamp > 0L) {\n        //获取运行时间\n        int uptime = (int) (System.currentTimeMillis() - timestamp);\n        //预热时间\n        int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n        //未达到预热时间，则根据运行时间长短重新计算权重\n        if (uptime > 0 && uptime < warmup) {\n          weight = calculateWarmupWeight(uptime, warmup, weight);\n        }\n      }\n    }\n    return weight;\n  }\n\n}\n```\n\n- RandomLoadBalance随机访问\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  int length = invokers.size(); //调用者数量\n  int totalWeight = 0; //权重总额\n  boolean sameWeight = true; //是否每个调用者的权重都是相等的\n  for (int i = 0; i < length; i++) {\n    int weight = getWeight(invokers.get(i), invocation);\n    totalWeight += weight; //求和\n    //出现相邻的调用者权重不等，则sameWeight为否\n    if (sameWeight && i > 0\n          && weight != getWeight(invokers.get(i - 1), invocation)) {\n      sameWeight = false;\n    }\n  }\n  //以下的逻辑需要列一个表，可能会清晰一些\n  if (totalWeight > 0 && !sameWeight) {\n    //得到一个【0, totalWeight)的随机数\n    int offset = random.nextInt(totalWeight);\n    //循环依次减去调用者权重，直到offset<0\n    for (int i = 0; i < length; i++) {\n      offset -= getWeight(invokers.get(i), invocation);\n      if (offset < 0) {\n        return invokers.get(i);\n      }\n    }\n  }\n  return invokers.get(random.nextInt(length));\n}\n```\n\n上面代码什么意思呢？我们稍微列一下。\n\n假设，ABC三个节点，权重分别是1，2，3，那totalWeight = 6，则offset取值范围是[0,6)。\n那么，\n```\noffset  A:1    B:2    C:3\n     0  0-1<0                选A\n     1  1-1=0\t 0-2<0\t       选B\n     2  2-1=1\t 1-2<0\t       选B\n     3  3-1=2\t 2-2=0\t0-3<0  选C\n     4  4-1=3\t 3-2=1\t1-3<0  选C\n     5  5-1=4  4-2=2\t2-3<0  选C\n```\n可见ABC被分配到的概率也是1、2、3。\n\n- RoundRobinLoadBalance权重比例轮训\n\n按照权重轮训，这个负载均衡的方式可以说是十分坑爹，按照文档里的说法是\n```\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n```\n就是会出现某台机子的活跃度非常高，而且还不断的把请求丢给这台机器。\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n  int length = invokers.size(); //调用者数量\n  int maxWeight = 0; //最大最小权重\n  int minWeight = Integer.MAX_VALUE;\n  final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();\n  int weightSum = 0;\n  for (int i = 0; i < length; i++) {\n    int weight = getWeight(invokers.get(i), invocation);\n    maxWeight = Math.max(maxWeight, weight);\n    minWeight = Math.min(minWeight, weight);//找出最大最小权重\n    if (weight > 0) {\n      invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n      weightSum += weight;\n    }\n  }\n  AtomicPositiveInteger sequence = sequences.get(key);\n  if (sequence == null) {\n    sequences.putIfAbsent(key, new AtomicPositiveInteger());\n    sequence = sequences.get(key);\n  }\n  //下面通过mod和weight不断递减1，依次轮训调用\n  //A:1 B:2 C:3 D:2，调用量：7\n  //则轮训调用A1次，B2次，C3次，D1次\n  int currentSequence = sequence.getAndIncrement();\n  if (maxWeight > 0 && minWeight < maxWeight) {\n    int mod = currentSequence % weightSum;\n    for (int i = 0; i < maxWeight; i++) {\n      for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {\n        final Invoker<T> k = each.getKey();\n        final IntegerWrapper v = each.getValue();\n        if (mod == 0 && v.getValue() > 0) {\n          return k;\n        }\n        if (v.getValue() > 0) {\n          v.decrement();\n          mod--;\n        }\n      }\n    }\n  }\n  return invokers.get(currentSequence % length);\n}\n```\n\n- LeastActiveLoadBalance最低活跃量\n\n这种方式需要配合`ActiveLimitFilter`一起使用，有一点要注意，这个活跃度是针对客户端而言，它并没有通过zk同步每个终端调用量来得到服务端的真实负载，这个拦截器仅仅作为客户端限流用的。\n\n``` java\n@Override\nprotected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n  int length = invokers.size(); //调用者数量\n  int leastActive = -1; //最低活跃度\n  int leastCount = 0; //多少相同最低活跃度\n  int[] leastIndexs = new int[length]; //记录相等最低活跃度的调用者下标\n  int totalWeight = 0; //相同最低活跃度的权重总额\n  int firstWeight = 0; // Initial value, used for comparision\n  boolean sameWeight = true; //相同最低活跃度的调用者权重是否相等\n  for (int i = 0; i < length; i++) {\n    Invoker<T> invoker = invokers.get(i);\n    int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number\n    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight\n    if (leastActive == -1 || active < leastActive) { // Restart, when find a invoker having smaller least active value.\n      leastActive = active; //记录新的最低活跃度\n      leastCount = 1;\n      leastIndexs[0] = i; //重置\n      totalWeight = weight; //重置\n      firstWeight = weight; //重置\n      sameWeight = true; // 重置\n    } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.\n      leastIndexs[leastCount++] = i;\n      totalWeight += weight; //累加权重\n      if (sameWeight && i > 0\n            && weight != firstWeight) {\n        sameWeight = false;\n      }\n    }\n  }\n  //最低活跃度只有一个，那那肯定是它\n  if (leastCount == 1) {\n    return invokers.get(leastIndexs[0]);\n  }\n  //下面这一步不用多说了，与RandomLoadBalance一摸一样\n  //最低活跃度相同的调用这，以权重比例随机访问\n  if (!sameWeight && totalWeight > 0) {\n    int offsetWeight = random.nextInt(totalWeight);\n    for (int i = 0; i < leastCount; i++) {\n      int leastIndex = leastIndexs[i];\n      offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n      if (offsetWeight <= 0)\n        return invokers.get(leastIndex);\n    }\n  }\n  return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n}\n```\n\n- ConsistentHashLoadBalance一致性哈希\n\n这个其实没什么好说的，源码只是计算hash值\n```\n一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n```\n","slug":"20180906-【Dubbo源码分析】四种负载均衡","published":1,"updated":"2019-01-16T16:36:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4b9g7t400314ejd5pnhfxw7","content":"<p>Dubbo选择在客户端做负载均衡，提供了四种选择：随机、轮询、最少活跃调用数、一致性Hash。四种算法简单且有趣，可以稍微研究以下。</p>\n<hr>\n<p>首先<code>LoadBalance</code>接口是一个SPI，<code>select()</code>方法被声明为Adaptive，通过URL参数找到对应的负载均衡方式，如果以下四种无法满足，可以自行拓展。</p>\n<ul>\n<li>AbstractLoadBalance的模版方法</li>\n</ul>\n<p>抽象类只提供了一个模版方法，具体的均衡策略由doSelect实现，<code>getWeight</code>是一个公用的计算权重方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLoadBalance</span> <span class=\"keyword\">implements</span> <span class=\"title\">LoadBalance</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateWarmupWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> uptime, <span class=\"keyword\">int</span> warmup, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//uptime：运行时间</span></span><br><span class=\"line\">    <span class=\"comment\">//warmup：预热时间</span></span><br><span class=\"line\">    <span class=\"comment\">//ww = 权重 * 运行时间／预热时间</span></span><br><span class=\"line\">    <span class=\"comment\">//在预热时间内，ww与运行时间成正比，uptime越短，权重越小</span></span><br><span class=\"line\">    <span class=\"comment\">//超出预热时间，返回预设权重</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ww = (<span class=\"keyword\">int</span>) ((<span class=\"keyword\">float</span>) uptime / ((<span class=\"keyword\">float</span>) warmup / (<span class=\"keyword\">float</span>) weight));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ww &lt; <span class=\"number\">1</span> ? <span class=\"number\">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//模版方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span> || invokers.isEmpty())</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers.size() == <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSelect(invokers, url, invocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getWeight</span><span class=\"params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取启动时间</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class=\"number\">0L</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timestamp &gt; <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取运行时间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> uptime = (<span class=\"keyword\">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class=\"line\">        <span class=\"comment\">//预热时间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class=\"line\">        <span class=\"comment\">//未达到预热时间，则根据运行时间长短重新计算权重</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uptime &gt; <span class=\"number\">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class=\"line\">          weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> weight;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>RandomLoadBalance随机访问</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">//权重总额</span></span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">//是否每个调用者的权重都是相等的</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">    totalWeight += weight; <span class=\"comment\">//求和</span></span><br><span class=\"line\">    <span class=\"comment\">//出现相邻的调用者权重不等，则sameWeight为否</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">          &amp;&amp; weight != getWeight(invokers.get(i - <span class=\"number\">1</span>), invocation)) &#123;</span><br><span class=\"line\">      sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//以下的逻辑需要列一个表，可能会清晰一些</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (totalWeight &gt; <span class=\"number\">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个【0, totalWeight)的随机数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> offset = random.nextInt(totalWeight);</span><br><span class=\"line\">    <span class=\"comment\">//循环依次减去调用者权重，直到offset&lt;0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      offset -= getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(random.nextInt(length));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码什么意思呢？我们稍微列一下。</p>\n<p>假设，ABC三个节点，权重分别是1，2，3，那totalWeight = 6，则offset取值范围是[0,6)。<br>那么，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset  A:1    B:2    C:3</span><br><span class=\"line\">     0  0-1&lt;0                选A</span><br><span class=\"line\">     1  1-1&#x3D;0\t 0-2&lt;0\t       选B</span><br><span class=\"line\">     2  2-1&#x3D;1\t 1-2&lt;0\t       选B</span><br><span class=\"line\">     3  3-1&#x3D;2\t 2-2&#x3D;0\t0-3&lt;0  选C</span><br><span class=\"line\">     4  4-1&#x3D;3\t 3-2&#x3D;1\t1-3&lt;0  选C</span><br><span class=\"line\">     5  5-1&#x3D;4  4-2&#x3D;2\t2-3&lt;0  选C</span><br></pre></td></tr></table></figure>\n<p>可见ABC被分配到的概率也是1、2、3。</p>\n<ul>\n<li>RoundRobinLoadBalance权重比例轮训</li>\n</ul>\n<p>按照权重轮训，这个负载均衡的方式可以说是十分坑爹，按照文档里的说法是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br></pre></td></tr></table></figure>\n<p>就是会出现某台机子的活跃度非常高，而且还不断的把请求丢给这台机器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">//最大最小权重</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> weightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">    maxWeight = Math.max(maxWeight, weight);</span><br><span class=\"line\">    minWeight = Math.min(minWeight, weight);<span class=\"comment\">//找出最大最小权重</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      invokerToWeightMap.put(invokers.get(i), <span class=\"keyword\">new</span> IntegerWrapper(weight));</span><br><span class=\"line\">      weightSum += weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">    sequence = sequences.get(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//下面通过mod和weight不断递减1，依次轮训调用</span></span><br><span class=\"line\">  <span class=\"comment\">//A:1 B:2 C:3 D:2，调用量：7</span></span><br><span class=\"line\">  <span class=\"comment\">//则轮训调用A1次，B2次，C3次，D1次</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> currentSequence = sequence.getAndIncrement();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mod = currentSequence % weightSum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxWeight; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Invoker&lt;T&gt; k = each.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntegerWrapper v = each.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mod == <span class=\"number\">0</span> &amp;&amp; v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          v.decrement();</span><br><span class=\"line\">          mod--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(currentSequence % length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>LeastActiveLoadBalance最低活跃量</li>\n</ul>\n<p>这种方式需要配合<code>ActiveLimitFilter</code>一起使用，有一点要注意，这个活跃度是针对客户端而言，它并没有通过zk同步每个终端调用量来得到服务端的真实负载，这个拦截器仅仅作为客户端限流用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> leastActive = -<span class=\"number\">1</span>; <span class=\"comment\">//最低活跃度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> leastCount = <span class=\"number\">0</span>; <span class=\"comment\">//多少相同最低活跃度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>[] leastIndexs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length]; <span class=\"comment\">//记录相等最低活跃度的调用者下标</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">//相同最低活跃度的权重总额</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> firstWeight = <span class=\"number\">0</span>; <span class=\"comment\">// Initial value, used for comparision</span></span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">//相同最低活跃度的调用者权重是否相等</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); <span class=\"comment\">// Active number</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); <span class=\"comment\">// Weight</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leastActive == -<span class=\"number\">1</span> || active &lt; leastActive) &#123; <span class=\"comment\">// Restart, when find a invoker having smaller least active value.</span></span><br><span class=\"line\">      leastActive = active; <span class=\"comment\">//记录新的最低活跃度</span></span><br><span class=\"line\">      leastCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      leastIndexs[<span class=\"number\">0</span>] = i; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      totalWeight = weight; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      firstWeight = weight; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (active == leastActive) &#123; <span class=\"comment\">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class=\"line\">      leastIndexs[leastCount++] = i;</span><br><span class=\"line\">      totalWeight += weight; <span class=\"comment\">//累加权重</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; weight != firstWeight) &#123;</span><br><span class=\"line\">        sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//最低活跃度只有一个，那那肯定是它</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (leastCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers.get(leastIndexs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//下面这一步不用多说了，与RandomLoadBalance一摸一样</span></span><br><span class=\"line\">  <span class=\"comment\">//最低活跃度相同的调用这，以权重比例随机访问</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> offsetWeight = random.nextInt(totalWeight);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> leastIndex = leastIndexs[i];</span><br><span class=\"line\">      offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (offsetWeight &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(leastIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ConsistentHashLoadBalance一致性哈希</li>\n</ul>\n<p>这个其实没什么好说的，源码只是计算hash值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一致性 Hash，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Dubbo选择在客户端做负载均衡，提供了四种选择：随机、轮询、最少活跃调用数、一致性Hash。四种算法简单且有趣，可以稍微研究以下。</p>\n<hr>\n<p>首先<code>LoadBalance</code>接口是一个SPI，<code>select()</code>方法被声明为Adaptive，通过URL参数找到对应的负载均衡方式，如果以下四种无法满足，可以自行拓展。</p>\n<ul>\n<li>AbstractLoadBalance的模版方法</li>\n</ul>\n<p>抽象类只提供了一个模版方法，具体的均衡策略由doSelect实现，<code>getWeight</code>是一个公用的计算权重方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractLoadBalance</span> <span class=\"keyword\">implements</span> <span class=\"title\">LoadBalance</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">calculateWarmupWeight</span><span class=\"params\">(<span class=\"keyword\">int</span> uptime, <span class=\"keyword\">int</span> warmup, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//uptime：运行时间</span></span><br><span class=\"line\">    <span class=\"comment\">//warmup：预热时间</span></span><br><span class=\"line\">    <span class=\"comment\">//ww = 权重 * 运行时间／预热时间</span></span><br><span class=\"line\">    <span class=\"comment\">//在预热时间内，ww与运行时间成正比，uptime越短，权重越小</span></span><br><span class=\"line\">    <span class=\"comment\">//超出预热时间，返回预设权重</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ww = (<span class=\"keyword\">int</span>) ((<span class=\"keyword\">float</span>) uptime / ((<span class=\"keyword\">float</span>) warmup / (<span class=\"keyword\">float</span>) weight));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ww &lt; <span class=\"number\">1</span> ? <span class=\"number\">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//模版方法</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">select</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers == <span class=\"keyword\">null</span> || invokers.isEmpty())</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (invokers.size() == <span class=\"number\">1</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> invokers.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> doSelect(invokers, url, invocation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">getWeight</span><span class=\"params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//获取启动时间</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, <span class=\"number\">0L</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timestamp &gt; <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取运行时间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> uptime = (<span class=\"keyword\">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class=\"line\">        <span class=\"comment\">//预热时间</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);</span><br><span class=\"line\">        <span class=\"comment\">//未达到预热时间，则根据运行时间长短重新计算权重</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uptime &gt; <span class=\"number\">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class=\"line\">          weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> weight;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>RandomLoadBalance随机访问</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">//权重总额</span></span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">//是否每个调用者的权重都是相等的</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">    totalWeight += weight; <span class=\"comment\">//求和</span></span><br><span class=\"line\">    <span class=\"comment\">//出现相邻的调用者权重不等，则sameWeight为否</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">          &amp;&amp; weight != getWeight(invokers.get(i - <span class=\"number\">1</span>), invocation)) &#123;</span><br><span class=\"line\">      sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//以下的逻辑需要列一个表，可能会清晰一些</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (totalWeight &gt; <span class=\"number\">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到一个【0, totalWeight)的随机数</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> offset = random.nextInt(totalWeight);</span><br><span class=\"line\">    <span class=\"comment\">//循环依次减去调用者权重，直到offset&lt;0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">      offset -= getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (offset &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(random.nextInt(length));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码什么意思呢？我们稍微列一下。</p>\n<p>假设，ABC三个节点，权重分别是1，2，3，那totalWeight = 6，则offset取值范围是[0,6)。<br>那么，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">offset  A:1    B:2    C:3</span><br><span class=\"line\">     0  0-1&lt;0                选A</span><br><span class=\"line\">     1  1-1&#x3D;0\t 0-2&lt;0\t       选B</span><br><span class=\"line\">     2  2-1&#x3D;1\t 1-2&lt;0\t       选B</span><br><span class=\"line\">     3  3-1&#x3D;2\t 2-2&#x3D;0\t0-3&lt;0  选C</span><br><span class=\"line\">     4  4-1&#x3D;3\t 3-2&#x3D;1\t1-3&lt;0  选C</span><br><span class=\"line\">     5  5-1&#x3D;4  4-2&#x3D;2\t2-3&lt;0  选C</span><br></pre></td></tr></table></figure>\n<p>可见ABC被分配到的概率也是1、2、3。</p>\n<ul>\n<li>RoundRobinLoadBalance权重比例轮训</li>\n</ul>\n<p>按照权重轮训，这个负载均衡的方式可以说是十分坑爹，按照文档里的说法是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</span><br></pre></td></tr></table></figure>\n<p>就是会出现某台机子的活跃度非常高，而且还不断的把请求丢给这台机器。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  String key = invokers.get(<span class=\"number\">0</span>).getUrl().getServiceKey() + <span class=\"string\">\".\"</span> + invocation.getMethodName();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> maxWeight = <span class=\"number\">0</span>; <span class=\"comment\">//最大最小权重</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> minWeight = Integer.MAX_VALUE;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap = <span class=\"keyword\">new</span> LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> weightSum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = getWeight(invokers.get(i), invocation);</span><br><span class=\"line\">    maxWeight = Math.max(maxWeight, weight);</span><br><span class=\"line\">    minWeight = Math.min(minWeight, weight);<span class=\"comment\">//找出最大最小权重</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (weight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      invokerToWeightMap.put(invokers.get(i), <span class=\"keyword\">new</span> IntegerWrapper(weight));</span><br><span class=\"line\">      weightSum += weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  AtomicPositiveInteger sequence = sequences.get(key);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sequence == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    sequences.putIfAbsent(key, <span class=\"keyword\">new</span> AtomicPositiveInteger());</span><br><span class=\"line\">    sequence = sequences.get(key);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//下面通过mod和weight不断递减1，依次轮训调用</span></span><br><span class=\"line\">  <span class=\"comment\">//A:1 B:2 C:3 D:2，调用量：7</span></span><br><span class=\"line\">  <span class=\"comment\">//则轮训调用A1次，B2次，C3次，D1次</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> currentSequence = sequence.getAndIncrement();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (maxWeight &gt; <span class=\"number\">0</span> &amp;&amp; minWeight &lt; maxWeight) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> mod = currentSequence % weightSum;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxWeight; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Invoker&lt;T&gt; k = each.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> IntegerWrapper v = each.getValue();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mod == <span class=\"number\">0</span> &amp;&amp; v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v.getValue() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          v.decrement();</span><br><span class=\"line\">          mod--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(currentSequence % length);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>LeastActiveLoadBalance最低活跃量</li>\n</ul>\n<p>这种方式需要配合<code>ActiveLimitFilter</code>一起使用，有一点要注意，这个活跃度是针对客户端而言，它并没有通过zk同步每个终端调用量来得到服务端的真实负载，这个拦截器仅仅作为客户端限流用的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> &lt;T&gt; <span class=\"function\">Invoker&lt;T&gt; <span class=\"title\">doSelect</span><span class=\"params\">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> length = invokers.size(); <span class=\"comment\">//调用者数量</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> leastActive = -<span class=\"number\">1</span>; <span class=\"comment\">//最低活跃度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> leastCount = <span class=\"number\">0</span>; <span class=\"comment\">//多少相同最低活跃度</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span>[] leastIndexs = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[length]; <span class=\"comment\">//记录相等最低活跃度的调用者下标</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> totalWeight = <span class=\"number\">0</span>; <span class=\"comment\">//相同最低活跃度的权重总额</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> firstWeight = <span class=\"number\">0</span>; <span class=\"comment\">// Initial value, used for comparision</span></span><br><span class=\"line\">  <span class=\"keyword\">boolean</span> sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">//相同最低活跃度的调用者权重是否相等</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); <span class=\"comment\">// Active number</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); <span class=\"comment\">// Weight</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (leastActive == -<span class=\"number\">1</span> || active &lt; leastActive) &#123; <span class=\"comment\">// Restart, when find a invoker having smaller least active value.</span></span><br><span class=\"line\">      leastActive = active; <span class=\"comment\">//记录新的最低活跃度</span></span><br><span class=\"line\">      leastCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">      leastIndexs[<span class=\"number\">0</span>] = i; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      totalWeight = weight; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      firstWeight = weight; <span class=\"comment\">//重置</span></span><br><span class=\"line\">      sameWeight = <span class=\"keyword\">true</span>; <span class=\"comment\">// 重置</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (active == leastActive) &#123; <span class=\"comment\">// If current invoker's active value equals with leaseActive, then accumulating.</span></span><br><span class=\"line\">      leastIndexs[leastCount++] = i;</span><br><span class=\"line\">      totalWeight += weight; <span class=\"comment\">//累加权重</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sameWeight &amp;&amp; i &gt; <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; weight != firstWeight) &#123;</span><br><span class=\"line\">        sameWeight = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//最低活跃度只有一个，那那肯定是它</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (leastCount == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> invokers.get(leastIndexs[<span class=\"number\">0</span>]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//下面这一步不用多说了，与RandomLoadBalance一摸一样</span></span><br><span class=\"line\">  <span class=\"comment\">//最低活跃度相同的调用这，以权重比例随机访问</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> offsetWeight = random.nextInt(totalWeight);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">int</span> leastIndex = leastIndexs[i];</span><br><span class=\"line\">      offsetWeight -= getWeight(invokers.get(leastIndex), invocation);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (offsetWeight &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invokers.get(leastIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ConsistentHashLoadBalance一致性哈希</li>\n</ul>\n<p>这个其实没什么好说的，源码只是计算hash值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">一致性 Hash，相同参数的请求总是发到同一提供者。</span><br><span class=\"line\">当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</span><br></pre></td></tr></table></figure>\n"},{"title":"【网络编程】从Linux角度以及JVM源码，深入NIO的细节","date":"2019-01-09T05:17:21.000Z","_content":"\n最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。\n\n---\n\n因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。\n\n### 涉及的Linux知识\n\n#### 文件描述符\n\n对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。\n\n##### 设备阻塞与非阻塞\n\n任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到`wait_queue_head_t`中进行等待，直到被`semaphore`通知允许执行。此时可以通过`fcntl()`函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。\n\n#### JVM内存结构 & 虚拟地址空间\n\n众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用`jcmd pid VM.native_memory detail`可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过`pmap -p`可以看到进程内存信息。\n\n肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。\n![jvm内存虚拟地址](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png)\n\n#### socket编程\n\n先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。\n``` c\n// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输\n// type : SOCK_STREAM -> TCP, SOCK_DGRAM -> UDP\n// protocol : 0 系统默认\n// return : socket fd\nint socket(int domain, int type, int protocol);\n//sockfd : socket retuen fd\n//addr : sockaddr_in{sin_family=AF_INET -> ipv4,s_addr -> ip地址,sin_port -> 端口号}\n//addrlen : sockaddr的长度\nint bind(int sockfd, struct sockaddr* addr, int addrlen);\n//backlog : 最大连接数， syn queue + accpet queue 的大小\nint listen(int sockfd, int backlog);\n//同bind()的参数\nint accept(int sockfd, struct sockaddr addr, socklen_t addrlen);\nint connect(int sd, struct sockaddr *server, int addr_len);\n```\n另，socketIO可以使用`read & write`，和`recv & send`两种函数，后者多了一个参数flags。\n\n注，阻塞非阻塞模式，以下函数返回值有所区别。\n```c\nint write(int fd, void *buf, size_t nbytes);//pwrite(), writev()\nint read(int fd, void *buf, size_t nbytes);//pread(), readv()\n//flags：这里没打算展开讲，自行google\n//MSG_DONTROUTE 本地网络，不需查找路由\n//MSG_OOB TCP URG紧急指针，多用于心跳\n//MSG_PEEK  只读不取，数据保留在缓冲区\n//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞\nint recv(int sockfd,void *buf,int len,int flags);\nint send(int sockfd,void *buf,int len,int flags);\n```\n\n#### IO多路复用\n\nNIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux & mac下的实现。\n\n#### epoll\n不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。\n\n首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下`ep_loop_check`和`reverse_path_check`，我图论学得不好，看不下去。\n需要说明fd、event、epfd的关系，epfd <n/n> fd <n/n> event，均是多对多的关系。\n```c\ntypedef union epoll_data {\n  void *ptr; //如果需要，可以携带自定义数据\n  int fd; //被监听的事件\n  __uint32_t u32;\n  __uint64_t u64;\n} epoll_data_t;\n\nstruct epoll_event {\n  __uint32_t events;\n  //EPOLLOUT：TL，缓冲池为空\n  //EPOLLIN：TL，缓冲池为满\n  //EPOLLET：EL，有所变化\n  //还有其他，不一一列出了\n  epoll_data_t data;\n};\n//size : 可监听的最大数目，后来2.6.8开始，此参数无效\n//return : epoll fd\nint epoll_create(int size);\n//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd\n//fd : 被监听的事件\n//event : 上面的struct\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n//events : 就绪事件的数组\n//maxevents : 能被处理的最大事件数\n//timeout : 0 非阻塞，-1 阻塞，>0 等待超时\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\n值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，\n\n`EL`只在中断信号来临时反馈，所以`buffer cache`的数据未处理完，没有新数据到来是不会通知就绪的。\n`TL`则是会查看`buffer cache`是否还有数据，只要没有被处理完，会继续通知就绪。\n\n一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解[Linux手册](http://man7.org/linux/man-pages/man7/epoll.7.html)中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。\n\n对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。\n\n#### kqueue\n全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇[《FreeBSD Kqueue的实现原理》](https://blog.csdn.net/mumumuwudi/article/details/47145801)，外文的就是发明者的论文和[FreeBSD手册](https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current)了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。\n``` c\n//返回一个kqueue fd\nint kqueue(void);\n//用于注册、等待阻塞\n//changelist : 监听列表\n//nchanges : 监听数目\n//eventlist : 就绪列表\n//nevents : 就绪事件数目\n//timeout : 0 非阻塞，-1 阻塞，>0 等待超时\nint kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);\nstruct kevent {\n  //ident : 通常是个fd\n  uintpt_t ident;\n  //filter :\n  short filter; // filter for event\n  u_short flags; // action flags for kq\n  u_int fflags; // filter flag value\n  intptr_t data; // filter data value\n  void *udata; // opaque identifier\n}\n\nEV_SET(&kev, ident, filter, flags, fflags, data, udata);\n```\n\n### NIO源码\n\n#### 先来一个NIO网络通讯的示例\n\nServer，`IOException`是要做处理的，我懒得写。[示例代码](https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java)\n\nClient，`read()`同 Server。[示例代码](https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java)\n\n#### 多路复用们的包装类\n\n我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着`SelectorImpl`写的，所以还是先来讲讲起子类与多路复用的包装类们。\n\n#### `EPollSelectorImpl` & `EPollSelectorWapper`\n后者就是Linux中epoll编程的包装类，在对应的`EPollArrayWrapper.c`中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒`epoll_wait`。\n\n每种实现都是通过`selector.select();`进行轮询，其实现的终极入口在`SelectorImpl.doSelect(timeout)`，对于epoll来说，究极实现在`EPollArrayWrapper.poll(timeout)`，最后调用的则是`epoll_wait`，下面代码都是围绕着轮询实现。\n\n``` java\nclass EPollSelectorImpl extends SelectorImpl {\n  //用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口\n  protected int fd0;\n  protected int fd1;\n  //epoll声明的JNI包装类\n  EPollArrayWrapper pollWrapper;\n  //fd -> selectionKey\n  private Map<Integer,SelectionKeyImpl> fdToKey;\n  //关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见\n  private volatile boolean closed = false;\n\n  private Object interruptLock = new Object();\n  private boolean interruptTriggered = false;\n\n  EPollSelectorImpl(SelectorProvider sp) {\n    super(sp);\n    //...\n  }\n\n  protected int doSelect(long timeout) throws IOException {\n    if (closed)\n      throw new ClosedSelectorException();\n    //删除被cancel的selectionKey\n    processDeregisterQueue();\n    try {\n      begin();\n      pollWrapper.poll(timeout);\n    } finally {\n      end();\n    }\n    //删除阻塞中被其他线程cancel的selectionKey\n    processDeregisterQueue();\n    int numKeysUpdated = updateSelectedKeys();\n    //处理中断\n    if (pollWrapper.interrupted()) {\n      //清除pipe事件的响应，并恢复中断状态\n      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);\n      synchronized (interruptLock) {\n        pollWrapper.clearInterrupted();\n        //读取管道数据\n        IOUtil.drain(fd0);\n        interruptTriggered = false;\n      }\n    }\n    return numKeysUpdated;\n  }\n}\n\nclass EPollArrayWrapper {\n  private final int epfd;\n  //用于对epoll_event *events数组的增删查改\n  private final AllocatedNativeObject pollArray;\n  //*events地址\n  private final long pollArrayAddress;\n  //对应上面fd1\n  private int outgoingInterruptFD;\n  //对应上面fd0\n  private int incomingInterruptFD;\n  //*events中断事件的下标\n  private int interruptedIndex;\n\n  EPollArrayWrapper() throws IOException {\n    //创建epoll fd\n    epfd = epollCreate();\n    //...\n  }\n\n  int poll(long timeout) throws IOException {\n    updateRegistrations(); //更新注册的event\n    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);\n    for (int i=0; i<updated; i++) {\n      //管道事件唤醒epoll，结束等待\n      if (getDescriptor(i) == incomingInterruptFD) {\n        interruptedIndex = i;\n        interrupted = true;\n        break;\n      }\n    }\n    return updated;\n  }\n\n  public void interrupt() {\n    interrupt(outgoingInterruptFD);\n  }\n  //本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断\n  private static native void interrupt(int fd);\n}\n```\n\nEPollArrayWrapper的JNI代码，如下\n``` c\n#define RESTARTABLE(_cmd, _result) do { \\\n  do { \\\n    _result = _cmd; \\\n    //如果被系统中断而结束轮询，会继续下一次epoll_wait\n  } while((_result == -1) && (errno == EINTR)); \\\n} while(0)\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject this,\n                                            jlong address, jint numfds,\n                                            jlong timeout, jint epfd)\n{\n  struct epoll_event *events = jlong_to_ptr(address);//获取指针\n  int res;\n\n  if (timeout <= 0) { //无限阻塞 or 非阻塞\n    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);\n  } else {            //系统中断后，会继续下一次epoll_wait\n    res = iepoll(epfd, events, numfds, timeout);\n  }\n  //...\n  return res;\n}\n\nstatic int\niepoll(int epfd, struct epoll_event *events, int numfds, jlong timeout)\n{\n  jlong start, now;\n  int remaining = timeout;\n  struct timeval t;\n  int diff;\n\n  gettimeofday(&t, NULL);\n  start = t.tv_sec * 1000 + t.tv_usec / 1000;\n\n  for (;;) {\n    int res = epoll_wait(epfd, events, numfds, timeout);\n    //同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询\n    if (res < 0 && errno == EINTR) {\n      if (remaining >= 0) {\n        gettimeofday(&t, NULL);\n        now = t.tv_sec * 1000 + t.tv_usec / 1000;\n        diff = now - start;\n        remaining -= diff;\n        if (diff < 0 || remaining <= 0) {\n          return 0;\n        }\n        start = now;\n      }\n    } else {\n      return res;\n    }\n  }\n}\n```\n#### `KqueueSelectorImpl` & `KqueueSelectorWapper`\n\n我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。\n\n``` java\nclass KQueueSelectorImpl extends SelectorImpl {\n  protected int doSelect(long timeout) throws IOException {\n    int entries = 0;\n    if (closed)\n      throw new ClosedSelectorException();\n    processDeregisterQueue();\n    try {\n      begin();\n      entries = kqueueWrapper.poll(timeout);\n    } finally {\n      end();\n    }\n    processDeregisterQueue();\n    //这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的\n    return updateSelectedKeys(entries);\n  }\n}\n\nclass KQueueArrayWrapper {\n  int poll(long timeout) {\n    updateRegistrations();\n    int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);\n    return updated;\n  }\n  private native int kevent0(int kq, long keventAddress, int keventCount,\n                               long timeout);\n}\n```\n要说不同，也就最后`kevent0`的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。\n``` c\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,\n                                           jlong kevAddr, jint kevCount,\n                                           jlong timeout)\n{\n  //...\n  if (timeout >= 0) {\n    ts.tv_sec = timeout / 1000;\n    ts.tv_nsec = (timeout % 1000) * 1000000;\n    tsp = &ts;\n  } else {\n    tsp = NULL;\n  }\n  result = kevent(kq, NULL, 0, kevs, kevCount, tsp);\n\n  if (result < 0) {\n    if (errno == EINTR) {\n      result = 0;\n    } else {\n      JNU_ThrowIOExceptionWithLastError(env, \"KQueueArrayWrapper: kqueue failed\");\n    }\n  }\n  return result;\n}\n```\n由此，多路复用在JVM的实现到这为止。\n\n#### Channels\n讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。\n\n![Channel体系](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png)\n\n#### 接口类型及其作用\n\n`Channel`顶级接口，实际只提供一个`close()`。\n\n`InterruptibleChannel`注释写了用于异步关闭or中断，大概说的是`AbstractInterruptibleChannel.begin()`的回调，中断后调用`implCloseChannel()`。\n\n`SelectableChannel`这个就是多路复用提供的部分实现API。\n\n`NetworkChannel`网络IO，绑定、设置socket选项等。\n\n`ScatteringByteChannel` & `GatheringByteChannel`就是BufferByte读写了。\n\n`SeekableByteChannel`知道`lseek()`就明白是跟文件IO相关的了。\n\n#### 网络IO相关实现及其分析\n\n这里我需要先说明一下`configureBlocking(boolean)`方法，这实际是调用了上述说到`fcntl()`，可以看下`IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);`的JNI源码，所以下述socket fd都是非阻塞的，有`空循环`很正常。\n```c\n/*\n * IOUtil.c\n */\nstatic int\nconfigureBlocking(int fd, jboolean blocking)\n{\n  int flags = fcntl(fd, F_GETFL);\n  int newflags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);\n\n  return (flags == newflags) ? 0 : fcntl(fd, F_SETFL, newflags);\n}\n```\n不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的\bfd进行读写操作的。\n```java\npublic abstract class AbstractSelectableChannel\n    extends SelectableChannel\n{\n  public final SelectableChannel configureBlocking(boolean block)\n    throws IOException\n  {\n    synchronized (regLock) {\n      if (!isOpen())\n        throw new ClosedChannelException();\n      if (blocking == block)\n        return this;\n      //ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。\n      if (block && haveValidKeys())\n        throw new IllegalBlockingModeException();\n      implConfigureBlocking(block);\n      blocking = block;\n    }\n    return this;\n  }\n}\n```\n\n在上面已经提及`AbstractSelectableChannel.configureBlocking`这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。\n``` java\npublic final SelectionKey register(Selector sel, int ops,\n                                   Object att)\n    throws ClosedChannelException\n{\n  synchronized (regLock) {\n    if (!isOpen())\n      throw new ClosedChannelException();\n    //随意传一个int是非法的\n    if ((ops & ~validOps()) != 0)\n      throw new IllegalArgumentException();\n    //如上面所说，阻塞不能被注册的\n    if (blocking)\n      throw new IllegalBlockingModeException();\n    //从SelectionKey[]中查找是被注册过\n    SelectionKey k = findKey(sel);\n    if (k != null) {\n      //实际调用epoll_ctl + EPOLL_CTL_MOD\n      k.interestOps(ops);\n      k.attach(att);\n    }\n    if (k == null) {\n      synchronized (keyLock) {\n        if (!isOpen())\n          throw new ClosedChannelException();\n        //就是epoll_ctl + EPOLL_CTL_ADD\n        k = ((AbstractSelector)sel).register(this, ops, att);\n        addKey(k);\n      }\n    }\n    return k;\n  }\n}\n```\n\n来看看`ServerSocketChannel.open()`发射出去的实例`SocketChannelImpl`，示例中`ssc.bind(new InetSocketAddress(16767))`已经包含了`bind`&`listen`两个函数，这里也把`accpet()`给说了。\n``` java\nclass ServerSocketChannelImpl\n  extends ServerSocketChannel\n  implements SelChImpl\n{\n  //未初始化\n  private static final int ST_UNINITIALIZED = -1;\n  //正在使用\n  private static final int ST_INUSE = 0;\n  //socket被kill\n  private static final int ST_KILLED = 1;\n  ServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n    super(sp);\n    // Net包含一切与socket编程有关的JNI\n    this.fd =  Net.serverSocket(true);\n    // fd的真实地址\n    this.fdVal = IOUtil.fdVal(fd);\n    this.state = ST_INUSE;\n  }\n\n  public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {\n    synchronized (lock) {\n      //...\n      InetSocketAddress isa = (local == null) ? new InetSocketAddress(0) :\n          Net.checkAddress(local);\n      SecurityManager sm = System.getSecurityManager();\n      //...\n      //SDP相关的钩子，没看懂\n      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n      //实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind\n      Net.bind(fd, isa.getAddress(), isa.getPort());\n      Net.listen(fd, backlog < 1 ? 50 : backlog);\n      synchronized (stateLock) {\n        localAddress = Net.localAddress(fd);\n      }\n    }\n    return this;\n  }\n\n  public SocketChannel accept() throws IOException {\n    synchronized (lock) {\n      //...\n      SocketChannel sc = null;\n\n      int n = 0;\n      //connection fd，用于socket读写\n      FileDescriptor newfd = new FileDescriptor();\n      //客户端地址\n      InetSocketAddress[] isaa = new InetSocketAddress[1];\n\n      try {\n        begin();\n        if (!isOpen())\n          return null;\n        thread = NativeThread.current();\n        for (;;) {\n          n = accept(this.fd, newfd, isaa);\n          //遇到EINTR，忽略且继续监听\n          if ((n == IOStatus.INTERRUPTED) && isOpen())\n            continue;\n          break;\n        }\n      } finally {\n        thread = 0;\n        end(n > 0);\n        assert IOStatus.check(n);\n      }\n\n      if (n < 1)\n        return null;\n      //默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK\n      IOUtil.configureBlocking(newfd, true);\n      InetSocketAddress isa = isaa[0];\n      sc = new SocketChannelImpl(provider(), newfd, isa);\n      SecurityManager sm = System.getSecurityManager();\n      if (sm != null) {\n        //...\n      }\n      return sc;\n    }\n  }\n}\n```\nNet.c算是把Linux的socket编程都写了一遍了，部分是ipv6&udp的设置，我个人不是很了解。\n``` c\n/*\n *  Net.c\n */\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,\n                            jboolean stream, jboolean reuse, jboolean ignored)\n{\n  int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n  //参数参考上述内容\n  fd = socket(domain, type, 0);\n  if (fd < 0) {\n    return handleSocketError(env, errno);\n  }\n  //默认ipv4与ipv6能监听同一端口\n  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg, sizeof(int));\n\n  //如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）\n  //不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血\n  //int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;\n  setsockopt(fd, level, IP_MULTICAST_ALL, (char*)&arg, sizeof(arg));\n  //支持IPv6组播\n  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &arg, sizeof(arg));\n\n  //server是允许reuseadd的，client不允许\n  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, sizeof(arg));\n}\n\n/*\n * ServerSocketChannelImpl.c\n */\n JNIEXPORT jint JNICALL\n Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject this,\n                                                 jobject ssfdo, jobject newfdo,\n                                                 jobjectArray isaa)\n {\n   //...\n   //出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。\n   for (;;) {\n     socklen_t sa_len = alloc_len;\n     newfd = accept(ssfd, sa, &sa_len);\n     if (newfd >= 0) {\n       break;\n     }\n     if (errno != ECONNABORTED) {\n       break;\n     }\n   }\n\n   if (newfd < 0) {\n     free((void *)sa);\n     //IOS_** 同等IOStatus.java中的常量\n     if (errno == EAGAIN)\n       return IOS_UNAVAILABLE;\n     if (errno == EINTR)\n       return IOS_INTERRUPTED;\n     JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n     return IOS_THROWN;\n   }\n   //...\n   return 1;\n }\n```\n\n客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。\n``` java\npublic boolean connect(SocketAddress sa) throws IOException {\n  for (;;) {\n    InetAddress ia = isa.getAddress();\n    if (ia.isAnyLocalAddress())\n      ia = InetAddress.getLocalHost();\n    n = Net.connect(fd,\n                    ia,\n                    isa.getPort());\n    //同样忽略RST错误\n    if ((n == IOStatus.INTERRUPTED)\n          && isOpen())\n      continue;\n    break;\n  }\n}\n```\n\n#### 文件IO\n留个位置\n\n#### ByteBuffer体系\n\n从继承关系来看，其实并不复杂，数据结构也很简单，但对于`malloc`和`allocateDirect`分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了`零拷贝`。\n\n![ByteBuffer](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png)\n\n##### Buffer的指针\n就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。\n\n![Buffer的指针](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png)\n``` java\npublic abstract class Buffer {\n  //标记读取or写入位置\n  private int mark = -1;\n  //已读已写的位置\n  private int position = 0;\n  //最大极限\n  private int limit;\n  //容器容量\n  private int capacity;\n  //重设位置\n  public final Buffer position(int newPosition) {\n    if ((newPosition > limit) || (newPosition < 0))\n      throw new IllegalArgumentException();\n    position = newPosition;\n    //标记位超过新位置，重置为-1\n    if (mark > position) mark = -1;\n    return this;\n  }\n  //与position(int)方法同理\n  public final Buffer limit(int newLimit) {\n    if ((newLimit > capacity) || (newLimit < 0))\n      throw new IllegalArgumentException();\n    limit = newLimit;\n    //如果位置超出新限制，则重合pos和limit\n    if (position > limit) position = limit;\n    if (mark > limit) mark = -1;\n    return this;\n  }\n}\n```\n\n#### ByteBuffer\n都是一些读读写写的操作，不做讲述了。\n\n#### HeapByteBuffer\n其实就是个byte[]，这个确实没什么好讲的。\n``` java\nclass HeapByteBuffer extends ByteBuffer {\n  HeapByteBuffer(int cap, int lim) {\n    super(-1, 0, lim, cap, new byte[cap], 0);\n  }\n}\n```\n#### DirectByteBuffer\n正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数`-XX:MaxDirectMemorySize`控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面`DirectByteBuffer`的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。\n\n``` java\nclass DirectByteBuffer extends MappedByteBuffer implements DirectBuffer {\n    super(-1, 0, cap, cap);\n    //是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制\n    //如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    //这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配\n    //上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM\n    //关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n      //看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配\n      base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n      Bits.unreserveMemory(size, cap);\n      throw x;\n    }\n    //将内存全部置零\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n      // Round up to page boundary\n      address = base + ps - (base & (ps - 1));\n    } else {\n      address = base;\n    }\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n  }\n}\n```\n这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。\n\n如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。\n\n``` cpp\nUNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))\n  UnsafeWrapper(\"Unsafe_AllocateMemory\");\n  size_t sz = (size_t)size;\n  //...\n  if (sz == 0) {\n    return 0;\n  }\n  sz = round_to(sz, HeapWordSize);\n  void* x = os::malloc(sz, mtInternal);\n  //...\n  //Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);\n  return addr_to_java(x);\nUNSAFE_END\n```","source":"_posts/20190109-【网络编程】NIO的深入解析.md","raw":"---\ntitle: 【网络编程】从Linux角度以及JVM源码，深入NIO的细节\ndate: 2019-01-09 13:17:21\ntags:\n  - java\n  - NIO\n  - C++\n  - Linux内核\n  - 网络编程\ncategories:\n    - java网络编程\n---\n\n最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。\n\n---\n\n因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。\n\n### 涉及的Linux知识\n\n#### 文件描述符\n\n对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。\n\n##### 设备阻塞与非阻塞\n\n任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到`wait_queue_head_t`中进行等待，直到被`semaphore`通知允许执行。此时可以通过`fcntl()`函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。\n\n#### JVM内存结构 & 虚拟地址空间\n\n众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用`jcmd pid VM.native_memory detail`可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过`pmap -p`可以看到进程内存信息。\n\n肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。\n![jvm内存虚拟地址](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png)\n\n#### socket编程\n\n先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。\n``` c\n// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输\n// type : SOCK_STREAM -> TCP, SOCK_DGRAM -> UDP\n// protocol : 0 系统默认\n// return : socket fd\nint socket(int domain, int type, int protocol);\n//sockfd : socket retuen fd\n//addr : sockaddr_in{sin_family=AF_INET -> ipv4,s_addr -> ip地址,sin_port -> 端口号}\n//addrlen : sockaddr的长度\nint bind(int sockfd, struct sockaddr* addr, int addrlen);\n//backlog : 最大连接数， syn queue + accpet queue 的大小\nint listen(int sockfd, int backlog);\n//同bind()的参数\nint accept(int sockfd, struct sockaddr addr, socklen_t addrlen);\nint connect(int sd, struct sockaddr *server, int addr_len);\n```\n另，socketIO可以使用`read & write`，和`recv & send`两种函数，后者多了一个参数flags。\n\n注，阻塞非阻塞模式，以下函数返回值有所区别。\n```c\nint write(int fd, void *buf, size_t nbytes);//pwrite(), writev()\nint read(int fd, void *buf, size_t nbytes);//pread(), readv()\n//flags：这里没打算展开讲，自行google\n//MSG_DONTROUTE 本地网络，不需查找路由\n//MSG_OOB TCP URG紧急指针，多用于心跳\n//MSG_PEEK  只读不取，数据保留在缓冲区\n//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞\nint recv(int sockfd,void *buf,int len,int flags);\nint send(int sockfd,void *buf,int len,int flags);\n```\n\n#### IO多路复用\n\nNIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux & mac下的实现。\n\n#### epoll\n不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。\n\n首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下`ep_loop_check`和`reverse_path_check`，我图论学得不好，看不下去。\n需要说明fd、event、epfd的关系，epfd <n/n> fd <n/n> event，均是多对多的关系。\n```c\ntypedef union epoll_data {\n  void *ptr; //如果需要，可以携带自定义数据\n  int fd; //被监听的事件\n  __uint32_t u32;\n  __uint64_t u64;\n} epoll_data_t;\n\nstruct epoll_event {\n  __uint32_t events;\n  //EPOLLOUT：TL，缓冲池为空\n  //EPOLLIN：TL，缓冲池为满\n  //EPOLLET：EL，有所变化\n  //还有其他，不一一列出了\n  epoll_data_t data;\n};\n//size : 可监听的最大数目，后来2.6.8开始，此参数无效\n//return : epoll fd\nint epoll_create(int size);\n//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd\n//fd : 被监听的事件\n//event : 上面的struct\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n//events : 就绪事件的数组\n//maxevents : 能被处理的最大事件数\n//timeout : 0 非阻塞，-1 阻塞，>0 等待超时\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n```\n\n值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，\n\n`EL`只在中断信号来临时反馈，所以`buffer cache`的数据未处理完，没有新数据到来是不会通知就绪的。\n`TL`则是会查看`buffer cache`是否还有数据，只要没有被处理完，会继续通知就绪。\n\n一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解[Linux手册](http://man7.org/linux/man-pages/man7/epoll.7.html)中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。\n\n对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。\n\n#### kqueue\n全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇[《FreeBSD Kqueue的实现原理》](https://blog.csdn.net/mumumuwudi/article/details/47145801)，外文的就是发明者的论文和[FreeBSD手册](https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current)了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。\n``` c\n//返回一个kqueue fd\nint kqueue(void);\n//用于注册、等待阻塞\n//changelist : 监听列表\n//nchanges : 监听数目\n//eventlist : 就绪列表\n//nevents : 就绪事件数目\n//timeout : 0 非阻塞，-1 阻塞，>0 等待超时\nint kevent(int kq, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout);\nstruct kevent {\n  //ident : 通常是个fd\n  uintpt_t ident;\n  //filter :\n  short filter; // filter for event\n  u_short flags; // action flags for kq\n  u_int fflags; // filter flag value\n  intptr_t data; // filter data value\n  void *udata; // opaque identifier\n}\n\nEV_SET(&kev, ident, filter, flags, fflags, data, udata);\n```\n\n### NIO源码\n\n#### 先来一个NIO网络通讯的示例\n\nServer，`IOException`是要做处理的，我懒得写。[示例代码](https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java)\n\nClient，`read()`同 Server。[示例代码](https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java)\n\n#### 多路复用们的包装类\n\n我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着`SelectorImpl`写的，所以还是先来讲讲起子类与多路复用的包装类们。\n\n#### `EPollSelectorImpl` & `EPollSelectorWapper`\n后者就是Linux中epoll编程的包装类，在对应的`EPollArrayWrapper.c`中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒`epoll_wait`。\n\n每种实现都是通过`selector.select();`进行轮询，其实现的终极入口在`SelectorImpl.doSelect(timeout)`，对于epoll来说，究极实现在`EPollArrayWrapper.poll(timeout)`，最后调用的则是`epoll_wait`，下面代码都是围绕着轮询实现。\n\n``` java\nclass EPollSelectorImpl extends SelectorImpl {\n  //用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口\n  protected int fd0;\n  protected int fd1;\n  //epoll声明的JNI包装类\n  EPollArrayWrapper pollWrapper;\n  //fd -> selectionKey\n  private Map<Integer,SelectionKeyImpl> fdToKey;\n  //关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见\n  private volatile boolean closed = false;\n\n  private Object interruptLock = new Object();\n  private boolean interruptTriggered = false;\n\n  EPollSelectorImpl(SelectorProvider sp) {\n    super(sp);\n    //...\n  }\n\n  protected int doSelect(long timeout) throws IOException {\n    if (closed)\n      throw new ClosedSelectorException();\n    //删除被cancel的selectionKey\n    processDeregisterQueue();\n    try {\n      begin();\n      pollWrapper.poll(timeout);\n    } finally {\n      end();\n    }\n    //删除阻塞中被其他线程cancel的selectionKey\n    processDeregisterQueue();\n    int numKeysUpdated = updateSelectedKeys();\n    //处理中断\n    if (pollWrapper.interrupted()) {\n      //清除pipe事件的响应，并恢复中断状态\n      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0);\n      synchronized (interruptLock) {\n        pollWrapper.clearInterrupted();\n        //读取管道数据\n        IOUtil.drain(fd0);\n        interruptTriggered = false;\n      }\n    }\n    return numKeysUpdated;\n  }\n}\n\nclass EPollArrayWrapper {\n  private final int epfd;\n  //用于对epoll_event *events数组的增删查改\n  private final AllocatedNativeObject pollArray;\n  //*events地址\n  private final long pollArrayAddress;\n  //对应上面fd1\n  private int outgoingInterruptFD;\n  //对应上面fd0\n  private int incomingInterruptFD;\n  //*events中断事件的下标\n  private int interruptedIndex;\n\n  EPollArrayWrapper() throws IOException {\n    //创建epoll fd\n    epfd = epollCreate();\n    //...\n  }\n\n  int poll(long timeout) throws IOException {\n    updateRegistrations(); //更新注册的event\n    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);\n    for (int i=0; i<updated; i++) {\n      //管道事件唤醒epoll，结束等待\n      if (getDescriptor(i) == incomingInterruptFD) {\n        interruptedIndex = i;\n        interrupted = true;\n        break;\n      }\n    }\n    return updated;\n  }\n\n  public void interrupt() {\n    interrupt(outgoingInterruptFD);\n  }\n  //本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断\n  private static native void interrupt(int fd);\n}\n```\n\nEPollArrayWrapper的JNI代码，如下\n``` c\n#define RESTARTABLE(_cmd, _result) do { \\\n  do { \\\n    _result = _cmd; \\\n    //如果被系统中断而结束轮询，会继续下一次epoll_wait\n  } while((_result == -1) && (errno == EINTR)); \\\n} while(0)\n\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject this,\n                                            jlong address, jint numfds,\n                                            jlong timeout, jint epfd)\n{\n  struct epoll_event *events = jlong_to_ptr(address);//获取指针\n  int res;\n\n  if (timeout <= 0) { //无限阻塞 or 非阻塞\n    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);\n  } else {            //系统中断后，会继续下一次epoll_wait\n    res = iepoll(epfd, events, numfds, timeout);\n  }\n  //...\n  return res;\n}\n\nstatic int\niepoll(int epfd, struct epoll_event *events, int numfds, jlong timeout)\n{\n  jlong start, now;\n  int remaining = timeout;\n  struct timeval t;\n  int diff;\n\n  gettimeofday(&t, NULL);\n  start = t.tv_sec * 1000 + t.tv_usec / 1000;\n\n  for (;;) {\n    int res = epoll_wait(epfd, events, numfds, timeout);\n    //同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询\n    if (res < 0 && errno == EINTR) {\n      if (remaining >= 0) {\n        gettimeofday(&t, NULL);\n        now = t.tv_sec * 1000 + t.tv_usec / 1000;\n        diff = now - start;\n        remaining -= diff;\n        if (diff < 0 || remaining <= 0) {\n          return 0;\n        }\n        start = now;\n      }\n    } else {\n      return res;\n    }\n  }\n}\n```\n#### `KqueueSelectorImpl` & `KqueueSelectorWapper`\n\n我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。\n\n``` java\nclass KQueueSelectorImpl extends SelectorImpl {\n  protected int doSelect(long timeout) throws IOException {\n    int entries = 0;\n    if (closed)\n      throw new ClosedSelectorException();\n    processDeregisterQueue();\n    try {\n      begin();\n      entries = kqueueWrapper.poll(timeout);\n    } finally {\n      end();\n    }\n    processDeregisterQueue();\n    //这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的\n    return updateSelectedKeys(entries);\n  }\n}\n\nclass KQueueArrayWrapper {\n  int poll(long timeout) {\n    updateRegistrations();\n    int updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);\n    return updated;\n  }\n  private native int kevent0(int kq, long keventAddress, int keventCount,\n                               long timeout);\n}\n```\n要说不同，也就最后`kevent0`的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。\n``` c\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject this, jint kq,\n                                           jlong kevAddr, jint kevCount,\n                                           jlong timeout)\n{\n  //...\n  if (timeout >= 0) {\n    ts.tv_sec = timeout / 1000;\n    ts.tv_nsec = (timeout % 1000) * 1000000;\n    tsp = &ts;\n  } else {\n    tsp = NULL;\n  }\n  result = kevent(kq, NULL, 0, kevs, kevCount, tsp);\n\n  if (result < 0) {\n    if (errno == EINTR) {\n      result = 0;\n    } else {\n      JNU_ThrowIOExceptionWithLastError(env, \"KQueueArrayWrapper: kqueue failed\");\n    }\n  }\n  return result;\n}\n```\n由此，多路复用在JVM的实现到这为止。\n\n#### Channels\n讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。\n\n![Channel体系](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png)\n\n#### 接口类型及其作用\n\n`Channel`顶级接口，实际只提供一个`close()`。\n\n`InterruptibleChannel`注释写了用于异步关闭or中断，大概说的是`AbstractInterruptibleChannel.begin()`的回调，中断后调用`implCloseChannel()`。\n\n`SelectableChannel`这个就是多路复用提供的部分实现API。\n\n`NetworkChannel`网络IO，绑定、设置socket选项等。\n\n`ScatteringByteChannel` & `GatheringByteChannel`就是BufferByte读写了。\n\n`SeekableByteChannel`知道`lseek()`就明白是跟文件IO相关的了。\n\n#### 网络IO相关实现及其分析\n\n这里我需要先说明一下`configureBlocking(boolean)`方法，这实际是调用了上述说到`fcntl()`，可以看下`IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);`的JNI源码，所以下述socket fd都是非阻塞的，有`空循环`很正常。\n```c\n/*\n * IOUtil.c\n */\nstatic int\nconfigureBlocking(int fd, jboolean blocking)\n{\n  int flags = fcntl(fd, F_GETFL);\n  int newflags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);\n\n  return (flags == newflags) ? 0 : fcntl(fd, F_SETFL, newflags);\n}\n```\n不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的\bfd进行读写操作的。\n```java\npublic abstract class AbstractSelectableChannel\n    extends SelectableChannel\n{\n  public final SelectableChannel configureBlocking(boolean block)\n    throws IOException\n  {\n    synchronized (regLock) {\n      if (!isOpen())\n        throw new ClosedChannelException();\n      if (blocking == block)\n        return this;\n      //ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。\n      if (block && haveValidKeys())\n        throw new IllegalBlockingModeException();\n      implConfigureBlocking(block);\n      blocking = block;\n    }\n    return this;\n  }\n}\n```\n\n在上面已经提及`AbstractSelectableChannel.configureBlocking`这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。\n``` java\npublic final SelectionKey register(Selector sel, int ops,\n                                   Object att)\n    throws ClosedChannelException\n{\n  synchronized (regLock) {\n    if (!isOpen())\n      throw new ClosedChannelException();\n    //随意传一个int是非法的\n    if ((ops & ~validOps()) != 0)\n      throw new IllegalArgumentException();\n    //如上面所说，阻塞不能被注册的\n    if (blocking)\n      throw new IllegalBlockingModeException();\n    //从SelectionKey[]中查找是被注册过\n    SelectionKey k = findKey(sel);\n    if (k != null) {\n      //实际调用epoll_ctl + EPOLL_CTL_MOD\n      k.interestOps(ops);\n      k.attach(att);\n    }\n    if (k == null) {\n      synchronized (keyLock) {\n        if (!isOpen())\n          throw new ClosedChannelException();\n        //就是epoll_ctl + EPOLL_CTL_ADD\n        k = ((AbstractSelector)sel).register(this, ops, att);\n        addKey(k);\n      }\n    }\n    return k;\n  }\n}\n```\n\n来看看`ServerSocketChannel.open()`发射出去的实例`SocketChannelImpl`，示例中`ssc.bind(new InetSocketAddress(16767))`已经包含了`bind`&`listen`两个函数，这里也把`accpet()`给说了。\n``` java\nclass ServerSocketChannelImpl\n  extends ServerSocketChannel\n  implements SelChImpl\n{\n  //未初始化\n  private static final int ST_UNINITIALIZED = -1;\n  //正在使用\n  private static final int ST_INUSE = 0;\n  //socket被kill\n  private static final int ST_KILLED = 1;\n  ServerSocketChannelImpl(SelectorProvider sp) throws IOException {\n    super(sp);\n    // Net包含一切与socket编程有关的JNI\n    this.fd =  Net.serverSocket(true);\n    // fd的真实地址\n    this.fdVal = IOUtil.fdVal(fd);\n    this.state = ST_INUSE;\n  }\n\n  public ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException {\n    synchronized (lock) {\n      //...\n      InetSocketAddress isa = (local == null) ? new InetSocketAddress(0) :\n          Net.checkAddress(local);\n      SecurityManager sm = System.getSecurityManager();\n      //...\n      //SDP相关的钩子，没看懂\n      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());\n      //实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind\n      Net.bind(fd, isa.getAddress(), isa.getPort());\n      Net.listen(fd, backlog < 1 ? 50 : backlog);\n      synchronized (stateLock) {\n        localAddress = Net.localAddress(fd);\n      }\n    }\n    return this;\n  }\n\n  public SocketChannel accept() throws IOException {\n    synchronized (lock) {\n      //...\n      SocketChannel sc = null;\n\n      int n = 0;\n      //connection fd，用于socket读写\n      FileDescriptor newfd = new FileDescriptor();\n      //客户端地址\n      InetSocketAddress[] isaa = new InetSocketAddress[1];\n\n      try {\n        begin();\n        if (!isOpen())\n          return null;\n        thread = NativeThread.current();\n        for (;;) {\n          n = accept(this.fd, newfd, isaa);\n          //遇到EINTR，忽略且继续监听\n          if ((n == IOStatus.INTERRUPTED) && isOpen())\n            continue;\n          break;\n        }\n      } finally {\n        thread = 0;\n        end(n > 0);\n        assert IOStatus.check(n);\n      }\n\n      if (n < 1)\n        return null;\n      //默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK\n      IOUtil.configureBlocking(newfd, true);\n      InetSocketAddress isa = isaa[0];\n      sc = new SocketChannelImpl(provider(), newfd, isa);\n      SecurityManager sm = System.getSecurityManager();\n      if (sm != null) {\n        //...\n      }\n      return sc;\n    }\n  }\n}\n```\nNet.c算是把Linux的socket编程都写了一遍了，部分是ipv6&udp的设置，我个人不是很了解。\n``` c\n/*\n *  Net.c\n */\nJNIEXPORT jint JNICALL\nJava_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,\n                            jboolean stream, jboolean reuse, jboolean ignored)\n{\n  int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n  //参数参考上述内容\n  fd = socket(domain, type, 0);\n  if (fd < 0) {\n    return handleSocketError(env, errno);\n  }\n  //默认ipv4与ipv6能监听同一端口\n  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg, sizeof(int));\n\n  //如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）\n  //不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血\n  //int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;\n  setsockopt(fd, level, IP_MULTICAST_ALL, (char*)&arg, sizeof(arg));\n  //支持IPv6组播\n  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &arg, sizeof(arg));\n\n  //server是允许reuseadd的，client不允许\n  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg, sizeof(arg));\n}\n\n/*\n * ServerSocketChannelImpl.c\n */\n JNIEXPORT jint JNICALL\n Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject this,\n                                                 jobject ssfdo, jobject newfdo,\n                                                 jobjectArray isaa)\n {\n   //...\n   //出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。\n   for (;;) {\n     socklen_t sa_len = alloc_len;\n     newfd = accept(ssfd, sa, &sa_len);\n     if (newfd >= 0) {\n       break;\n     }\n     if (errno != ECONNABORTED) {\n       break;\n     }\n   }\n\n   if (newfd < 0) {\n     free((void *)sa);\n     //IOS_** 同等IOStatus.java中的常量\n     if (errno == EAGAIN)\n       return IOS_UNAVAILABLE;\n     if (errno == EINTR)\n       return IOS_INTERRUPTED;\n     JNU_ThrowIOExceptionWithLastError(env, \"Accept failed\");\n     return IOS_THROWN;\n   }\n   //...\n   return 1;\n }\n```\n\n客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。\n``` java\npublic boolean connect(SocketAddress sa) throws IOException {\n  for (;;) {\n    InetAddress ia = isa.getAddress();\n    if (ia.isAnyLocalAddress())\n      ia = InetAddress.getLocalHost();\n    n = Net.connect(fd,\n                    ia,\n                    isa.getPort());\n    //同样忽略RST错误\n    if ((n == IOStatus.INTERRUPTED)\n          && isOpen())\n      continue;\n    break;\n  }\n}\n```\n\n#### 文件IO\n留个位置\n\n#### ByteBuffer体系\n\n从继承关系来看，其实并不复杂，数据结构也很简单，但对于`malloc`和`allocateDirect`分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了`零拷贝`。\n\n![ByteBuffer](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png)\n\n##### Buffer的指针\n就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。\n\n![Buffer的指针](https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png)\n``` java\npublic abstract class Buffer {\n  //标记读取or写入位置\n  private int mark = -1;\n  //已读已写的位置\n  private int position = 0;\n  //最大极限\n  private int limit;\n  //容器容量\n  private int capacity;\n  //重设位置\n  public final Buffer position(int newPosition) {\n    if ((newPosition > limit) || (newPosition < 0))\n      throw new IllegalArgumentException();\n    position = newPosition;\n    //标记位超过新位置，重置为-1\n    if (mark > position) mark = -1;\n    return this;\n  }\n  //与position(int)方法同理\n  public final Buffer limit(int newLimit) {\n    if ((newLimit > capacity) || (newLimit < 0))\n      throw new IllegalArgumentException();\n    limit = newLimit;\n    //如果位置超出新限制，则重合pos和limit\n    if (position > limit) position = limit;\n    if (mark > limit) mark = -1;\n    return this;\n  }\n}\n```\n\n#### ByteBuffer\n都是一些读读写写的操作，不做讲述了。\n\n#### HeapByteBuffer\n其实就是个byte[]，这个确实没什么好讲的。\n``` java\nclass HeapByteBuffer extends ByteBuffer {\n  HeapByteBuffer(int cap, int lim) {\n    super(-1, 0, lim, cap, new byte[cap], 0);\n  }\n}\n```\n#### DirectByteBuffer\n正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数`-XX:MaxDirectMemorySize`控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面`DirectByteBuffer`的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。\n\n``` java\nclass DirectByteBuffer extends MappedByteBuffer implements DirectBuffer {\n    super(-1, 0, cap, cap);\n    //是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制\n    //如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率\n    boolean pa = VM.isDirectMemoryPageAligned();\n    int ps = Bits.pageSize();\n    long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n    //这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配\n    //上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM\n    //关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/\n    Bits.reserveMemory(size, cap);\n\n    long base = 0;\n    try {\n      //看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配\n      base = unsafe.allocateMemory(size);\n    } catch (OutOfMemoryError x) {\n      Bits.unreserveMemory(size, cap);\n      throw x;\n    }\n    //将内存全部置零\n    unsafe.setMemory(base, size, (byte) 0);\n    if (pa && (base % ps != 0)) {\n      // Round up to page boundary\n      address = base + ps - (base & (ps - 1));\n    } else {\n      address = base;\n    }\n    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n    att = null;\n  }\n}\n```\n这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。\n\n如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。\n\n``` cpp\nUNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))\n  UnsafeWrapper(\"Unsafe_AllocateMemory\");\n  size_t sz = (size_t)size;\n  //...\n  if (sz == 0) {\n    return 0;\n  }\n  sz = round_to(sz, HeapWordSize);\n  void* x = os::malloc(sz, mtInternal);\n  //...\n  //Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);\n  return addr_to_java(x);\nUNSAFE_END\n```","slug":"20190109-【网络编程】NIO的深入解析","published":1,"updated":"2019-12-19T05:05:51.050Z","_id":"ck4b9g7t500354ejd7q5k4abh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。</p>\n<hr>\n<p>因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。</p>\n<h3 id=\"涉及的Linux知识\"><a href=\"#涉及的Linux知识\" class=\"headerlink\" title=\"涉及的Linux知识\"></a>涉及的Linux知识</h3><h4 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h4><p>对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。</p>\n<h5 id=\"设备阻塞与非阻塞\"><a href=\"#设备阻塞与非阻塞\" class=\"headerlink\" title=\"设备阻塞与非阻塞\"></a>设备阻塞与非阻塞</h5><p>任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到<code>wait_queue_head_t</code>中进行等待，直到被<code>semaphore</code>通知允许执行。此时可以通过<code>fcntl()</code>函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。</p>\n<h4 id=\"JVM内存结构-amp-虚拟地址空间\"><a href=\"#JVM内存结构-amp-虚拟地址空间\" class=\"headerlink\" title=\"JVM内存结构 &amp; 虚拟地址空间\"></a>JVM内存结构 &amp; 虚拟地址空间</h4><p>众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用<code>jcmd pid VM.native_memory detail</code>可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过<code>pmap -p</code>可以看到进程内存信息。</p>\n<p>肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。<br><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png\" alt=\"jvm内存虚拟地址\"></p>\n<h4 id=\"socket编程\"><a href=\"#socket编程\" class=\"headerlink\" title=\"socket编程\"></a>socket编程</h4><p>先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输</span></span><br><span class=\"line\"><span class=\"comment\">// type : SOCK_STREAM -&gt; TCP, SOCK_DGRAM -&gt; UDP</span></span><br><span class=\"line\"><span class=\"comment\">// protocol : 0 系统默认</span></span><br><span class=\"line\"><span class=\"comment\">// return : socket fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//sockfd : socket retuen fd</span></span><br><span class=\"line\"><span class=\"comment\">//addr : sockaddr_in&#123;sin_family=AF_INET -&gt; ipv4,s_addr -&gt; ip地址,sin_port -&gt; 端口号&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//addrlen : sockaddr的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">int</span> addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//backlog : 最大连接数， syn queue + accpet queue 的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//同bind()的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sd, struct sockaddr *server, <span class=\"keyword\">int</span> addr_len)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>另，socketIO可以使用<code>read &amp; write</code>，和<code>recv &amp; send</code>两种函数，后者多了一个参数flags。</p>\n<p>注，阻塞非阻塞模式，以下函数返回值有所区别。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span></span>;<span class=\"comment\">//pwrite(), writev()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span></span>;<span class=\"comment\">//pread(), readv()</span></span><br><span class=\"line\"><span class=\"comment\">//flags：这里没打算展开讲，自行google</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_DONTROUTE 本地网络，不需查找路由</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_OOB TCP URG紧急指针，多用于心跳</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_PEEK  只读不取，数据保留在缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h4><p>NIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux &amp; mac下的实现。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。</p>\n<p>首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下<code>ep_loop_check</code>和<code>reverse_path_check</code>，我图论学得不好，看不下去。<br>需要说明fd、event、epfd的关系，epfd &lt;n/n&gt; fd &lt;n/n&gt; event，均是多对多的关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *ptr; <span class=\"comment\">//如果需要，可以携带自定义数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd; <span class=\"comment\">//被监听的事件</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span> u32;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span> events;</span><br><span class=\"line\">  <span class=\"comment\">//EPOLLOUT：TL，缓冲池为空</span></span><br><span class=\"line\">  <span class=\"comment\">//EPOLLIN：TL，缓冲池为满</span></span><br><span class=\"line\">  <span class=\"comment\">//EPOLLET：EL，有所变化</span></span><br><span class=\"line\">  <span class=\"comment\">//还有其他，不一一列出了</span></span><br><span class=\"line\">  <span class=\"keyword\">epoll_data_t</span> data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//size : 可监听的最大数目，后来2.6.8开始，此参数无效</span></span><br><span class=\"line\"><span class=\"comment\">//return : epoll fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd</span></span><br><span class=\"line\"><span class=\"comment\">//fd : 被监听的事件</span></span><br><span class=\"line\"><span class=\"comment\">//event : 上面的struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//events : 就绪事件的数组</span></span><br><span class=\"line\"><span class=\"comment\">//maxevents : 能被处理的最大事件数</span></span><br><span class=\"line\"><span class=\"comment\">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event *events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，</p>\n<p><code>EL</code>只在中断信号来临时反馈，所以<code>buffer cache</code>的数据未处理完，没有新数据到来是不会通知就绪的。<br><code>TL</code>则是会查看<code>buffer cache</code>是否还有数据，只要没有被处理完，会继续通知就绪。</p>\n<p>一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解<a href=\"http://man7.org/linux/man-pages/man7/epoll.7.html\" target=\"_blank\" rel=\"noopener\">Linux手册</a>中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。</p>\n<p>对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。</p>\n<h4 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h4><p>全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇<a href=\"https://blog.csdn.net/mumumuwudi/article/details/47145801\" target=\"_blank\" rel=\"noopener\">《FreeBSD Kqueue的实现原理》</a>，外文的就是发明者的论文和<a href=\"https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current\" target=\"_blank\" rel=\"noopener\">FreeBSD手册</a>了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回一个kqueue fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kqueue</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//用于注册、等待阻塞</span></span><br><span class=\"line\"><span class=\"comment\">//changelist : 监听列表</span></span><br><span class=\"line\"><span class=\"comment\">//nchanges : 监听数目</span></span><br><span class=\"line\"><span class=\"comment\">//eventlist : 就绪列表</span></span><br><span class=\"line\"><span class=\"comment\">//nevents : 就绪事件数目</span></span><br><span class=\"line\"><span class=\"comment\">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kevent</span><span class=\"params\">(<span class=\"keyword\">int</span> kq, <span class=\"keyword\">const</span> struct kevent *changelist, <span class=\"keyword\">int</span> nchanges, struct kevent *eventlist, <span class=\"keyword\">int</span> nevents, <span class=\"keyword\">const</span> struct timespec *timeout)</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kevent</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//ident : 通常是个fd</span></span><br><span class=\"line\">  <span class=\"keyword\">uintpt_t</span> ident;</span><br><span class=\"line\">  <span class=\"comment\">//filter :</span></span><br><span class=\"line\">  short filter; <span class=\"comment\">// filter for event</span></span><br><span class=\"line\">  u_short flags; <span class=\"comment\">// action flags for kq</span></span><br><span class=\"line\">  u_int fflags; <span class=\"comment\">// filter flag value</span></span><br><span class=\"line\">  <span class=\"keyword\">intptr_t</span> data; <span class=\"comment\">// filter data value</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *udata; <span class=\"comment\">// opaque identifier</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EV_SET(&amp;kev, ident, filter, flags, fflags, data, udata);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NIO源码\"><a href=\"#NIO源码\" class=\"headerlink\" title=\"NIO源码\"></a>NIO源码</h3><h4 id=\"先来一个NIO网络通讯的示例\"><a href=\"#先来一个NIO网络通讯的示例\" class=\"headerlink\" title=\"先来一个NIO网络通讯的示例\"></a>先来一个NIO网络通讯的示例</h4><p>Server，<code>IOException</code>是要做处理的，我懒得写。<a href=\"https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java\" target=\"_blank\" rel=\"noopener\">示例代码</a></p>\n<p>Client，<code>read()</code>同 Server。<a href=\"https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java\" target=\"_blank\" rel=\"noopener\">示例代码</a></p>\n<h4 id=\"多路复用们的包装类\"><a href=\"#多路复用们的包装类\" class=\"headerlink\" title=\"多路复用们的包装类\"></a>多路复用们的包装类</h4><p>我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着<code>SelectorImpl</code>写的，所以还是先来讲讲起子类与多路复用的包装类们。</p>\n<h4 id=\"EPollSelectorImpl-amp-EPollSelectorWapper\"><a href=\"#EPollSelectorImpl-amp-EPollSelectorWapper\" class=\"headerlink\" title=\"EPollSelectorImpl &amp; EPollSelectorWapper\"></a><code>EPollSelectorImpl</code> &amp; <code>EPollSelectorWapper</code></h4><p>后者就是Linux中epoll编程的包装类，在对应的<code>EPollArrayWrapper.c</code>中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒<code>epoll_wait</code>。</p>\n<p>每种实现都是通过<code>selector.select();</code>进行轮询，其实现的终极入口在<code>SelectorImpl.doSelect(timeout)</code>，对于epoll来说，究极实现在<code>EPollArrayWrapper.poll(timeout)</code>，最后调用的则是<code>epoll_wait</code>，下面代码都是围绕着轮询实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EPollSelectorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">SelectorImpl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> fd0;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> fd1;</span><br><span class=\"line\">  <span class=\"comment\">//epoll声明的JNI包装类</span></span><br><span class=\"line\">  EPollArrayWrapper pollWrapper;</span><br><span class=\"line\">  <span class=\"comment\">//fd -&gt; selectionKey</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br><span class=\"line\">  <span class=\"comment\">//关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> closed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object interruptLock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> interruptTriggered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  EPollSelectorImpl(SelectorProvider sp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(sp);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">doSelect</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedSelectorException();</span><br><span class=\"line\">    <span class=\"comment\">//删除被cancel的selectionKey</span></span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      begin();</span><br><span class=\"line\">      pollWrapper.poll(timeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除阻塞中被其他线程cancel的selectionKey</span></span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class=\"line\">    <span class=\"comment\">//处理中断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//清除pipe事件的响应，并恢复中断状态</span></span><br><span class=\"line\">      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (interruptLock) &#123;</span><br><span class=\"line\">        pollWrapper.clearInterrupted();</span><br><span class=\"line\">        <span class=\"comment\">//读取管道数据</span></span><br><span class=\"line\">        IOUtil.drain(fd0);</span><br><span class=\"line\">        interruptTriggered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numKeysUpdated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EPollArrayWrapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> epfd;</span><br><span class=\"line\">  <span class=\"comment\">//用于对epoll_event *events数组的增删查改</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AllocatedNativeObject pollArray;</span><br><span class=\"line\">  <span class=\"comment\">//*events地址</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> pollArrayAddress;</span><br><span class=\"line\">  <span class=\"comment\">//对应上面fd1</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outgoingInterruptFD;</span><br><span class=\"line\">  <span class=\"comment\">//对应上面fd0</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> incomingInterruptFD;</span><br><span class=\"line\">  <span class=\"comment\">//*events中断事件的下标</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> interruptedIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">  EPollArrayWrapper() <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建epoll fd</span></span><br><span class=\"line\">    epfd = epollCreate();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    updateRegistrations(); <span class=\"comment\">//更新注册的event</span></span><br><span class=\"line\">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;updated; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//管道事件唤醒epoll，结束等待</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class=\"line\">        interruptedIndex = i;</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> updated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    interrupt(outgoingInterruptFD);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EPollArrayWrapper的JNI代码，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESTARTABLE(_cmd, _result) do &#123; \\</span></span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    _result = _cmd; \\</span><br><span class=\"line\">    <span class=\"comment\">//如果被系统中断而结束轮询，会继续下一次epoll_wait</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span>((_result == <span class=\"number\">-1</span>) &amp;&amp; (errno == EINTR)); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                            jlong address, jint numfds,</span><br><span class=\"line\">                                            jlong timeout, jint epfd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> *<span class=\"title\">events</span> = <span class=\"title\">jlong_to_ptr</span>(<span class=\"title\">address</span>);</span><span class=\"comment\">//获取指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timeout &lt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">//无限阻塞 or 非阻塞</span></span><br><span class=\"line\">    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"comment\">//系统中断后，会继续下一次epoll_wait</span></span><br><span class=\"line\">    res = iepoll(epfd, events, numfds, timeout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">iepoll(<span class=\"keyword\">int</span> epfd, struct epoll_event *events, <span class=\"keyword\">int</span> numfds, jlong timeout)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  jlong start, now;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> remaining = timeout;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">t</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  gettimeofday(&amp;t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  start = t.tv_sec * <span class=\"number\">1000</span> + t.tv_usec / <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = epoll_wait(epfd, events, numfds, timeout);</span><br><span class=\"line\">    <span class=\"comment\">//同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res &lt; <span class=\"number\">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        gettimeofday(&amp;t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        now = t.tv_sec * <span class=\"number\">1000</span> + t.tv_usec / <span class=\"number\">1000</span>;</span><br><span class=\"line\">        diff = now - start;</span><br><span class=\"line\">        remaining -= diff;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">0</span> || remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        start = now;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"KqueueSelectorImpl-amp-KqueueSelectorWapper\"><a href=\"#KqueueSelectorImpl-amp-KqueueSelectorWapper\" class=\"headerlink\" title=\"KqueueSelectorImpl &amp; KqueueSelectorWapper\"></a><code>KqueueSelectorImpl</code> &amp; <code>KqueueSelectorWapper</code></h4><p>我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KQueueSelectorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">SelectorImpl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">doSelect</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> entries = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedSelectorException();</span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      begin();</span><br><span class=\"line\">      entries = kqueueWrapper.poll(timeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"comment\">//这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> updateSelectedKeys(entries);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KQueueArrayWrapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">    updateRegistrations();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> updated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">kevent0</span><span class=\"params\">(<span class=\"keyword\">int</span> kq, <span class=\"keyword\">long</span> keventAddress, <span class=\"keyword\">int</span> keventCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">long</span> timeout)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要说不同，也就最后<code>kevent0</code>的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jint kq,</span><br><span class=\"line\">                                           jlong kevAddr, jint kevCount,</span><br><span class=\"line\">                                           jlong timeout)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timeout &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ts.tv_sec = timeout / <span class=\"number\">1000</span>;</span><br><span class=\"line\">    ts.tv_nsec = (timeout % <span class=\"number\">1000</span>) * <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    tsp = &amp;ts;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    tsp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result = kevent(kq, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, kevs, kevCount, tsp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">      result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"KQueueArrayWrapper: kqueue failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此，多路复用在JVM的实现到这为止。</p>\n<h4 id=\"Channels\"><a href=\"#Channels\" class=\"headerlink\" title=\"Channels\"></a>Channels</h4><p>讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png\" alt=\"Channel体系\"></p>\n<h4 id=\"接口类型及其作用\"><a href=\"#接口类型及其作用\" class=\"headerlink\" title=\"接口类型及其作用\"></a>接口类型及其作用</h4><p><code>Channel</code>顶级接口，实际只提供一个<code>close()</code>。</p>\n<p><code>InterruptibleChannel</code>注释写了用于异步关闭or中断，大概说的是<code>AbstractInterruptibleChannel.begin()</code>的回调，中断后调用<code>implCloseChannel()</code>。</p>\n<p><code>SelectableChannel</code>这个就是多路复用提供的部分实现API。</p>\n<p><code>NetworkChannel</code>网络IO，绑定、设置socket选项等。</p>\n<p><code>ScatteringByteChannel</code> &amp; <code>GatheringByteChannel</code>就是BufferByte读写了。</p>\n<p><code>SeekableByteChannel</code>知道<code>lseek()</code>就明白是跟文件IO相关的了。</p>\n<h4 id=\"网络IO相关实现及其分析\"><a href=\"#网络IO相关实现及其分析\" class=\"headerlink\" title=\"网络IO相关实现及其分析\"></a>网络IO相关实现及其分析</h4><p>这里我需要先说明一下<code>configureBlocking(boolean)</code>方法，这实际是调用了上述说到<code>fcntl()</code>，可以看下<code>IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);</code>的JNI源码，所以下述socket fd都是非阻塞的，有<code>空循环</code>很正常。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * IOUtil.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">configureBlocking(<span class=\"keyword\">int</span> fd, jboolean blocking)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newflags = blocking ? (flags &amp; ~O_NONBLOCK) : (flags | O_NONBLOCK);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (flags == newflags) ? <span class=\"number\">0</span> : fcntl(fd, F_SETFL, newflags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的\bfd进行读写操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractSelectableChannel</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">SelectableChannel</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> SelectableChannel <span class=\"title\">configureBlocking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> block)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (regLock) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (blocking == block)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"comment\">//ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalBlockingModeException();</span><br><span class=\"line\">      implConfigureBlocking(block);</span><br><span class=\"line\">      blocking = block;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面已经提及<code>AbstractSelectableChannel.configureBlocking</code>这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> SelectionKey <span class=\"title\">register</span><span class=\"params\">(Selector sel, <span class=\"keyword\">int</span> ops,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   Object att)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ClosedChannelException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (regLock) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">    <span class=\"comment\">//随意传一个int是非法的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ops &amp; ~validOps()) != <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"comment\">//如上面所说，阻塞不能被注册的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (blocking)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalBlockingModeException();</span><br><span class=\"line\">    <span class=\"comment\">//从SelectionKey[]中查找是被注册过</span></span><br><span class=\"line\">    SelectionKey k = findKey(sel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//实际调用epoll_ctl + EPOLL_CTL_MOD</span></span><br><span class=\"line\">      k.interestOps(ops);</span><br><span class=\"line\">      k.attach(att);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (keyLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">        <span class=\"comment\">//就是epoll_ctl + EPOLL_CTL_ADD</span></span><br><span class=\"line\">        k = ((AbstractSelector)sel).register(<span class=\"keyword\">this</span>, ops, att);</span><br><span class=\"line\">        addKey(k);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来看看<code>ServerSocketChannel.open()</code>发射出去的实例<code>SocketChannelImpl</code>，示例中<code>ssc.bind(new InetSocketAddress(16767))</code>已经包含了<code>bind</code>&amp;<code>listen</code>两个函数，这里也把<code>accpet()</code>给说了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerSocketChannelImpl</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">extends</span> <span class=\"title\">ServerSocketChannel</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">SelChImpl</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//未初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_UNINITIALIZED = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//正在使用</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_INUSE = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//socket被kill</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_KILLED = <span class=\"number\">1</span>;</span><br><span class=\"line\">  ServerSocketChannelImpl(SelectorProvider sp) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(sp);</span><br><span class=\"line\">    <span class=\"comment\">// Net包含一切与socket编程有关的JNI</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fd =  Net.serverSocket(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">// fd的真实地址</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = ST_INUSE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ServerSocketChannel <span class=\"title\">bind</span><span class=\"params\">(SocketAddress local, <span class=\"keyword\">int</span> backlog)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      InetSocketAddress isa = (local == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">0</span>) :</span><br><span class=\"line\">          Net.checkAddress(local);</span><br><span class=\"line\">      SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"comment\">//SDP相关的钩子，没看懂</span></span><br><span class=\"line\">      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class=\"line\">      <span class=\"comment\">//实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind</span></span><br><span class=\"line\">      Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class=\"line\">      Net.listen(fd, backlog &lt; <span class=\"number\">1</span> ? <span class=\"number\">50</span> : backlog);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (stateLock) &#123;</span><br><span class=\"line\">        localAddress = Net.localAddress(fd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> SocketChannel <span class=\"title\">accept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      SocketChannel sc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">//connection fd，用于socket读写</span></span><br><span class=\"line\">      FileDescriptor newfd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">      <span class=\"comment\">//客户端地址</span></span><br><span class=\"line\">      InetSocketAddress[] isaa = <span class=\"keyword\">new</span> InetSocketAddress[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        begin();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        thread = NativeThread.current();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">          n = accept(<span class=\"keyword\">this</span>.fd, newfd, isaa);</span><br><span class=\"line\">          <span class=\"comment\">//遇到EINTR，忽略且继续监听</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen())</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        thread = <span class=\"number\">0</span>;</span><br><span class=\"line\">        end(n &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IOStatus.check(n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">//默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK</span></span><br><span class=\"line\">      IOUtil.configureBlocking(newfd, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      InetSocketAddress isa = isaa[<span class=\"number\">0</span>];</span><br><span class=\"line\">      sc = <span class=\"keyword\">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class=\"line\">      SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Net.c算是把Linux的socket编程都写了一遍了，部分是ipv6&amp;udp的设置，我个人不是很了解。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  Net.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class=\"line\">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class=\"line\">  <span class=\"comment\">//参数参考上述内容</span></span><br><span class=\"line\">  fd = socket(domain, type, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleSocketError(env, errno);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//默认ipv4与ipv6能监听同一端口</span></span><br><span class=\"line\">  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）</span></span><br><span class=\"line\">  <span class=\"comment\">//不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血</span></span><br><span class=\"line\">  <span class=\"comment\">//int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span></span><br><span class=\"line\">  setsockopt(fd, level, IP_MULTICAST_ALL, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\">  <span class=\"comment\">//支持IPv6组播</span></span><br><span class=\"line\">  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//server是允许reuseadd的，client不允许</span></span><br><span class=\"line\">  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ServerSocketChannelImpl.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> JNIEXPORT jint JNICALL</span><br><span class=\"line\"> Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                                 jobject ssfdo, jobject newfdo,</span><br><span class=\"line\">                                                 jobjectArray isaa)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//...</span></span><br><span class=\"line\">   <span class=\"comment\">//出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">socklen_t</span> sa_len = alloc_len;</span><br><span class=\"line\">     newfd = accept(ssfd, sa, &amp;sa_len);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (newfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno != ECONNABORTED) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (newfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">free</span>((<span class=\"keyword\">void</span> *)sa);</span><br><span class=\"line\">     <span class=\"comment\">//IOS_** 同等IOStatus.java中的常量</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> IOS_UNAVAILABLE;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> IOS_INTERRUPTED;</span><br><span class=\"line\">     JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Accept failed\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> IOS_THROWN;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//...</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connect</span><span class=\"params\">(SocketAddress sa)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    InetAddress ia = isa.getAddress();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ia.isAnyLocalAddress())</span><br><span class=\"line\">      ia = InetAddress.getLocalHost();</span><br><span class=\"line\">    n = Net.connect(fd,</span><br><span class=\"line\">                    ia,</span><br><span class=\"line\">                    isa.getPort());</span><br><span class=\"line\">    <span class=\"comment\">//同样忽略RST错误</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((n == IOStatus.INTERRUPTED)</span><br><span class=\"line\">          &amp;&amp; isOpen())</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"文件IO\"><a href=\"#文件IO\" class=\"headerlink\" title=\"文件IO\"></a>文件IO</h4><p>留个位置</p>\n<h4 id=\"ByteBuffer体系\"><a href=\"#ByteBuffer体系\" class=\"headerlink\" title=\"ByteBuffer体系\"></a>ByteBuffer体系</h4><p>从继承关系来看，其实并不复杂，数据结构也很简单，但对于<code>malloc</code>和<code>allocateDirect</code>分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了<code>零拷贝</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png\" alt=\"ByteBuffer\"></p>\n<h5 id=\"Buffer的指针\"><a href=\"#Buffer的指针\" class=\"headerlink\" title=\"Buffer的指针\"></a>Buffer的指针</h5><p>就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png\" alt=\"Buffer的指针\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//标记读取or写入位置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//已读已写的位置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//最大极限</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> limit;</span><br><span class=\"line\">  <span class=\"comment\">//容器容量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">  <span class=\"comment\">//重设位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">position</span><span class=\"params\">(<span class=\"keyword\">int</span> newPosition)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    position = newPosition;</span><br><span class=\"line\">    <span class=\"comment\">//标记位超过新位置，重置为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mark &gt; position) mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//与position(int)方法同理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">limit</span><span class=\"params\">(<span class=\"keyword\">int</span> newLimit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    limit = newLimit;</span><br><span class=\"line\">    <span class=\"comment\">//如果位置超出新限制，则重合pos和limit</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt; limit) position = limit;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mark &gt; limit) mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a>ByteBuffer</h4><p>都是一些读读写写的操作，不做讲述了。</p>\n<h4 id=\"HeapByteBuffer\"><a href=\"#HeapByteBuffer\" class=\"headerlink\" title=\"HeapByteBuffer\"></a>HeapByteBuffer</h4><p>其实就是个byte[]，这个确实没什么好讲的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ByteBuffer</span> </span>&#123;</span><br><span class=\"line\">  HeapByteBuffer(<span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> lim) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, lim, cap, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[cap], <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DirectByteBuffer\"><a href=\"#DirectByteBuffer\" class=\"headerlink\" title=\"DirectByteBuffer\"></a>DirectByteBuffer</h4><p>正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数<code>-XX:MaxDirectMemorySize</code>控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面<code>DirectByteBuffer</code>的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">MappedByteBuffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">DirectBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, cap, cap);</span><br><span class=\"line\">    <span class=\"comment\">//是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制</span></span><br><span class=\"line\">    <span class=\"comment\">//如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ps = Bits.pageSize();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> size = Math.max(<span class=\"number\">1L</span>, (<span class=\"keyword\">long</span>)cap + (pa ? ps : <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配</span></span><br><span class=\"line\">    <span class=\"comment\">//上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM</span></span><br><span class=\"line\">    <span class=\"comment\">//关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/</span></span><br><span class=\"line\">    Bits.reserveMemory(size, cap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> base = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配</span></span><br><span class=\"line\">      base = unsafe.allocateMemory(size);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">      Bits.unreserveMemory(size, cap);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将内存全部置零</span></span><br><span class=\"line\">    unsafe.setMemory(base, size, (<span class=\"keyword\">byte</span>) <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa &amp;&amp; (base % ps != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Round up to page boundary</span></span><br><span class=\"line\">      address = base + ps - (base &amp; (ps - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      address = base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br><span class=\"line\">    att = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。</p>\n<p>如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class=\"line\">  UnsafeWrapper(<span class=\"string\">\"Unsafe_AllocateMemory\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> sz = (<span class=\"keyword\">size_t</span>)size;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sz == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sz = round_to(sz, HeapWordSize);</span><br><span class=\"line\">  <span class=\"keyword\">void</span>* x = os::<span class=\"built_in\">malloc</span>(sz, mtInternal);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr_to_java(x);</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>最近一段时间都在啃Linux内核， 也给了自己机会再度深入理解Java的NIO实现，希望能获得更多东西，尝试理解以前未能理解的，会涉及少量OpenJDK源码。</p>\n<hr>\n<p>因为NIO本身的实现很多牵扯到操作系统，所以需要先稍微过一下，有理解不对的地方，请指出。</p>\n<h3 id=\"涉及的Linux知识\"><a href=\"#涉及的Linux知识\" class=\"headerlink\" title=\"涉及的Linux知识\"></a>涉及的Linux知识</h3><h4 id=\"文件描述符\"><a href=\"#文件描述符\" class=\"headerlink\" title=\"文件描述符\"></a>文件描述符</h4><p>对于Linux来说，一切皆为文件，设备文件、IO文件还是普通文件，都可以通过一个叫做文件描述符（FileDescriptor）的东西来进行操作，其涉及的数据结构可以自行了解VFS。</p>\n<h5 id=\"设备阻塞与非阻塞\"><a href=\"#设备阻塞与非阻塞\" class=\"headerlink\" title=\"设备阻塞与非阻塞\"></a>设备阻塞与非阻塞</h5><p>任意对设备的操作都是默认为阻塞的，如果没有或有不可操作的资源，会被添加到<code>wait_queue_head_t</code>中进行等待，直到被<code>semaphore</code>通知允许执行。此时可以通过<code>fcntl()</code>函数将文件描述符设置为非阻塞，若没有或有不可操作的资源，立即返回错误信息。</p>\n<h4 id=\"JVM内存结构-amp-虚拟地址空间\"><a href=\"#JVM内存结构-amp-虚拟地址空间\" class=\"headerlink\" title=\"JVM内存结构 &amp; 虚拟地址空间\"></a>JVM内存结构 &amp; 虚拟地址空间</h4><p>众所周知，Linux下的每一进程都有自己的虚拟内存地址，而JVM也是一个进程，且JVM有自己的内存结构。既然如此，两者之间必有对应关系，OracleJDK7提供了NMT，用<code>jcmd pid VM.native_memory detail</code>可以查看各类区域的reserved，被committed的内存大小及其地址区间，再通过<code>pmap -p</code>可以看到进程内存信息。</p>\n<p>肉眼对比地址区间可以发现，JVM heap是通过mmap分配内存的，位于进程的映射区内，而进程堆区可以被malloc进行分配，对应关系如图。<br><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jvm%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80.png\" alt=\"jvm内存虚拟地址\"></p>\n<h4 id=\"socket编程\"><a href=\"#socket编程\" class=\"headerlink\" title=\"socket编程\"></a>socket编程</h4><p>先回顾一下几个相关函数，JVM相关实现可以看Net.c源码，这里不做赘述。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// domain : AF_UNIX|AF_LOCAL 本地传输，AF_INET|AF_INET6  ipv4/6传输</span></span><br><span class=\"line\"><span class=\"comment\">// type : SOCK_STREAM -&gt; TCP, SOCK_DGRAM -&gt; UDP</span></span><br><span class=\"line\"><span class=\"comment\">// protocol : 0 系统默认</span></span><br><span class=\"line\"><span class=\"comment\">// return : socket fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//sockfd : socket retuen fd</span></span><br><span class=\"line\"><span class=\"comment\">//addr : sockaddr_in&#123;sin_family=AF_INET -&gt; ipv4,s_addr -&gt; ip地址,sin_port -&gt; 端口号&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//addrlen : sockaddr的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">int</span> addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//backlog : 最大连接数， syn queue + accpet queue 的大小</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//同bind()的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sd, struct sockaddr *server, <span class=\"keyword\">int</span> addr_len)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>另，socketIO可以使用<code>read &amp; write</code>，和<code>recv &amp; send</code>两种函数，后者多了一个参数flags。</p>\n<p>注，阻塞非阻塞模式，以下函数返回值有所区别。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span></span>;<span class=\"comment\">//pwrite(), writev()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes)</span></span>;<span class=\"comment\">//pread(), readv()</span></span><br><span class=\"line\"><span class=\"comment\">//flags：这里没打算展开讲，自行google</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_DONTROUTE 本地网络，不需查找路由</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_OOB TCP URG紧急指针，多用于心跳</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_PEEK  只读不取，数据保留在缓冲区</span></span><br><span class=\"line\"><span class=\"comment\">//MSG_WAITALL 等待到满足指定条件才返回，在此之前会一直阻塞</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd,<span class=\"keyword\">void</span> *buf,<span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h4><p>NIO在不同操作系统提供了不同实现，win-select，linux-epoll以及mac-kqueue，本文忽略windows平台，只说linux &amp; mac下的实现。</p>\n<h4 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h4><p>不太想讲epoll跟select的区别，网上多的是，不过唯一要说epoll本身是fd，很多功能都基于此，也不需要select一样重复实例化，下面的kqueue也是一样。</p>\n<p>首先是epoll是个文件，所以有可能被其他epoll/select/poll监听，所以可能会出现循环或反向路径，内核实现极其复杂冗长，有兴趣可以啃下<code>ep_loop_check</code>和<code>reverse_path_check</code>，我图论学得不好，看不下去。<br>需要说明fd、event、epfd的关系，epfd &lt;n/n&gt; fd &lt;n/n&gt; event，均是多对多的关系。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data &#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> *ptr; <span class=\"comment\">//如果需要，可以携带自定义数据</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd; <span class=\"comment\">//被监听的事件</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span> u32;</span><br><span class=\"line\">  <span class=\"keyword\">__uint64_t</span> u64;</span><br><span class=\"line\">&#125; <span class=\"keyword\">epoll_data_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">__uint32_t</span> events;</span><br><span class=\"line\">  <span class=\"comment\">//EPOLLOUT：TL，缓冲池为空</span></span><br><span class=\"line\">  <span class=\"comment\">//EPOLLIN：TL，缓冲池为满</span></span><br><span class=\"line\">  <span class=\"comment\">//EPOLLET：EL，有所变化</span></span><br><span class=\"line\">  <span class=\"comment\">//还有其他，不一一列出了</span></span><br><span class=\"line\">  <span class=\"keyword\">epoll_data_t</span> data;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//size : 可监听的最大数目，后来2.6.8开始，此参数无效</span></span><br><span class=\"line\"><span class=\"comment\">//return : epoll fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//op : EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL 分别是新增修改删除fd</span></span><br><span class=\"line\"><span class=\"comment\">//fd : 被监听的事件</span></span><br><span class=\"line\"><span class=\"comment\">//event : 上面的struct</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//events : 就绪事件的数组</span></span><br><span class=\"line\"><span class=\"comment\">//maxevents : 能被处理的最大事件数</span></span><br><span class=\"line\"><span class=\"comment\">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event *events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，epoll的边沿模式(EL)和水平模式(TL)，</p>\n<p><code>EL</code>只在中断信号来临时反馈，所以<code>buffer cache</code>的数据未处理完，没有新数据到来是不会通知就绪的。<br><code>TL</code>则是会查看<code>buffer cache</code>是否还有数据，只要没有被处理完，会继续通知就绪。</p>\n<p>一个关于这两种模式的问题，就EL模式是否必须把fd设置为O_NONBLOCK。我不是很理解<a href=\"http://man7.org/linux/man-pages/man7/epoll.7.html\" target=\"_blank\" rel=\"noopener\">Linux手册</a>中对EL的描述，为什么要和EL扯上关系，若是因为读写阻塞导致后续任务饥饿，那在TL是一样的后果。要我说，既然用了epoll，那就直接把fd设置为O_NONBLOCK得了，就没那么多事。</p>\n<p>对此我强烈建议写过一次linux下的网络编程，加强理解，这里不写示例了。</p>\n<h4 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h4><p>全网关于kqueue的文章少之又少，特别是中文，描述得比较详细的只有这篇<a href=\"https://blog.csdn.net/mumumuwudi/article/details/47145801\" target=\"_blank\" rel=\"noopener\">《FreeBSD Kqueue的实现原理》</a>，外文的就是发明者的论文和<a href=\"https://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2&manpath=FreeBSD+5.0-current\" target=\"_blank\" rel=\"noopener\">FreeBSD手册</a>了。kqueue的数据结构我并没有完全搞懂，懒得啃FreeBSD的实现（解压出来的源码有1.05g 手动微笑）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回一个kqueue fd</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kqueue</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//用于注册、等待阻塞</span></span><br><span class=\"line\"><span class=\"comment\">//changelist : 监听列表</span></span><br><span class=\"line\"><span class=\"comment\">//nchanges : 监听数目</span></span><br><span class=\"line\"><span class=\"comment\">//eventlist : 就绪列表</span></span><br><span class=\"line\"><span class=\"comment\">//nevents : 就绪事件数目</span></span><br><span class=\"line\"><span class=\"comment\">//timeout : 0 非阻塞，-1 阻塞，&gt;0 等待超时</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kevent</span><span class=\"params\">(<span class=\"keyword\">int</span> kq, <span class=\"keyword\">const</span> struct kevent *changelist, <span class=\"keyword\">int</span> nchanges, struct kevent *eventlist, <span class=\"keyword\">int</span> nevents, <span class=\"keyword\">const</span> struct timespec *timeout)</span></span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">kevent</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//ident : 通常是个fd</span></span><br><span class=\"line\">  <span class=\"keyword\">uintpt_t</span> ident;</span><br><span class=\"line\">  <span class=\"comment\">//filter :</span></span><br><span class=\"line\">  short filter; <span class=\"comment\">// filter for event</span></span><br><span class=\"line\">  u_short flags; <span class=\"comment\">// action flags for kq</span></span><br><span class=\"line\">  u_int fflags; <span class=\"comment\">// filter flag value</span></span><br><span class=\"line\">  <span class=\"keyword\">intptr_t</span> data; <span class=\"comment\">// filter data value</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> *udata; <span class=\"comment\">// opaque identifier</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">EV_SET(&amp;kev, ident, filter, flags, fflags, data, udata);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"NIO源码\"><a href=\"#NIO源码\" class=\"headerlink\" title=\"NIO源码\"></a>NIO源码</h3><h4 id=\"先来一个NIO网络通讯的示例\"><a href=\"#先来一个NIO网络通讯的示例\" class=\"headerlink\" title=\"先来一个NIO网络通讯的示例\"></a>先来一个NIO网络通讯的示例</h4><p>Server，<code>IOException</code>是要做处理的，我懒得写。<a href=\"https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ServerDemo.java\" target=\"_blank\" rel=\"noopener\">示例代码</a></p>\n<p>Client，<code>read()</code>同 Server。<a href=\"https://github.com/zehonghuang/github_blog_bak/blob/master/source/file/ClientDemo.java\" target=\"_blank\" rel=\"noopener\">示例代码</a></p>\n<h4 id=\"多路复用们的包装类\"><a href=\"#多路复用们的包装类\" class=\"headerlink\" title=\"多路复用们的包装类\"></a>多路复用们的包装类</h4><p>我很想按照demo的代码顺序讲，但感觉NIO的实现几乎围绕着<code>SelectorImpl</code>写的，所以还是先来讲讲起子类与多路复用的包装类们。</p>\n<h4 id=\"EPollSelectorImpl-amp-EPollSelectorWapper\"><a href=\"#EPollSelectorImpl-amp-EPollSelectorWapper\" class=\"headerlink\" title=\"EPollSelectorImpl &amp; EPollSelectorWapper\"></a><code>EPollSelectorImpl</code> &amp; <code>EPollSelectorWapper</code></h4><p>后者就是Linux中epoll编程的包装类，在对应的<code>EPollArrayWrapper.c</code>中可以看出调用的都是上面说到的函数，实现类特意注册了一个管道用于唤醒<code>epoll_wait</code>。</p>\n<p>每种实现都是通过<code>selector.select();</code>进行轮询，其实现的终极入口在<code>SelectorImpl.doSelect(timeout)</code>，对于epoll来说，究极实现在<code>EPollArrayWrapper.poll(timeout)</code>，最后调用的则是<code>epoll_wait</code>，下面代码都是围绕着轮询实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EPollSelectorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">SelectorImpl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//用于中断epoll阻塞的pipe文件描述符，fd0:入口 fd1:出口</span></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> fd0;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> fd1;</span><br><span class=\"line\">  <span class=\"comment\">//epoll声明的JNI包装类</span></span><br><span class=\"line\">  EPollArrayWrapper pollWrapper;</span><br><span class=\"line\">  <span class=\"comment\">//fd -&gt; selectionKey</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Map&lt;Integer,SelectionKeyImpl&gt; fdToKey;</span><br><span class=\"line\">  <span class=\"comment\">//关闭selector，将会把所有文件描述符全部close并置为-1，implClose()可见</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> closed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> Object interruptLock = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> interruptTriggered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  EPollSelectorImpl(SelectorProvider sp) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(sp);</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">doSelect</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedSelectorException();</span><br><span class=\"line\">    <span class=\"comment\">//删除被cancel的selectionKey</span></span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      begin();</span><br><span class=\"line\">      pollWrapper.poll(timeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//删除阻塞中被其他线程cancel的selectionKey</span></span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> numKeysUpdated = updateSelectedKeys();</span><br><span class=\"line\">    <span class=\"comment\">//处理中断</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pollWrapper.interrupted()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//清除pipe事件的响应，并恢复中断状态</span></span><br><span class=\"line\">      pollWrapper.putEventOps(pollWrapper.interruptedIndex(), <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (interruptLock) &#123;</span><br><span class=\"line\">        pollWrapper.clearInterrupted();</span><br><span class=\"line\">        <span class=\"comment\">//读取管道数据</span></span><br><span class=\"line\">        IOUtil.drain(fd0);</span><br><span class=\"line\">        interruptTriggered = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> numKeysUpdated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EPollArrayWrapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> epfd;</span><br><span class=\"line\">  <span class=\"comment\">//用于对epoll_event *events数组的增删查改</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AllocatedNativeObject pollArray;</span><br><span class=\"line\">  <span class=\"comment\">//*events地址</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> pollArrayAddress;</span><br><span class=\"line\">  <span class=\"comment\">//对应上面fd1</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> outgoingInterruptFD;</span><br><span class=\"line\">  <span class=\"comment\">//对应上面fd0</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> incomingInterruptFD;</span><br><span class=\"line\">  <span class=\"comment\">//*events中断事件的下标</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> interruptedIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">  EPollArrayWrapper() <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建epoll fd</span></span><br><span class=\"line\">    epfd = epollCreate();</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    updateRegistrations(); <span class=\"comment\">//更新注册的event</span></span><br><span class=\"line\">    updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;updated; i++) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//管道事件唤醒epoll，结束等待</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (getDescriptor(i) == incomingInterruptFD) &#123;</span><br><span class=\"line\">        interruptedIndex = i;</span><br><span class=\"line\">        interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> updated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    interrupt(outgoingInterruptFD);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//本地方法名: Java_sun_nio_ch_EPollArrayWrapper_interrupt，会向管道传递数字「1」表中断</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">interrupt</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>EPollArrayWrapper的JNI代码，如下</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> RESTARTABLE(_cmd, _result) do &#123; \\</span></span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123; \\</span><br><span class=\"line\">    _result = _cmd; \\</span><br><span class=\"line\">    <span class=\"comment\">//如果被系统中断而结束轮询，会继续下一次epoll_wait</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">while</span>((_result == <span class=\"number\">-1</span>) &amp;&amp; (errno == EINTR)); \\</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                            jlong address, jint numfds,</span><br><span class=\"line\">                                            jlong timeout, jint epfd)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> *<span class=\"title\">events</span> = <span class=\"title\">jlong_to_ptr</span>(<span class=\"title\">address</span>);</span><span class=\"comment\">//获取指针</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timeout &lt;= <span class=\"number\">0</span>) &#123; <span class=\"comment\">//无限阻塞 or 非阻塞</span></span><br><span class=\"line\">    RESTARTABLE((*epoll_wait_func)(epfd, events, numfds, timeout), res);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;            <span class=\"comment\">//系统中断后，会继续下一次epoll_wait</span></span><br><span class=\"line\">    res = iepoll(epfd, events, numfds, timeout);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">iepoll(<span class=\"keyword\">int</span> epfd, struct epoll_event *events, <span class=\"keyword\">int</span> numfds, jlong timeout)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  jlong start, now;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> remaining = timeout;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">t</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> diff;</span><br><span class=\"line\"></span><br><span class=\"line\">  gettimeofday(&amp;t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  start = t.tv_sec * <span class=\"number\">1000</span> + t.tv_usec / <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = epoll_wait(epfd, events, numfds, timeout);</span><br><span class=\"line\">    <span class=\"comment\">//同RESTARTABLE，被中断后重新计算剩余超时时间并继续轮询</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res &lt; <span class=\"number\">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (remaining &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        gettimeofday(&amp;t, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        now = t.tv_sec * <span class=\"number\">1000</span> + t.tv_usec / <span class=\"number\">1000</span>;</span><br><span class=\"line\">        diff = now - start;</span><br><span class=\"line\">        remaining -= diff;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (diff &lt; <span class=\"number\">0</span> || remaining &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        start = now;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"KqueueSelectorImpl-amp-KqueueSelectorWapper\"><a href=\"#KqueueSelectorImpl-amp-KqueueSelectorWapper\" class=\"headerlink\" title=\"KqueueSelectorImpl &amp; KqueueSelectorWapper\"></a><code>KqueueSelectorImpl</code> &amp; <code>KqueueSelectorWapper</code></h4><p>我挺纠结是否要说kqueue，毕竟除了本身的声明过程，其他几乎与上述的epoll一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KQueueSelectorImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">SelectorImpl</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">doSelect</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> entries = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (closed)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedSelectorException();</span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      begin();</span><br><span class=\"line\">      entries = kqueueWrapper.poll(timeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      end();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    processDeregisterQueue();</span><br><span class=\"line\">    <span class=\"comment\">//这里更新selectedKey的位置不同，但其中逻辑与epoll是一样的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> updateSelectedKeys(entries);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KQueueArrayWrapper</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout)</span> </span>&#123;</span><br><span class=\"line\">    updateRegistrations();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> updated = kevent0(kq, keventArrayAddress, NUM_KEVENTS, timeout);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> updated;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">native</span> <span class=\"keyword\">int</span> <span class=\"title\">kevent0</span><span class=\"params\">(<span class=\"keyword\">int</span> kq, <span class=\"keyword\">long</span> keventAddress, <span class=\"keyword\">int</span> keventCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                               <span class=\"keyword\">long</span> timeout)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要说不同，也就最后<code>kevent0</code>的轮询，不像epoll收到中断后会继续轮询，这里是直接return 0，由用户代码继续下一次轮询。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_KQueueArrayWrapper_kevent0(JNIEnv *env, jobject <span class=\"keyword\">this</span>, jint kq,</span><br><span class=\"line\">                                           jlong kevAddr, jint kevCount,</span><br><span class=\"line\">                                           jlong timeout)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (timeout &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    ts.tv_sec = timeout / <span class=\"number\">1000</span>;</span><br><span class=\"line\">    ts.tv_nsec = (timeout % <span class=\"number\">1000</span>) * <span class=\"number\">1000000</span>;</span><br><span class=\"line\">    tsp = &amp;ts;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    tsp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result = kevent(kq, <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>, kevs, kevCount, tsp);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (result &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errno == EINTR) &#123;</span><br><span class=\"line\">      result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"KQueueArrayWrapper: kqueue failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此，多路复用在JVM的实现到这为止。</p>\n<h4 id=\"Channels\"><a href=\"#Channels\" class=\"headerlink\" title=\"Channels\"></a>Channels</h4><p>讲道理，这个图看起来复杂，其实功能接口很分明，阅读难度并不大。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Channel%E4%BD%93%E7%B3%BB.png\" alt=\"Channel体系\"></p>\n<h4 id=\"接口类型及其作用\"><a href=\"#接口类型及其作用\" class=\"headerlink\" title=\"接口类型及其作用\"></a>接口类型及其作用</h4><p><code>Channel</code>顶级接口，实际只提供一个<code>close()</code>。</p>\n<p><code>InterruptibleChannel</code>注释写了用于异步关闭or中断，大概说的是<code>AbstractInterruptibleChannel.begin()</code>的回调，中断后调用<code>implCloseChannel()</code>。</p>\n<p><code>SelectableChannel</code>这个就是多路复用提供的部分实现API。</p>\n<p><code>NetworkChannel</code>网络IO，绑定、设置socket选项等。</p>\n<p><code>ScatteringByteChannel</code> &amp; <code>GatheringByteChannel</code>就是BufferByte读写了。</p>\n<p><code>SeekableByteChannel</code>知道<code>lseek()</code>就明白是跟文件IO相关的了。</p>\n<h4 id=\"网络IO相关实现及其分析\"><a href=\"#网络IO相关实现及其分析\" class=\"headerlink\" title=\"网络IO相关实现及其分析\"></a>网络IO相关实现及其分析</h4><p>这里我需要先说明一下<code>configureBlocking(boolean)</code>方法，这实际是调用了上述说到<code>fcntl()</code>，可以看下<code>IOUtil.configureBlocking(FileDescriptor fd, boolean blocking);</code>的JNI源码，所以下述socket fd都是非阻塞的，有<code>空循环</code>很正常。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * IOUtil.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span><br><span class=\"line\">configureBlocking(<span class=\"keyword\">int</span> fd, jboolean blocking)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> flags = fcntl(fd, F_GETFL);</span><br><span class=\"line\">  <span class=\"keyword\">int</span> newflags = blocking ? (flags &amp; ~O_NONBLOCK) : (flags | O_NONBLOCK);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (flags == newflags) ? <span class=\"number\">0</span> : fcntl(fd, F_SETFL, newflags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过有必要说明该方法的使用注意事项，一旦fd(即channel)被注册后，是不能重新设置为阻塞的。如果在注册前或不需要注册，是可以使用阻塞模式的\bfd进行读写操作的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractSelectableChannel</span></span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"keyword\">extends</span> <span class=\"title\">SelectableChannel</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> SelectableChannel <span class=\"title\">configureBlocking</span><span class=\"params\">(<span class=\"keyword\">boolean</span> block)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> IOException</span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (regLock) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (blocking == block)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">      <span class=\"comment\">//ValidKeys是查找该fd是否有注册的key，如果有且设置为阻塞，直接抛异常。</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (block &amp;&amp; haveValidKeys())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalBlockingModeException();</span><br><span class=\"line\">      implConfigureBlocking(block);</span><br><span class=\"line\">      blocking = block;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面已经提及<code>AbstractSelectableChannel.configureBlocking</code>这么小而重要的方法，有一个与其息息相关的方法就是register了。需要说的是，epfd(或kq)和被监听的fd是可以多对多的，所以每个channel都需要被维护一个selectionKey[]记录被哪些epfd监听。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> SelectionKey <span class=\"title\">register</span><span class=\"params\">(Selector sel, <span class=\"keyword\">int</span> ops,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                   Object att)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> ClosedChannelException</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">synchronized</span> (regLock) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">    <span class=\"comment\">//随意传一个int是非法的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((ops &amp; ~validOps()) != <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"comment\">//如上面所说，阻塞不能被注册的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (blocking)</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalBlockingModeException();</span><br><span class=\"line\">    <span class=\"comment\">//从SelectionKey[]中查找是被注册过</span></span><br><span class=\"line\">    SelectionKey k = findKey(sel);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//实际调用epoll_ctl + EPOLL_CTL_MOD</span></span><br><span class=\"line\">      k.interestOps(ops);</span><br><span class=\"line\">      k.attach(att);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (keyLock) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClosedChannelException();</span><br><span class=\"line\">        <span class=\"comment\">//就是epoll_ctl + EPOLL_CTL_ADD</span></span><br><span class=\"line\">        k = ((AbstractSelector)sel).register(<span class=\"keyword\">this</span>, ops, att);</span><br><span class=\"line\">        addKey(k);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> k;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来看看<code>ServerSocketChannel.open()</code>发射出去的实例<code>SocketChannelImpl</code>，示例中<code>ssc.bind(new InetSocketAddress(16767))</code>已经包含了<code>bind</code>&amp;<code>listen</code>两个函数，这里也把<code>accpet()</code>给说了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServerSocketChannelImpl</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">extends</span> <span class=\"title\">ServerSocketChannel</span></span></span><br><span class=\"line\"><span class=\"class\">  <span class=\"keyword\">implements</span> <span class=\"title\">SelChImpl</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//未初始化</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_UNINITIALIZED = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//正在使用</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_INUSE = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//socket被kill</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> ST_KILLED = <span class=\"number\">1</span>;</span><br><span class=\"line\">  ServerSocketChannelImpl(SelectorProvider sp) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(sp);</span><br><span class=\"line\">    <span class=\"comment\">// Net包含一切与socket编程有关的JNI</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fd =  Net.serverSocket(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"comment\">// fd的真实地址</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.fdVal = IOUtil.fdVal(fd);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = ST_INUSE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ServerSocketChannel <span class=\"title\">bind</span><span class=\"params\">(SocketAddress local, <span class=\"keyword\">int</span> backlog)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      InetSocketAddress isa = (local == <span class=\"keyword\">null</span>) ? <span class=\"keyword\">new</span> InetSocketAddress(<span class=\"number\">0</span>) :</span><br><span class=\"line\">          Net.checkAddress(local);</span><br><span class=\"line\">      SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      <span class=\"comment\">//SDP相关的钩子，没看懂</span></span><br><span class=\"line\">      NetHooks.beforeTcpBind(fd, isa.getAddress(), isa.getPort());</span><br><span class=\"line\">      <span class=\"comment\">//实际调用的是net_util_md.c的NET_InetAddressToSockaddr 和NET_Bind</span></span><br><span class=\"line\">      Net.bind(fd, isa.getAddress(), isa.getPort());</span><br><span class=\"line\">      Net.listen(fd, backlog &lt; <span class=\"number\">1</span> ? <span class=\"number\">50</span> : backlog);</span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span> (stateLock) &#123;</span><br><span class=\"line\">        localAddress = Net.localAddress(fd);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> SocketChannel <span class=\"title\">accept</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (lock) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//...</span></span><br><span class=\"line\">      SocketChannel sc = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">//connection fd，用于socket读写</span></span><br><span class=\"line\">      FileDescriptor newfd = <span class=\"keyword\">new</span> FileDescriptor();</span><br><span class=\"line\">      <span class=\"comment\">//客户端地址</span></span><br><span class=\"line\">      InetSocketAddress[] isaa = <span class=\"keyword\">new</span> InetSocketAddress[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        begin();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isOpen())</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        thread = NativeThread.current();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">          n = accept(<span class=\"keyword\">this</span>.fd, newfd, isaa);</span><br><span class=\"line\">          <span class=\"comment\">//遇到EINTR，忽略且继续监听</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen())</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        thread = <span class=\"number\">0</span>;</span><br><span class=\"line\">        end(n &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span> IOStatus.check(n);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">//默认connection fd阻塞，后面需要非阻塞读写则重新设为O_NONBLOCK</span></span><br><span class=\"line\">      IOUtil.configureBlocking(newfd, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">      InetSocketAddress isa = isaa[<span class=\"number\">0</span>];</span><br><span class=\"line\">      sc = <span class=\"keyword\">new</span> SocketChannelImpl(provider(), newfd, isa);</span><br><span class=\"line\">      SecurityManager sm = System.getSecurityManager();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (sm != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Net.c算是把Linux的socket编程都写了一遍了，部分是ipv6&amp;udp的设置，我个人不是很了解。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  Net.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">JNIEXPORT jint JNICALL</span><br><span class=\"line\">Java_sun_nio_ch_Net_socket0(JNIEnv *env, jclass cl, jboolean preferIPv6,</span><br><span class=\"line\">                            jboolean stream, jboolean reuse, jboolean ignored)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> type = (stream ? SOCK_STREAM : SOCK_DGRAM);</span><br><span class=\"line\">  <span class=\"comment\">//参数参考上述内容</span></span><br><span class=\"line\">  fd = socket(domain, type, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> handleSocketError(env, errno);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//默认ipv4与ipv6能监听同一端口</span></span><br><span class=\"line\">  setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//如果是UDP协议（以下省略部分代码，可以阅读openjdk9的完整代码）</span></span><br><span class=\"line\">  <span class=\"comment\">//不支持IP_MULTICAST_ALL，这个是linux2.6的非标准选项，被人喷了一脸血</span></span><br><span class=\"line\">  <span class=\"comment\">//int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;</span></span><br><span class=\"line\">  setsockopt(fd, level, IP_MULTICAST_ALL, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\">  <span class=\"comment\">//支持IPv6组播</span></span><br><span class=\"line\">  setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, &amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//server是允许reuseadd的，client不允许</span></span><br><span class=\"line\">  setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (<span class=\"keyword\">char</span>*)&amp;arg, <span class=\"keyword\">sizeof</span>(arg));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * ServerSocketChannelImpl.c</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> JNIEXPORT jint JNICALL</span><br><span class=\"line\"> Java_sun_nio_ch_ServerSocketChannelImpl_accept0(JNIEnv *env, jobject <span class=\"keyword\">this</span>,</span><br><span class=\"line\">                                                 jobject ssfdo, jobject newfdo,</span><br><span class=\"line\">                                                 jobjectArray isaa)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">   <span class=\"comment\">//...</span></span><br><span class=\"line\">   <span class=\"comment\">//出现ECONNABORTED则忽略，继续accept，用户代码不需要对RST做出处理。</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">socklen_t</span> sa_len = alloc_len;</span><br><span class=\"line\">     newfd = accept(ssfd, sa, &amp;sa_len);</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (newfd &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno != ECONNABORTED) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (newfd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">free</span>((<span class=\"keyword\">void</span> *)sa);</span><br><span class=\"line\">     <span class=\"comment\">//IOS_** 同等IOStatus.java中的常量</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> IOS_UNAVAILABLE;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">       <span class=\"keyword\">return</span> IOS_INTERRUPTED;</span><br><span class=\"line\">     JNU_ThrowIOExceptionWithLastError(env, <span class=\"string\">\"Accept failed\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">return</span> IOS_THROWN;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">//...</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端的连接就很简单了，并不难，方法看似很长重点也就那么几行，JNI的代码就不贴了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">connect</span><span class=\"params\">(SocketAddress sa)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    InetAddress ia = isa.getAddress();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ia.isAnyLocalAddress())</span><br><span class=\"line\">      ia = InetAddress.getLocalHost();</span><br><span class=\"line\">    n = Net.connect(fd,</span><br><span class=\"line\">                    ia,</span><br><span class=\"line\">                    isa.getPort());</span><br><span class=\"line\">    <span class=\"comment\">//同样忽略RST错误</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((n == IOStatus.INTERRUPTED)</span><br><span class=\"line\">          &amp;&amp; isOpen())</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"文件IO\"><a href=\"#文件IO\" class=\"headerlink\" title=\"文件IO\"></a>文件IO</h4><p>留个位置</p>\n<h4 id=\"ByteBuffer体系\"><a href=\"#ByteBuffer体系\" class=\"headerlink\" title=\"ByteBuffer体系\"></a>ByteBuffer体系</h4><p>从继承关系来看，其实并不复杂，数据结构也很简单，但对于<code>malloc</code>和<code>allocateDirect</code>分配的空间在进程虚拟内存所处的位置却很值得拿出来探讨一番，因为涉及NIO是否真实现了<code>零拷贝</code>。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/ByteBuffer.png\" alt=\"ByteBuffer\"></p>\n<h5 id=\"Buffer的指针\"><a href=\"#Buffer的指针\" class=\"headerlink\" title=\"Buffer的指针\"></a>Buffer的指针</h5><p>就是个对数组操作的容器，内部的指针也很容易理解，直接上图上源码，不多做解释。</p>\n<p><img src=\"https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/bytebuffer%E6%8C%87%E9%92%88.png\" alt=\"Buffer的指针\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Buffer</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//标记读取or写入位置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"comment\">//已读已写的位置</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> position = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//最大极限</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> limit;</span><br><span class=\"line\">  <span class=\"comment\">//容器容量</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">  <span class=\"comment\">//重设位置</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">position</span><span class=\"params\">(<span class=\"keyword\">int</span> newPosition)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((newPosition &gt; limit) || (newPosition &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    position = newPosition;</span><br><span class=\"line\">    <span class=\"comment\">//标记位超过新位置，重置为-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mark &gt; position) mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//与position(int)方法同理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Buffer <span class=\"title\">limit</span><span class=\"params\">(<span class=\"keyword\">int</span> newLimit)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((newLimit &gt; capacity) || (newLimit &lt; <span class=\"number\">0</span>))</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    limit = newLimit;</span><br><span class=\"line\">    <span class=\"comment\">//如果位置超出新限制，则重合pos和limit</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (position &gt; limit) position = limit;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mark &gt; limit) mark = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ByteBuffer\"><a href=\"#ByteBuffer\" class=\"headerlink\" title=\"ByteBuffer\"></a>ByteBuffer</h4><p>都是一些读读写写的操作，不做讲述了。</p>\n<h4 id=\"HeapByteBuffer\"><a href=\"#HeapByteBuffer\" class=\"headerlink\" title=\"HeapByteBuffer\"></a>HeapByteBuffer</h4><p>其实就是个byte[]，这个确实没什么好讲的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeapByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">ByteBuffer</span> </span>&#123;</span><br><span class=\"line\">  HeapByteBuffer(<span class=\"keyword\">int</span> cap, <span class=\"keyword\">int</span> lim) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, lim, cap, <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[cap], <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"DirectByteBuffer\"><a href=\"#DirectByteBuffer\" class=\"headerlink\" title=\"DirectByteBuffer\"></a>DirectByteBuffer</h4><p>正如类名所示direct，分配了java heap以外的「直接」内存，空间大小由JVM参数<code>-XX:MaxDirectMemorySize</code>控制，默认64m。我一开始认为jvm应该会根据这个参数在进程里面分配相对于的vm_area_struct，与heap相似的管理方式。直到我看到下面<code>DirectByteBuffer</code>的构造方法，吃了一鲸，并不是我想象中那样，而是DirectMemory分配的控制是交给java控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DirectByteBuffer</span> <span class=\"keyword\">extends</span> <span class=\"title\">MappedByteBuffer</span> <span class=\"keyword\">implements</span> <span class=\"title\">DirectBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(-<span class=\"number\">1</span>, <span class=\"number\">0</span>, cap, cap);</span><br><span class=\"line\">    <span class=\"comment\">//是否对齐页面，一般设置为false，-XX:+PageAlignDirectMemory控制</span></span><br><span class=\"line\">    <span class=\"comment\">//如果对齐，最后的address是个页面上边框的地址，有利于页面查找效率</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ps = Bits.pageSize();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> size = Math.max(<span class=\"number\">1L</span>, (<span class=\"keyword\">long</span>)cap + (pa ? ps : <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//这里会尝试分配空间，假如空间不足会执行Cleaner做清理后再次尝试分配</span></span><br><span class=\"line\">    <span class=\"comment\">//上面失败后，会进入自旋9次，若成功则返回，失败抛出OOM</span></span><br><span class=\"line\">    <span class=\"comment\">//关于这个方法可以参考JVM大佬寒泉子的http://lovestblog.cn/blog/2015/05/12/direct-buffer/</span></span><br><span class=\"line\">    Bits.reserveMemory(size, cap);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> base = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//看JNI代码可以看到jvm声明了自己的方法os::malloc进行内存分配</span></span><br><span class=\"line\">      base = unsafe.allocateMemory(size);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (OutOfMemoryError x) &#123;</span><br><span class=\"line\">      Bits.unreserveMemory(size, cap);</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//将内存全部置零</span></span><br><span class=\"line\">    unsafe.setMemory(base, size, (<span class=\"keyword\">byte</span>) <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pa &amp;&amp; (base % ps != <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Round up to page boundary</span></span><br><span class=\"line\">      address = base + ps - (base &amp; (ps - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      address = base;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cleaner = Cleaner.create(<span class=\"keyword\">this</span>, <span class=\"keyword\">new</span> Deallocator(base, size, cap));</span><br><span class=\"line\">    att = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个地方我一直很让我纠结，这个「直接」内存是分配在进程的堆区还是在映射区（忽略malloc()大于128k使用mmap()），自己又实在不想浪费心力过分研读JVM源码。如果正用了malloc，DirectByteBuffer并非所谓实现Linux零拷贝。</p>\n<p>如果是在进程堆区，最后还是要拷贝至内核空间，参考FileChannel的map()，JNI毫不吝啬直接调用mmap()，所以看到os::malloc我很疑惑是否仅仅直接交给glibc进行内存分配。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class=\"line\">  UnsafeWrapper(<span class=\"string\">\"Unsafe_AllocateMemory\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> sz = (<span class=\"keyword\">size_t</span>)size;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sz == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sz = round_to(sz, HeapWordSize);</span><br><span class=\"line\">  <span class=\"keyword\">void</span>* x = os::<span class=\"built_in\">malloc</span>(sz, mtInternal);</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"comment\">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr_to_java(x);</span><br><span class=\"line\">UNSAFE_END</span><br></pre></td></tr></table></figure>"},{"title":"【Java并发】new Thread时JVM发生了什么？","date":"2019-12-16T03:48:28.000Z","_content":"\n最近兴致勃勃捡起C++，打算深入Unix网络编程，但输出博客想从比较简单的问题入手，所以对标一下Java与C的线程创建过程，加深一下理解。（注，Linux）\n\n---\n\nJava创建线程是简单的，`new Thread()`和`start()`即可启动并执行线程，但由于posix提供的api还涉及不少线程属性，真实过程显然要复杂得多。可以看到前者`new Thread`只是初始化属性，后者才是真正意义上调用本地接口`JVM_StartThread`，创建线程。\n\n``` c++\n//以下函数指针均被定义在jvm.h，实现在jvm.cpp\nstatic JNINativeMethod methods[] = {\n    {\"start0\",           \"()V\",        (void *)&JVM_StartThread},\n    {\"stop0\",            \"(\" OBJ \")V\", (void *)&JVM_StopThread},\n    {\"isAlive\",          \"()Z\",        (void *)&JVM_IsThreadAlive},\n    {\"suspend0\",         \"()V\",        (void *)&JVM_SuspendThread},\n    {\"resume0\",          \"()V\",        (void *)&JVM_ResumeThread},\n    {\"setPriority0\",     \"(I)V\",       (void *)&JVM_SetThreadPriority},\n    {\"yield\",            \"()V\",        (void *)&JVM_Yield},\n    {\"sleep\",            \"(J)V\",       (void *)&JVM_Sleep},\n    {\"currentThread\",    \"()\" THD,     (void *)&JVM_CurrentThread},\n    {\"countStackFrames\", \"()I\",        (void *)&JVM_CountStackFrames},\n    {\"interrupt0\",       \"()V\",        (void *)&JVM_Interrupt},\n    {\"isInterrupted\",    \"(Z)Z\",       (void *)&JVM_IsInterrupted},\n    {\"holdsLock\",        \"(\" OBJ \")Z\", (void *)&JVM_HoldsLock},\n    {\"getThreads\",        \"()[\" THD,   (void *)&JVM_GetAllThreads},\n    {\"dumpThreads\",      \"([\" THD \")[[\" STE, (void *)&JVM_DumpThreads},\n    {\"setNativeName\",    \"(\" STR \")V\", (void *)&JVM_SetNativeThreadName},\n};\n```\n\n阅读相关JVM源码时，需要知道几个重要类的关系，下面部分实现默认os_linux.cpp。\n```\n1、JavaThread: 创建线程执行任务，持有java_lang_thread & OSThread对象，维护线程状态运行Thread.run()的地方\n2、OSThread: 由于不同操作系统的状态不一致，所以JVM维护了一套平台线程状态，被JavaThread所持有\n3、java_lang_Thread::ThreadStatus: 即Java线程状态，与java.lang.Thread.State完全一致\n4、OSThread::ThreadState: 2所说的平台线程状态\n```\n\n需要说的是，以下相关pthread函数均是posix标准，可自行阅读<pthread.h>文档，不多赘述。\n``` c++\nJVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))\n  JVMWrapper(\"JVM_StartThread\");\n  JavaThread *native_thread = NULL;\n\n  bool throw_illegal_thread_state = false;\n\n  //这里一对花括号代表一段程序，执行完后回释放资源，会调用~MutexLocker(Monitor * monitor)释放互斥锁 (注，~代表析构函数)\n  {\n    //获取互斥锁，加上诉说明，等同于synchronized代码块\n    //这里的独占锁依然使用了pthread_mutex_lock函数\n    //具体实现在os_posix.cpp的PlatformEvent.park & unpark函数\n    MutexLocker mu(Threads_lock);\n\n    //这里检查Thread.java的long eetop变量是否有值，避免重复启动线程，该值为JavaThread的地址\n    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {\n      throw_illegal_thread_state = true;\n    } else {\n      //实例化Thread时，可以设置stackSize，用于初始化虚拟地址栈空间\n      jlong size =\n             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));\n\n      NOT_LP64(if (size > SIZE_MAX) size = SIZE_MAX;)\n      size_t sz = size > 0 ? (size_t) size : 0;\n      //这里正式调用pthread_create创建线程\n      native_thread = new JavaThread(&thread_entry, sz);\n\n      //可能因为内存不足，无法为OSThread分配空间，所以可能为NULL\n      if (native_thread->osthread() != NULL) {\n        //上面提到的eetop，将在这里被设置\n        native_thread->prepare(jthread);\n      }\n    }\n  }\n\n  if (throw_illegal_thread_state) {\n    THROW(vmSymbols::java_lang_IllegalThreadStateException());\n  }\n\n  assert(native_thread != NULL, \"Starting null thread?\");\n\n  if (native_thread->osthread() == NULL) {\n    // 安全内存回收(SMR)\n    native_thread->smr_delete();\n    if (JvmtiExport::should_post_resource_exhausted()) {\n      JvmtiExport::post_resource_exhausted(\n        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,\n        os::native_thread_creation_failed_msg());\n    }\n    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),\n              os::native_thread_creation_failed_msg());\n  }\n  //哦吼！这是线程真正的开始\n  Thread::start(native_thread);\n\nJVM_END\n```\n\n我们知道`pthread_create`创建线程后立刻执行线程，所以什么`Thread::start`才是真正启动线程，我们需要进一步窥探。\n``` c++\n//JavaThread类定义在thread.hpp中，为Thread的子类\nJavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :\n                       Thread() {\n  //初始化字段，最重要的是创建线程安全点，作用在垃圾回收时的STW\n  initialize();\n  _jni_attach_state = _not_attaching_via_jni;\n  set_entry_point(entry_point);\n  //yep，线程类型有gc、编译、守护、平台等几种\n  os::ThreadType thr_type = os::java_thread;\n  thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :\n                                                     os::java_thread;\n  os::create_thread(this, thr_type, stack_sz);\n  //这段话我没懂，有大佬明白可以交流下\n  // The _osthread may be NULL here because we ran out of memory (too many threads active).\n  // We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n  // may hold a lock and all locks must be unlocked before throwing the exception (throwing\n  // the exception consists of creating the exception object & initializing it, initialization\n  // will leave the VM via a JavaCall and then all locks must be unlocked).\n  //\n  // The thread is still suspended when we reach here. Thread must be explicit started\n  // by creator! Furthermore, the thread must also explicitly be added to the Threads list\n  // by calling Threads:add. The reason why this is not done here, is because the thread\n  // object must be fully initialized (take a look at JVM_Start)\n}\n```\n\n`create_thread`对线程属性的设置跟日常写c++时有些不同，包括警戒线缓冲区和页面对其，一般我们并不会考虑aligned。\n``` c++\n//os_linux.cpp\n\nbool os::create_thread(Thread* thread, ThreadType thr_type,\n                       size_t req_stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object (<_<)可能空指针\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // java_thread\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  // 所以java线程都是分离状态，join也并非用结合状态\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // -Xss默认1M，Thread没设置stackSize，在Linux-x86默认512K，取最大值\n  size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);\n  //这里设置栈警戒缓冲区，默认系统页大小\n  //原注解的意思是，Linux的NPTL没有完全按照posix标准\n  //理应guard_size + stack_size，且二者大小相等，而不是从stack_size取guard_size作为警戒取\n  //所以这里模仿实现posix标准\n  size_t guard_size = os::Linux::default_guard_size(thr_type);\n  if (stack_size <= SIZE_MAX - guard_size) {\n    stack_size += guard_size;\n  }\n  assert(is_aligned(stack_size, os::vm_page_size()), \"stack_size not aligned\");\n\n  int status = pthread_attr_setstacksize(&attr, stack_size);\n  assert_status(status == 0, status, \"pthread_attr_setstacksize\");\n\n  pthread_attr_setguardsize(&attr, os::Linux::default_guard_size(thr_type));\n\n  ThreadState state;\n\n  {\n    //欧了，创建线程，函数指针thread_native_entry是重点\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n    \n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // 等待thread_native_entry设置osthread为INITIALIZED，或收到终止信号\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n  }\n    // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n    thread->set_osthread(NULL);\n    delete osthread;\n    return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n```\n\n由于`pthread_create`会立即执行`thread_native_entry`，但又因为JavaThread被OSThread管理着，所以需要加各种排斥锁，达到二者状态同步的效果。\n``` c++\nstatic void *thread_native_entry(Thread *thread) {\n\n  thread->record_stack_base_and_size();\n  //我没理解这里的左右，有CPU大佬请解答\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n  //声明类似ThreadLocal的pthread_key_t\n  thread->initialize_thread_current();\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  osthread->set_thread_id(os::current_thread_id());\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n  // 屏蔽来自VM的阻塞信号\n  os::Linux::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread() <<<------  自璇中，等待调用Thread::start()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  assert(osthread->pthread_id() != 0, \"pthread_id was not set as expected\");\n\n  // call one more level start routine\n  thread->call_run(); // <--- 里面调用JavaThread::run()\n\n  // Note: at this point the thread object may already have deleted itself.\n  // Prevent dereferencing it from here on out.\n  thread = NULL;\n\n  return 0;\n}\n```\n\n执行Runable之前，JVM需要给java线程分配本地缓冲区等操作(这是一个大块)，这里算是到头了。\n``` c++\nvoid JavaThread::run() {\n  // 初始化TLAB，即在年轻代割一点空间给自己，具体大小-XX:UseTLAB设置\n  this->initialize_tlab();\n\n  //不知道干嘛的，在linux_x86是空实现\n  this->record_base_of_stack_pointer();\n\n  this->create_stack_guard_pages();\n\n  this->cache_global_variables();\n\n  // Thread is now sufficiently initialized to be handled by the safepoint code as being\n  // in the VM. Change thread state from _thread_new to _thread_in_vm\n  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);\n\n  assert(JavaThread::current() == this, \"sanity check\");\n  assert(!Thread::current()->owns_locks(), \"sanity check\");\n\n  DTRACE_THREAD_PROBE(start, this);\n\n  this->set_active_handles(JNIHandleBlock::allocate_block());\n\n  if (JvmtiExport::should_post_thread_life()) {\n    JvmtiExport::post_thread_start(this);\n\n  }\n  //这里才是真正调用java.lang.Thread#run()方法，执行Runable\n  // We call another function to do the rest so we are sure that the stack addresses used\n  // from there will be lower than the stack base just computed.\n  thread_main_inner();\n}\n```\n\n下面代码不多做解释了，`this->entry_point()(this, this)` 等同于调用函数`thread_entry`，`JavaCalls`也是个大块，复杂调用java方法。\n``` c++\nvoid JavaThread::thread_main_inner() {\n  assert(JavaThread::current() == this, \"sanity check\");\n  assert(this->threadObj() != NULL, \"just checking\");\n\n  // Execute thread entry point unless this thread has a pending exception\n  // or has been stopped before starting.\n  // Note: Due to JVM_StopThread we can have pending exceptions already!\n  if (!this->has_pending_exception() &&\n      !java_lang_Thread::is_stillborn(this->threadObj())) {\n    {\n      ResourceMark rm(this);\n      this->set_native_thread_name(this->get_thread_name());\n    }\n    HandleMark hm(this);\n    this->entry_point()(this, this);\n  }\n\n  DTRACE_THREAD_PROBE(stop, this);\n\n  // Cleanup is handled in post_run()\n}\n\nstatic void thread_entry(JavaThread* thread, TRAPS) {\n  HandleMark hm(THREAD);\n  Handle obj(THREAD, thread->threadObj());\n  JavaValue result(T_VOID);\n  JavaCalls::call_virtual(&result,\n                          obj,\n                          SystemDictionary::Thread_klass(),\n                          vmSymbols::run_method_name(),\n                          vmSymbols::void_method_signature(),\n                          THREAD);\n}\n```\n\n总体来说，创建一个线程对于JVM来说还是相对费劲的，不是说性能不好，是需要做太多事。与GC息息相关的两个点就是TLAB与ThreadSafePoint，其他则是对于java程序员透明的栈空间的分配(这里指的是虚拟内存地址)、线程状态管理。","source":"_posts/20191216-【并发编程】new-Thread时JVM做了什么？.md","raw":"---\ntitle: 【Java并发】new Thread时JVM发生了什么？\ndate: 2019-12-16 11:48:28\ntags:\n  - java\n  - C++\n  - Thread\n  - Linux编程\n  - 并发编程\ncategories:\n    - java并发编程\n---\n\n最近兴致勃勃捡起C++，打算深入Unix网络编程，但输出博客想从比较简单的问题入手，所以对标一下Java与C的线程创建过程，加深一下理解。（注，Linux）\n\n---\n\nJava创建线程是简单的，`new Thread()`和`start()`即可启动并执行线程，但由于posix提供的api还涉及不少线程属性，真实过程显然要复杂得多。可以看到前者`new Thread`只是初始化属性，后者才是真正意义上调用本地接口`JVM_StartThread`，创建线程。\n\n``` c++\n//以下函数指针均被定义在jvm.h，实现在jvm.cpp\nstatic JNINativeMethod methods[] = {\n    {\"start0\",           \"()V\",        (void *)&JVM_StartThread},\n    {\"stop0\",            \"(\" OBJ \")V\", (void *)&JVM_StopThread},\n    {\"isAlive\",          \"()Z\",        (void *)&JVM_IsThreadAlive},\n    {\"suspend0\",         \"()V\",        (void *)&JVM_SuspendThread},\n    {\"resume0\",          \"()V\",        (void *)&JVM_ResumeThread},\n    {\"setPriority0\",     \"(I)V\",       (void *)&JVM_SetThreadPriority},\n    {\"yield\",            \"()V\",        (void *)&JVM_Yield},\n    {\"sleep\",            \"(J)V\",       (void *)&JVM_Sleep},\n    {\"currentThread\",    \"()\" THD,     (void *)&JVM_CurrentThread},\n    {\"countStackFrames\", \"()I\",        (void *)&JVM_CountStackFrames},\n    {\"interrupt0\",       \"()V\",        (void *)&JVM_Interrupt},\n    {\"isInterrupted\",    \"(Z)Z\",       (void *)&JVM_IsInterrupted},\n    {\"holdsLock\",        \"(\" OBJ \")Z\", (void *)&JVM_HoldsLock},\n    {\"getThreads\",        \"()[\" THD,   (void *)&JVM_GetAllThreads},\n    {\"dumpThreads\",      \"([\" THD \")[[\" STE, (void *)&JVM_DumpThreads},\n    {\"setNativeName\",    \"(\" STR \")V\", (void *)&JVM_SetNativeThreadName},\n};\n```\n\n阅读相关JVM源码时，需要知道几个重要类的关系，下面部分实现默认os_linux.cpp。\n```\n1、JavaThread: 创建线程执行任务，持有java_lang_thread & OSThread对象，维护线程状态运行Thread.run()的地方\n2、OSThread: 由于不同操作系统的状态不一致，所以JVM维护了一套平台线程状态，被JavaThread所持有\n3、java_lang_Thread::ThreadStatus: 即Java线程状态，与java.lang.Thread.State完全一致\n4、OSThread::ThreadState: 2所说的平台线程状态\n```\n\n需要说的是，以下相关pthread函数均是posix标准，可自行阅读<pthread.h>文档，不多赘述。\n``` c++\nJVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))\n  JVMWrapper(\"JVM_StartThread\");\n  JavaThread *native_thread = NULL;\n\n  bool throw_illegal_thread_state = false;\n\n  //这里一对花括号代表一段程序，执行完后回释放资源，会调用~MutexLocker(Monitor * monitor)释放互斥锁 (注，~代表析构函数)\n  {\n    //获取互斥锁，加上诉说明，等同于synchronized代码块\n    //这里的独占锁依然使用了pthread_mutex_lock函数\n    //具体实现在os_posix.cpp的PlatformEvent.park & unpark函数\n    MutexLocker mu(Threads_lock);\n\n    //这里检查Thread.java的long eetop变量是否有值，避免重复启动线程，该值为JavaThread的地址\n    if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {\n      throw_illegal_thread_state = true;\n    } else {\n      //实例化Thread时，可以设置stackSize，用于初始化虚拟地址栈空间\n      jlong size =\n             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));\n\n      NOT_LP64(if (size > SIZE_MAX) size = SIZE_MAX;)\n      size_t sz = size > 0 ? (size_t) size : 0;\n      //这里正式调用pthread_create创建线程\n      native_thread = new JavaThread(&thread_entry, sz);\n\n      //可能因为内存不足，无法为OSThread分配空间，所以可能为NULL\n      if (native_thread->osthread() != NULL) {\n        //上面提到的eetop，将在这里被设置\n        native_thread->prepare(jthread);\n      }\n    }\n  }\n\n  if (throw_illegal_thread_state) {\n    THROW(vmSymbols::java_lang_IllegalThreadStateException());\n  }\n\n  assert(native_thread != NULL, \"Starting null thread?\");\n\n  if (native_thread->osthread() == NULL) {\n    // 安全内存回收(SMR)\n    native_thread->smr_delete();\n    if (JvmtiExport::should_post_resource_exhausted()) {\n      JvmtiExport::post_resource_exhausted(\n        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,\n        os::native_thread_creation_failed_msg());\n    }\n    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),\n              os::native_thread_creation_failed_msg());\n  }\n  //哦吼！这是线程真正的开始\n  Thread::start(native_thread);\n\nJVM_END\n```\n\n我们知道`pthread_create`创建线程后立刻执行线程，所以什么`Thread::start`才是真正启动线程，我们需要进一步窥探。\n``` c++\n//JavaThread类定义在thread.hpp中，为Thread的子类\nJavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :\n                       Thread() {\n  //初始化字段，最重要的是创建线程安全点，作用在垃圾回收时的STW\n  initialize();\n  _jni_attach_state = _not_attaching_via_jni;\n  set_entry_point(entry_point);\n  //yep，线程类型有gc、编译、守护、平台等几种\n  os::ThreadType thr_type = os::java_thread;\n  thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :\n                                                     os::java_thread;\n  os::create_thread(this, thr_type, stack_sz);\n  //这段话我没懂，有大佬明白可以交流下\n  // The _osthread may be NULL here because we ran out of memory (too many threads active).\n  // We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n  // may hold a lock and all locks must be unlocked before throwing the exception (throwing\n  // the exception consists of creating the exception object & initializing it, initialization\n  // will leave the VM via a JavaCall and then all locks must be unlocked).\n  //\n  // The thread is still suspended when we reach here. Thread must be explicit started\n  // by creator! Furthermore, the thread must also explicitly be added to the Threads list\n  // by calling Threads:add. The reason why this is not done here, is because the thread\n  // object must be fully initialized (take a look at JVM_Start)\n}\n```\n\n`create_thread`对线程属性的设置跟日常写c++时有些不同，包括警戒线缓冲区和页面对其，一般我们并不会考虑aligned。\n``` c++\n//os_linux.cpp\n\nbool os::create_thread(Thread* thread, ThreadType thr_type,\n                       size_t req_stack_size) {\n  assert(thread->osthread() == NULL, \"caller responsible\");\n\n  // Allocate the OSThread object (<_<)可能空指针\n  OSThread* osthread = new OSThread(NULL, NULL);\n  if (osthread == NULL) {\n    return false;\n  }\n\n  // java_thread\n  osthread->set_thread_type(thr_type);\n\n  // Initial state is ALLOCATED but not INITIALIZED\n  osthread->set_state(ALLOCATED);\n\n  thread->set_osthread(osthread);\n\n  pthread_attr_t attr;\n  pthread_attr_init(&attr);\n  // 所以java线程都是分离状态，join也并非用结合状态\n  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n  // -Xss默认1M，Thread没设置stackSize，在Linux-x86默认512K，取最大值\n  size_t stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);\n  //这里设置栈警戒缓冲区，默认系统页大小\n  //原注解的意思是，Linux的NPTL没有完全按照posix标准\n  //理应guard_size + stack_size，且二者大小相等，而不是从stack_size取guard_size作为警戒取\n  //所以这里模仿实现posix标准\n  size_t guard_size = os::Linux::default_guard_size(thr_type);\n  if (stack_size <= SIZE_MAX - guard_size) {\n    stack_size += guard_size;\n  }\n  assert(is_aligned(stack_size, os::vm_page_size()), \"stack_size not aligned\");\n\n  int status = pthread_attr_setstacksize(&attr, stack_size);\n  assert_status(status == 0, status, \"pthread_attr_setstacksize\");\n\n  pthread_attr_setguardsize(&attr, os::Linux::default_guard_size(thr_type));\n\n  ThreadState state;\n\n  {\n    //欧了，创建线程，函数指针thread_native_entry是重点\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n    \n    pthread_attr_destroy(&attr);\n\n    if (ret != 0) {\n      // Need to clean up stuff we've allocated so far\n      thread->set_osthread(NULL);\n      delete osthread;\n      return false;\n    }\n\n    // Store pthread info into the OSThread\n    osthread->set_pthread_id(tid);\n\n    // 等待thread_native_entry设置osthread为INITIALIZED，或收到终止信号\n    {\n      Monitor* sync_with_child = osthread->startThread_lock();\n      MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag);\n      while ((state = osthread->get_state()) == ALLOCATED) {\n        sync_with_child->wait(Mutex::_no_safepoint_check_flag);\n      }\n    }\n  }\n    // Aborted due to thread limit being reached\n  if (state == ZOMBIE) {\n    thread->set_osthread(NULL);\n    delete osthread;\n    return false;\n  }\n\n  // The thread is returned suspended (in state INITIALIZED),\n  // and is started higher up in the call chain\n  assert(state == INITIALIZED, \"race condition\");\n  return true;\n}\n```\n\n由于`pthread_create`会立即执行`thread_native_entry`，但又因为JavaThread被OSThread管理着，所以需要加各种排斥锁，达到二者状态同步的效果。\n``` c++\nstatic void *thread_native_entry(Thread *thread) {\n\n  thread->record_stack_base_and_size();\n  //我没理解这里的左右，有CPU大佬请解答\n  // Try to randomize the cache line index of hot stack frames.\n  // This helps when threads of the same stack traces evict each other's\n  // cache lines. The threads can be either from the same JVM instance, or\n  // from different JVM instances. The benefit is especially true for\n  // processors with hyperthreading technology.\n  static int counter = 0;\n  int pid = os::current_process_id();\n  alloca(((pid ^ counter++) & 7) * 128);\n  //声明类似ThreadLocal的pthread_key_t\n  thread->initialize_thread_current();\n\n  OSThread* osthread = thread->osthread();\n  Monitor* sync = osthread->startThread_lock();\n\n  osthread->set_thread_id(os::current_thread_id());\n\n  if (UseNUMA) {\n    int lgrp_id = os::numa_get_group_id();\n    if (lgrp_id != -1) {\n      thread->set_lgrp_id(lgrp_id);\n    }\n  }\n  // 屏蔽来自VM的阻塞信号\n  os::Linux::hotspot_sigmask(thread);\n\n  // initialize floating point control register\n  os::Linux::init_thread_fpu_state();\n\n  {\n    MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag);\n\n    // notify parent thread\n    osthread->set_state(INITIALIZED);\n    sync->notify_all();\n\n    // wait until os::start_thread() <<<------  自璇中，等待调用Thread::start()\n    while (osthread->get_state() == INITIALIZED) {\n      sync->wait(Mutex::_no_safepoint_check_flag);\n    }\n  }\n\n  assert(osthread->pthread_id() != 0, \"pthread_id was not set as expected\");\n\n  // call one more level start routine\n  thread->call_run(); // <--- 里面调用JavaThread::run()\n\n  // Note: at this point the thread object may already have deleted itself.\n  // Prevent dereferencing it from here on out.\n  thread = NULL;\n\n  return 0;\n}\n```\n\n执行Runable之前，JVM需要给java线程分配本地缓冲区等操作(这是一个大块)，这里算是到头了。\n``` c++\nvoid JavaThread::run() {\n  // 初始化TLAB，即在年轻代割一点空间给自己，具体大小-XX:UseTLAB设置\n  this->initialize_tlab();\n\n  //不知道干嘛的，在linux_x86是空实现\n  this->record_base_of_stack_pointer();\n\n  this->create_stack_guard_pages();\n\n  this->cache_global_variables();\n\n  // Thread is now sufficiently initialized to be handled by the safepoint code as being\n  // in the VM. Change thread state from _thread_new to _thread_in_vm\n  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);\n\n  assert(JavaThread::current() == this, \"sanity check\");\n  assert(!Thread::current()->owns_locks(), \"sanity check\");\n\n  DTRACE_THREAD_PROBE(start, this);\n\n  this->set_active_handles(JNIHandleBlock::allocate_block());\n\n  if (JvmtiExport::should_post_thread_life()) {\n    JvmtiExport::post_thread_start(this);\n\n  }\n  //这里才是真正调用java.lang.Thread#run()方法，执行Runable\n  // We call another function to do the rest so we are sure that the stack addresses used\n  // from there will be lower than the stack base just computed.\n  thread_main_inner();\n}\n```\n\n下面代码不多做解释了，`this->entry_point()(this, this)` 等同于调用函数`thread_entry`，`JavaCalls`也是个大块，复杂调用java方法。\n``` c++\nvoid JavaThread::thread_main_inner() {\n  assert(JavaThread::current() == this, \"sanity check\");\n  assert(this->threadObj() != NULL, \"just checking\");\n\n  // Execute thread entry point unless this thread has a pending exception\n  // or has been stopped before starting.\n  // Note: Due to JVM_StopThread we can have pending exceptions already!\n  if (!this->has_pending_exception() &&\n      !java_lang_Thread::is_stillborn(this->threadObj())) {\n    {\n      ResourceMark rm(this);\n      this->set_native_thread_name(this->get_thread_name());\n    }\n    HandleMark hm(this);\n    this->entry_point()(this, this);\n  }\n\n  DTRACE_THREAD_PROBE(stop, this);\n\n  // Cleanup is handled in post_run()\n}\n\nstatic void thread_entry(JavaThread* thread, TRAPS) {\n  HandleMark hm(THREAD);\n  Handle obj(THREAD, thread->threadObj());\n  JavaValue result(T_VOID);\n  JavaCalls::call_virtual(&result,\n                          obj,\n                          SystemDictionary::Thread_klass(),\n                          vmSymbols::run_method_name(),\n                          vmSymbols::void_method_signature(),\n                          THREAD);\n}\n```\n\n总体来说，创建一个线程对于JVM来说还是相对费劲的，不是说性能不好，是需要做太多事。与GC息息相关的两个点就是TLAB与ThreadSafePoint，其他则是对于java程序员透明的栈空间的分配(这里指的是虚拟内存地址)、线程状态管理。","slug":"20191216-【并发编程】new-Thread时JVM做了什么？","published":1,"updated":"2019-12-18T12:42:39.599Z","_id":"ck4b9g7t700384ejdd7180z15","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近兴致勃勃捡起C++，打算深入Unix网络编程，但输出博客想从比较简单的问题入手，所以对标一下Java与C的线程创建过程，加深一下理解。（注，Linux）</p>\n<hr>\n<p>Java创建线程是简单的，<code>new Thread()</code>和<code>start()</code>即可启动并执行线程，但由于posix提供的api还涉及不少线程属性，真实过程显然要复杂得多。可以看到前者<code>new Thread</code>只是初始化属性，后者才是真正意义上调用本地接口<code>JVM_StartThread</code>，创建线程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下函数指针均被定义在jvm.h，实现在jvm.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod methods[] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">\"start0\"</span>,           <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"stop0\"</span>,            <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\")V\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"isAlive\"</span>,          <span class=\"string\">\"()Z\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"suspend0\"</span>,         <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"resume0\"</span>,          <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"setPriority0\"</span>,     <span class=\"string\">\"(I)V\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"yield\"</span>,            <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"sleep\"</span>,            <span class=\"string\">\"(J)V\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"currentThread\"</span>,    <span class=\"string\">\"()\"</span> THD,     (<span class=\"keyword\">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"countStackFrames\"</span>, <span class=\"string\">\"()I\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"interrupt0\"</span>,       <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"isInterrupted\"</span>,    <span class=\"string\">\"(Z)Z\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"holdsLock\"</span>,        <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\")Z\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"getThreads\"</span>,        <span class=\"string\">\"()[\"</span> THD,   (<span class=\"keyword\">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"dumpThreads\"</span>,      <span class=\"string\">\"([\"</span> THD <span class=\"string\">\")[[\"</span> STE, (<span class=\"keyword\">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"setNativeName\"</span>,    <span class=\"string\">\"(\"</span> STR <span class=\"string\">\")V\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>阅读相关JVM源码时，需要知道几个重要类的关系，下面部分实现默认os_linux.cpp。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、JavaThread: 创建线程执行任务，持有java_lang_thread &amp; OSThread对象，维护线程状态运行Thread.run()的地方</span><br><span class=\"line\">2、OSThread: 由于不同操作系统的状态不一致，所以JVM维护了一套平台线程状态，被JavaThread所持有</span><br><span class=\"line\">3、java_lang_Thread::ThreadStatus: 即Java线程状态，与java.lang.Thread.State完全一致</span><br><span class=\"line\">4、OSThread::ThreadState: 2所说的平台线程状态</span><br></pre></td></tr></table></figure>\n\n<p>需要说的是，以下相关pthread函数均是posix标准，可自行阅读&lt;pthread.h&gt;文档，不多赘述。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM_ENTRY(<span class=\"keyword\">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class=\"line\">  JVMWrapper(<span class=\"string\">\"JVM_StartThread\"</span>);</span><br><span class=\"line\">  JavaThread *native_thread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> throw_illegal_thread_state = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//这里一对花括号代表一段程序，执行完后回释放资源，会调用~MutexLocker(Monitor * monitor)释放互斥锁 (注，~代表析构函数)</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取互斥锁，加上诉说明，等同于synchronized代码块</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的独占锁依然使用了pthread_mutex_lock函数</span></span><br><span class=\"line\">    <span class=\"comment\">//具体实现在os_posix.cpp的PlatformEvent.park &amp; unpark函数</span></span><br><span class=\"line\">    <span class=\"function\">MutexLocker <span class=\"title\">mu</span><span class=\"params\">(Threads_lock)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里检查Thread.java的long eetop变量是否有值，避免重复启动线程，该值为JavaThread的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      throw_illegal_thread_state = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//实例化Thread时，可以设置stackSize，用于初始化虚拟地址栈空间</span></span><br><span class=\"line\">      jlong <span class=\"built_in\">size</span> =</span><br><span class=\"line\">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class=\"line\"></span><br><span class=\"line\">      NOT_LP64(<span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> &gt; SIZE_MAX) <span class=\"built_in\">size</span> = SIZE_MAX;)</span><br><span class=\"line\">      <span class=\"keyword\">size_t</span> sz = <span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span> ? (<span class=\"keyword\">size_t</span>) <span class=\"built_in\">size</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">//这里正式调用pthread_create创建线程</span></span><br><span class=\"line\">      native_thread = <span class=\"keyword\">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//可能因为内存不足，无法为OSThread分配空间，所以可能为NULL</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (native_thread-&gt;osthread() != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//上面提到的eetop，将在这里被设置</span></span><br><span class=\"line\">        native_thread-&gt;<span class=\"built_in\">prepare</span>(jthread);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throw_illegal_thread_state) &#123;</span><br><span class=\"line\">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(native_thread != <span class=\"literal\">NULL</span>, <span class=\"string\">\"Starting null thread?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (native_thread-&gt;osthread() == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全内存回收(SMR)</span></span><br><span class=\"line\">    native_thread-&gt;smr_delete();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class=\"line\">      JvmtiExport::post_resource_exhausted(</span><br><span class=\"line\">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class=\"line\">        os::native_thread_creation_failed_msg());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class=\"line\">              os::native_thread_creation_failed_msg());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//哦吼！这是线程真正的开始</span></span><br><span class=\"line\">  Thread::start(native_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">JVM_END</span><br></pre></td></tr></table></figure>\n\n<p>我们知道<code>pthread_create</code>创建线程后立刻执行线程，所以什么<code>Thread::start</code>才是真正启动线程，我们需要进一步窥探。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//JavaThread类定义在thread.hpp中，为Thread的子类</span></span><br><span class=\"line\">JavaThread::JavaThread(ThreadFunction entry_point, <span class=\"keyword\">size_t</span> stack_sz) :</span><br><span class=\"line\">                       Thread() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//初始化字段，最重要的是创建线程安全点，作用在垃圾回收时的STW</span></span><br><span class=\"line\">  initialize();</span><br><span class=\"line\">  _jni_attach_state = _not_attaching_via_jni;</span><br><span class=\"line\">  set_entry_point(entry_point);</span><br><span class=\"line\">  <span class=\"comment\">//yep，线程类型有gc、编译、守护、平台等几种</span></span><br><span class=\"line\">  os::ThreadType thr_type = os::java_thread;</span><br><span class=\"line\">  thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class=\"line\">                                                     os::java_thread;</span><br><span class=\"line\">  os::create_thread(<span class=\"keyword\">this</span>, thr_type, stack_sz);</span><br><span class=\"line\">  <span class=\"comment\">//这段话我没懂，有大佬明白可以交流下</span></span><br><span class=\"line\">  <span class=\"comment\">// The _osthread may be NULL here because we ran out of memory (too many threads active).</span></span><br><span class=\"line\">  <span class=\"comment\">// We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span></span><br><span class=\"line\">  <span class=\"comment\">// may hold a lock and all locks must be unlocked before throwing the exception (throwing</span></span><br><span class=\"line\">  <span class=\"comment\">// the exception consists of creating the exception object &amp; initializing it, initialization</span></span><br><span class=\"line\">  <span class=\"comment\">// will leave the VM via a JavaCall and then all locks must be unlocked).</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// The thread is still suspended when we reach here. Thread must be explicit started</span></span><br><span class=\"line\">  <span class=\"comment\">// by creator! Furthermore, the thread must also explicitly be added to the Threads list</span></span><br><span class=\"line\">  <span class=\"comment\">// by calling Threads:add. The reason why this is not done here, is because the thread</span></span><br><span class=\"line\">  <span class=\"comment\">// object must be fully initialized (take a look at JVM_Start)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>create_thread</code>对线程属性的设置跟日常写c++时有些不同，包括警戒线缓冲区和页面对其，一般我们并不会考虑aligned。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//os_linux.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> os::create_thread(Thread* thread, ThreadType thr_type,</span><br><span class=\"line\">                       <span class=\"keyword\">size_t</span> req_stack_size) &#123;</span><br><span class=\"line\">  assert(thread-&gt;osthread() == <span class=\"literal\">NULL</span>, <span class=\"string\">\"caller responsible\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate the OSThread object (&lt;_&lt;)可能空指针</span></span><br><span class=\"line\">  OSThread* osthread = <span class=\"keyword\">new</span> OSThread(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (osthread == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// java_thread</span></span><br><span class=\"line\">  osthread-&gt;set_thread_type(thr_type);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Initial state is ALLOCATED but not INITIALIZED</span></span><br><span class=\"line\">  osthread-&gt;set_state(ALLOCATED);</span><br><span class=\"line\"></span><br><span class=\"line\">  thread-&gt;set_osthread(osthread);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">pthread_attr_t</span> attr;</span><br><span class=\"line\">  pthread_attr_init(&amp;attr);</span><br><span class=\"line\">  <span class=\"comment\">// 所以java线程都是分离状态，join也并非用结合状态</span></span><br><span class=\"line\">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// -Xss默认1M，Thread没设置stackSize，在Linux-x86默认512K，取最大值</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);</span><br><span class=\"line\">  <span class=\"comment\">//这里设置栈警戒缓冲区，默认系统页大小</span></span><br><span class=\"line\">  <span class=\"comment\">//原注解的意思是，Linux的NPTL没有完全按照posix标准</span></span><br><span class=\"line\">  <span class=\"comment\">//理应guard_size + stack_size，且二者大小相等，而不是从stack_size取guard_size作为警戒取</span></span><br><span class=\"line\">  <span class=\"comment\">//所以这里模仿实现posix标准</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> guard_size = os::Linux::default_guard_size(thr_type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack_size &lt;= SIZE_MAX - guard_size) &#123;</span><br><span class=\"line\">    stack_size += guard_size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(is_aligned(stack_size, os::vm_page_size()), <span class=\"string\">\"stack_size not aligned\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status = pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span>, status, <span class=\"string\">\"pthread_attr_setstacksize\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span><br><span class=\"line\"></span><br><span class=\"line\">  ThreadState state;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//欧了，创建线程，函数指针thread_native_entry是重点</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> tid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class=\"keyword\">void</span>* (*)(<span class=\"keyword\">void</span>*)) thread_native_entry, thread);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pthread_attr_destroy(&amp;attr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Need to clean up stuff we've allocated so far</span></span><br><span class=\"line\">      thread-&gt;set_osthread(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> osthread;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Store pthread info into the OSThread</span></span><br><span class=\"line\">    osthread-&gt;set_pthread_id(tid);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待thread_native_entry设置osthread为INITIALIZED，或收到终止信号</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br><span class=\"line\">      <span class=\"function\">MutexLockerEx <span class=\"title\">ml</span><span class=\"params\">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((state = osthread-&gt;get_state()) == ALLOCATED) &#123;</span><br><span class=\"line\">        sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Aborted due to thread limit being reached</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state == ZOMBIE) &#123;</span><br><span class=\"line\">    thread-&gt;set_osthread(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> osthread;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The thread is returned suspended (in state INITIALIZED),</span></span><br><span class=\"line\">  <span class=\"comment\">// and is started higher up in the call chain</span></span><br><span class=\"line\">  assert(state == INITIALIZED, <span class=\"string\">\"race condition\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>pthread_create</code>会立即执行<code>thread_native_entry</code>，但又因为JavaThread被OSThread管理着，所以需要加各种排斥锁，达到二者状态同步的效果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">thread_native_entry</span><span class=\"params\">(Thread *thread)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  thread-&gt;record_stack_base_and_size();</span><br><span class=\"line\">  <span class=\"comment\">//我没理解这里的左右，有CPU大佬请解答</span></span><br><span class=\"line\">  <span class=\"comment\">// Try to randomize the cache line index of hot stack frames.</span></span><br><span class=\"line\">  <span class=\"comment\">// This helps when threads of the same stack traces evict each other's</span></span><br><span class=\"line\">  <span class=\"comment\">// cache lines. The threads can be either from the same JVM instance, or</span></span><br><span class=\"line\">  <span class=\"comment\">// from different JVM instances. The benefit is especially true for</span></span><br><span class=\"line\">  <span class=\"comment\">// processors with hyperthreading technology.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid = os::current_process_id();</span><br><span class=\"line\">  alloca(((pid ^ counter++) &amp; <span class=\"number\">7</span>) * <span class=\"number\">128</span>);</span><br><span class=\"line\">  <span class=\"comment\">//声明类似ThreadLocal的pthread_key_t</span></span><br><span class=\"line\">  thread-&gt;initialize_thread_current();</span><br><span class=\"line\"></span><br><span class=\"line\">  OSThread* osthread = thread-&gt;osthread();</span><br><span class=\"line\">  Monitor* sync = osthread-&gt;startThread_lock();</span><br><span class=\"line\"></span><br><span class=\"line\">  osthread-&gt;set_thread_id(os::current_thread_id());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (UseNUMA) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lgrp_id != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏蔽来自VM的阻塞信号</span></span><br><span class=\"line\">  os::Linux::hotspot_sigmask(thread);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// initialize floating point control register</span></span><br><span class=\"line\">  os::Linux::init_thread_fpu_state();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockerEx <span class=\"title\">ml</span><span class=\"params\">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// notify parent thread</span></span><br><span class=\"line\">    osthread-&gt;set_state(INITIALIZED);</span><br><span class=\"line\">    sync-&gt;notify_all();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// wait until os::start_thread() &lt;&lt;&lt;------  自璇中，等待调用Thread::start()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (osthread-&gt;get_state() == INITIALIZED) &#123;</span><br><span class=\"line\">      sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(osthread-&gt;pthread_id() != <span class=\"number\">0</span>, <span class=\"string\">\"pthread_id was not set as expected\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// call one more level start routine</span></span><br><span class=\"line\">  thread-&gt;call_run(); <span class=\"comment\">// &lt;--- 里面调用JavaThread::run()</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Note: at this point the thread object may already have deleted itself.</span></span><br><span class=\"line\">  <span class=\"comment\">// Prevent dereferencing it from here on out.</span></span><br><span class=\"line\">  thread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行Runable之前，JVM需要给java线程分配本地缓冲区等操作(这是一个大块)，这里算是到头了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> JavaThread::<span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化TLAB，即在年轻代割一点空间给自己，具体大小-XX:UseTLAB设置</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;initialize_tlab();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//不知道干嘛的，在linux_x86是空实现</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;create_stack_guard_pages();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;cache_global_variables();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Thread is now sufficiently initialized to be handled by the safepoint code as being</span></span><br><span class=\"line\">  <span class=\"comment\">// in the VM. Change thread state from _thread_new to _thread_in_vm</span></span><br><span class=\"line\">  ThreadStateTransition::transition_and_fence(<span class=\"keyword\">this</span>, _thread_new, _thread_in_vm);</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(JavaThread::current() == <span class=\"keyword\">this</span>, <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\">  assert(!Thread::current()-&gt;owns_locks(), <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  DTRACE_THREAD_PROBE(start, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class=\"line\">    JvmtiExport::post_thread_start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//这里才是真正调用java.lang.Thread#run()方法，执行Runable</span></span><br><span class=\"line\">  <span class=\"comment\">// We call another function to do the rest so we are sure that the stack addresses used</span></span><br><span class=\"line\">  <span class=\"comment\">// from there will be lower than the stack base just computed.</span></span><br><span class=\"line\">  thread_main_inner();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面代码不多做解释了，<code>this-&gt;entry_point()(this, this)</code> 等同于调用函数<code>thread_entry</code>，<code>JavaCalls</code>也是个大块，复杂调用java方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class=\"line\">  assert(JavaThread::current() == <span class=\"keyword\">this</span>, <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\">  assert(<span class=\"keyword\">this</span>-&gt;threadObj() != <span class=\"literal\">NULL</span>, <span class=\"string\">\"just checking\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Execute thread entry point unless this thread has a pending exception</span></span><br><span class=\"line\">  <span class=\"comment\">// or has been stopped before starting.</span></span><br><span class=\"line\">  <span class=\"comment\">// Note: Due to JVM_StopThread we can have pending exceptions already!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class=\"line\">      !java_lang_Thread::is_stillborn(<span class=\"keyword\">this</span>-&gt;threadObj())) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"function\">ResourceMark <span class=\"title\">rm</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>-&gt;set_native_thread_name(<span class=\"keyword\">this</span>-&gt;get_thread_name());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">HandleMark <span class=\"title\">hm</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;entry_point()(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  DTRACE_THREAD_PROBE(<span class=\"built_in\">stop</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cleanup is handled in post_run()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">thread_entry</span><span class=\"params\">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">HandleMark <span class=\"title\">hm</span><span class=\"params\">(THREAD)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">Handle <span class=\"title\">obj</span><span class=\"params\">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class=\"line\">  <span class=\"function\">JavaValue <span class=\"title\">result</span><span class=\"params\">(T_VOID)</span></span>;</span><br><span class=\"line\">  JavaCalls::call_virtual(&amp;result,</span><br><span class=\"line\">                          obj,</span><br><span class=\"line\">                          SystemDictionary::Thread_klass(),</span><br><span class=\"line\">                          vmSymbols::run_method_name(),</span><br><span class=\"line\">                          vmSymbols::void_method_signature(),</span><br><span class=\"line\">                          THREAD);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总体来说，创建一个线程对于JVM来说还是相对费劲的，不是说性能不好，是需要做太多事。与GC息息相关的两个点就是TLAB与ThreadSafePoint，其他则是对于java程序员透明的栈空间的分配(这里指的是虚拟内存地址)、线程状态管理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近兴致勃勃捡起C++，打算深入Unix网络编程，但输出博客想从比较简单的问题入手，所以对标一下Java与C的线程创建过程，加深一下理解。（注，Linux）</p>\n<hr>\n<p>Java创建线程是简单的，<code>new Thread()</code>和<code>start()</code>即可启动并执行线程，但由于posix提供的api还涉及不少线程属性，真实过程显然要复杂得多。可以看到前者<code>new Thread</code>只是初始化属性，后者才是真正意义上调用本地接口<code>JVM_StartThread</code>，创建线程。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//以下函数指针均被定义在jvm.h，实现在jvm.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod methods[] = &#123;</span><br><span class=\"line\">    &#123;<span class=\"string\">\"start0\"</span>,           <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"stop0\"</span>,            <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\")V\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"isAlive\"</span>,          <span class=\"string\">\"()Z\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"suspend0\"</span>,         <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"resume0\"</span>,          <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"setPriority0\"</span>,     <span class=\"string\">\"(I)V\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"yield\"</span>,            <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"sleep\"</span>,            <span class=\"string\">\"(J)V\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_Sleep&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"currentThread\"</span>,    <span class=\"string\">\"()\"</span> THD,     (<span class=\"keyword\">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"countStackFrames\"</span>, <span class=\"string\">\"()I\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"interrupt0\"</span>,       <span class=\"string\">\"()V\"</span>,        (<span class=\"keyword\">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"isInterrupted\"</span>,    <span class=\"string\">\"(Z)Z\"</span>,       (<span class=\"keyword\">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"holdsLock\"</span>,        <span class=\"string\">\"(\"</span> OBJ <span class=\"string\">\")Z\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"getThreads\"</span>,        <span class=\"string\">\"()[\"</span> THD,   (<span class=\"keyword\">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"dumpThreads\"</span>,      <span class=\"string\">\"([\"</span> THD <span class=\"string\">\")[[\"</span> STE, (<span class=\"keyword\">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">\"setNativeName\"</span>,    <span class=\"string\">\"(\"</span> STR <span class=\"string\">\")V\"</span>, (<span class=\"keyword\">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>阅读相关JVM源码时，需要知道几个重要类的关系，下面部分实现默认os_linux.cpp。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、JavaThread: 创建线程执行任务，持有java_lang_thread &amp; OSThread对象，维护线程状态运行Thread.run()的地方</span><br><span class=\"line\">2、OSThread: 由于不同操作系统的状态不一致，所以JVM维护了一套平台线程状态，被JavaThread所持有</span><br><span class=\"line\">3、java_lang_Thread::ThreadStatus: 即Java线程状态，与java.lang.Thread.State完全一致</span><br><span class=\"line\">4、OSThread::ThreadState: 2所说的平台线程状态</span><br></pre></td></tr></table></figure>\n\n<p>需要说的是，以下相关pthread函数均是posix标准，可自行阅读&lt;pthread.h&gt;文档，不多赘述。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JVM_ENTRY(<span class=\"keyword\">void</span>, JVM_StartThread(JNIEnv* env, jobject jthread))</span><br><span class=\"line\">  JVMWrapper(<span class=\"string\">\"JVM_StartThread\"</span>);</span><br><span class=\"line\">  JavaThread *native_thread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">bool</span> throw_illegal_thread_state = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//这里一对花括号代表一段程序，执行完后回释放资源，会调用~MutexLocker(Monitor * monitor)释放互斥锁 (注，~代表析构函数)</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取互斥锁，加上诉说明，等同于synchronized代码块</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的独占锁依然使用了pthread_mutex_lock函数</span></span><br><span class=\"line\">    <span class=\"comment\">//具体实现在os_posix.cpp的PlatformEvent.park &amp; unpark函数</span></span><br><span class=\"line\">    <span class=\"function\">MutexLocker <span class=\"title\">mu</span><span class=\"params\">(Threads_lock)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里检查Thread.java的long eetop变量是否有值，避免重复启动线程，该值为JavaThread的地址</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">      throw_illegal_thread_state = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//实例化Thread时，可以设置stackSize，用于初始化虚拟地址栈空间</span></span><br><span class=\"line\">      jlong <span class=\"built_in\">size</span> =</span><br><span class=\"line\">             java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));</span><br><span class=\"line\"></span><br><span class=\"line\">      NOT_LP64(<span class=\"keyword\">if</span> (<span class=\"built_in\">size</span> &gt; SIZE_MAX) <span class=\"built_in\">size</span> = SIZE_MAX;)</span><br><span class=\"line\">      <span class=\"keyword\">size_t</span> sz = <span class=\"built_in\">size</span> &gt; <span class=\"number\">0</span> ? (<span class=\"keyword\">size_t</span>) <span class=\"built_in\">size</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"comment\">//这里正式调用pthread_create创建线程</span></span><br><span class=\"line\">      native_thread = <span class=\"keyword\">new</span> JavaThread(&amp;thread_entry, sz);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//可能因为内存不足，无法为OSThread分配空间，所以可能为NULL</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (native_thread-&gt;osthread() != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//上面提到的eetop，将在这里被设置</span></span><br><span class=\"line\">        native_thread-&gt;<span class=\"built_in\">prepare</span>(jthread);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (throw_illegal_thread_state) &#123;</span><br><span class=\"line\">    THROW(vmSymbols::java_lang_IllegalThreadStateException());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(native_thread != <span class=\"literal\">NULL</span>, <span class=\"string\">\"Starting null thread?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (native_thread-&gt;osthread() == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 安全内存回收(SMR)</span></span><br><span class=\"line\">    native_thread-&gt;smr_delete();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (JvmtiExport::should_post_resource_exhausted()) &#123;</span><br><span class=\"line\">      JvmtiExport::post_resource_exhausted(</span><br><span class=\"line\">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class=\"line\">        os::native_thread_creation_failed_msg());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),</span><br><span class=\"line\">              os::native_thread_creation_failed_msg());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//哦吼！这是线程真正的开始</span></span><br><span class=\"line\">  Thread::start(native_thread);</span><br><span class=\"line\"></span><br><span class=\"line\">JVM_END</span><br></pre></td></tr></table></figure>\n\n<p>我们知道<code>pthread_create</code>创建线程后立刻执行线程，所以什么<code>Thread::start</code>才是真正启动线程，我们需要进一步窥探。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//JavaThread类定义在thread.hpp中，为Thread的子类</span></span><br><span class=\"line\">JavaThread::JavaThread(ThreadFunction entry_point, <span class=\"keyword\">size_t</span> stack_sz) :</span><br><span class=\"line\">                       Thread() &#123;</span><br><span class=\"line\">  <span class=\"comment\">//初始化字段，最重要的是创建线程安全点，作用在垃圾回收时的STW</span></span><br><span class=\"line\">  initialize();</span><br><span class=\"line\">  _jni_attach_state = _not_attaching_via_jni;</span><br><span class=\"line\">  set_entry_point(entry_point);</span><br><span class=\"line\">  <span class=\"comment\">//yep，线程类型有gc、编译、守护、平台等几种</span></span><br><span class=\"line\">  os::ThreadType thr_type = os::java_thread;</span><br><span class=\"line\">  thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :</span><br><span class=\"line\">                                                     os::java_thread;</span><br><span class=\"line\">  os::create_thread(<span class=\"keyword\">this</span>, thr_type, stack_sz);</span><br><span class=\"line\">  <span class=\"comment\">//这段话我没懂，有大佬明白可以交流下</span></span><br><span class=\"line\">  <span class=\"comment\">// The _osthread may be NULL here because we ran out of memory (too many threads active).</span></span><br><span class=\"line\">  <span class=\"comment\">// We need to throw and OutOfMemoryError - however we cannot do this here because the caller</span></span><br><span class=\"line\">  <span class=\"comment\">// may hold a lock and all locks must be unlocked before throwing the exception (throwing</span></span><br><span class=\"line\">  <span class=\"comment\">// the exception consists of creating the exception object &amp; initializing it, initialization</span></span><br><span class=\"line\">  <span class=\"comment\">// will leave the VM via a JavaCall and then all locks must be unlocked).</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// The thread is still suspended when we reach here. Thread must be explicit started</span></span><br><span class=\"line\">  <span class=\"comment\">// by creator! Furthermore, the thread must also explicitly be added to the Threads list</span></span><br><span class=\"line\">  <span class=\"comment\">// by calling Threads:add. The reason why this is not done here, is because the thread</span></span><br><span class=\"line\">  <span class=\"comment\">// object must be fully initialized (take a look at JVM_Start)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>create_thread</code>对线程属性的设置跟日常写c++时有些不同，包括警戒线缓冲区和页面对其，一般我们并不会考虑aligned。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//os_linux.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> os::create_thread(Thread* thread, ThreadType thr_type,</span><br><span class=\"line\">                       <span class=\"keyword\">size_t</span> req_stack_size) &#123;</span><br><span class=\"line\">  assert(thread-&gt;osthread() == <span class=\"literal\">NULL</span>, <span class=\"string\">\"caller responsible\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Allocate the OSThread object (&lt;_&lt;)可能空指针</span></span><br><span class=\"line\">  OSThread* osthread = <span class=\"keyword\">new</span> OSThread(<span class=\"literal\">NULL</span>, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (osthread == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// java_thread</span></span><br><span class=\"line\">  osthread-&gt;set_thread_type(thr_type);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Initial state is ALLOCATED but not INITIALIZED</span></span><br><span class=\"line\">  osthread-&gt;set_state(ALLOCATED);</span><br><span class=\"line\"></span><br><span class=\"line\">  thread-&gt;set_osthread(osthread);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">pthread_attr_t</span> attr;</span><br><span class=\"line\">  pthread_attr_init(&amp;attr);</span><br><span class=\"line\">  <span class=\"comment\">// 所以java线程都是分离状态，join也并非用结合状态</span></span><br><span class=\"line\">  pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// -Xss默认1M，Thread没设置stackSize，在Linux-x86默认512K，取最大值</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> stack_size = os::Posix::get_initial_stack_size(thr_type, req_stack_size);</span><br><span class=\"line\">  <span class=\"comment\">//这里设置栈警戒缓冲区，默认系统页大小</span></span><br><span class=\"line\">  <span class=\"comment\">//原注解的意思是，Linux的NPTL没有完全按照posix标准</span></span><br><span class=\"line\">  <span class=\"comment\">//理应guard_size + stack_size，且二者大小相等，而不是从stack_size取guard_size作为警戒取</span></span><br><span class=\"line\">  <span class=\"comment\">//所以这里模仿实现posix标准</span></span><br><span class=\"line\">  <span class=\"keyword\">size_t</span> guard_size = os::Linux::default_guard_size(thr_type);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stack_size &lt;= SIZE_MAX - guard_size) &#123;</span><br><span class=\"line\">    stack_size += guard_size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  assert(is_aligned(stack_size, os::vm_page_size()), <span class=\"string\">\"stack_size not aligned\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> status = pthread_attr_setstacksize(&amp;attr, stack_size);</span><br><span class=\"line\">  assert_status(status == <span class=\"number\">0</span>, status, <span class=\"string\">\"pthread_attr_setstacksize\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  pthread_attr_setguardsize(&amp;attr, os::Linux::default_guard_size(thr_type));</span><br><span class=\"line\"></span><br><span class=\"line\">  ThreadState state;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"comment\">//欧了，创建线程，函数指针thread_native_entry是重点</span></span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> tid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = pthread_create(&amp;tid, &amp;attr, (<span class=\"keyword\">void</span>* (*)(<span class=\"keyword\">void</span>*)) thread_native_entry, thread);</span><br><span class=\"line\">    </span><br><span class=\"line\">    pthread_attr_destroy(&amp;attr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Need to clean up stuff we've allocated so far</span></span><br><span class=\"line\">      thread-&gt;set_osthread(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">      <span class=\"keyword\">delete</span> osthread;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Store pthread info into the OSThread</span></span><br><span class=\"line\">    osthread-&gt;set_pthread_id(tid);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 等待thread_native_entry设置osthread为INITIALIZED，或收到终止信号</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      Monitor* sync_with_child = osthread-&gt;startThread_lock();</span><br><span class=\"line\">      <span class=\"function\">MutexLockerEx <span class=\"title\">ml</span><span class=\"params\">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> ((state = osthread-&gt;get_state()) == ALLOCATED) &#123;</span><br><span class=\"line\">        sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Aborted due to thread limit being reached</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state == ZOMBIE) &#123;</span><br><span class=\"line\">    thread-&gt;set_osthread(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> osthread;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The thread is returned suspended (in state INITIALIZED),</span></span><br><span class=\"line\">  <span class=\"comment\">// and is started higher up in the call chain</span></span><br><span class=\"line\">  assert(state == INITIALIZED, <span class=\"string\">\"race condition\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>pthread_create</code>会立即执行<code>thread_native_entry</code>，但又因为JavaThread被OSThread管理着，所以需要加各种排斥锁，达到二者状态同步的效果。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *<span class=\"title\">thread_native_entry</span><span class=\"params\">(Thread *thread)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  thread-&gt;record_stack_base_and_size();</span><br><span class=\"line\">  <span class=\"comment\">//我没理解这里的左右，有CPU大佬请解答</span></span><br><span class=\"line\">  <span class=\"comment\">// Try to randomize the cache line index of hot stack frames.</span></span><br><span class=\"line\">  <span class=\"comment\">// This helps when threads of the same stack traces evict each other's</span></span><br><span class=\"line\">  <span class=\"comment\">// cache lines. The threads can be either from the same JVM instance, or</span></span><br><span class=\"line\">  <span class=\"comment\">// from different JVM instances. The benefit is especially true for</span></span><br><span class=\"line\">  <span class=\"comment\">// processors with hyperthreading technology.</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> pid = os::current_process_id();</span><br><span class=\"line\">  alloca(((pid ^ counter++) &amp; <span class=\"number\">7</span>) * <span class=\"number\">128</span>);</span><br><span class=\"line\">  <span class=\"comment\">//声明类似ThreadLocal的pthread_key_t</span></span><br><span class=\"line\">  thread-&gt;initialize_thread_current();</span><br><span class=\"line\"></span><br><span class=\"line\">  OSThread* osthread = thread-&gt;osthread();</span><br><span class=\"line\">  Monitor* sync = osthread-&gt;startThread_lock();</span><br><span class=\"line\"></span><br><span class=\"line\">  osthread-&gt;set_thread_id(os::current_thread_id());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (UseNUMA) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lgrp_id = os::numa_get_group_id();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lgrp_id != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">      thread-&gt;set_lgrp_id(lgrp_id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 屏蔽来自VM的阻塞信号</span></span><br><span class=\"line\">  os::Linux::hotspot_sigmask(thread);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// initialize floating point control register</span></span><br><span class=\"line\">  os::Linux::init_thread_fpu_state();</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockerEx <span class=\"title\">ml</span><span class=\"params\">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// notify parent thread</span></span><br><span class=\"line\">    osthread-&gt;set_state(INITIALIZED);</span><br><span class=\"line\">    sync-&gt;notify_all();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// wait until os::start_thread() &lt;&lt;&lt;------  自璇中，等待调用Thread::start()</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (osthread-&gt;get_state() == INITIALIZED) &#123;</span><br><span class=\"line\">      sync-&gt;wait(Mutex::_no_safepoint_check_flag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(osthread-&gt;pthread_id() != <span class=\"number\">0</span>, <span class=\"string\">\"pthread_id was not set as expected\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// call one more level start routine</span></span><br><span class=\"line\">  thread-&gt;call_run(); <span class=\"comment\">// &lt;--- 里面调用JavaThread::run()</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Note: at this point the thread object may already have deleted itself.</span></span><br><span class=\"line\">  <span class=\"comment\">// Prevent dereferencing it from here on out.</span></span><br><span class=\"line\">  thread = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行Runable之前，JVM需要给java线程分配本地缓冲区等操作(这是一个大块)，这里算是到头了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> JavaThread::<span class=\"built_in\">run</span>() &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 初始化TLAB，即在年轻代割一点空间给自己，具体大小-XX:UseTLAB设置</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;initialize_tlab();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//不知道干嘛的，在linux_x86是空实现</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;create_stack_guard_pages();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;cache_global_variables();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Thread is now sufficiently initialized to be handled by the safepoint code as being</span></span><br><span class=\"line\">  <span class=\"comment\">// in the VM. Change thread state from _thread_new to _thread_in_vm</span></span><br><span class=\"line\">  ThreadStateTransition::transition_and_fence(<span class=\"keyword\">this</span>, _thread_new, _thread_in_vm);</span><br><span class=\"line\"></span><br><span class=\"line\">  assert(JavaThread::current() == <span class=\"keyword\">this</span>, <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\">  assert(!Thread::current()-&gt;owns_locks(), <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  DTRACE_THREAD_PROBE(start, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class=\"line\">    JvmtiExport::post_thread_start(<span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//这里才是真正调用java.lang.Thread#run()方法，执行Runable</span></span><br><span class=\"line\">  <span class=\"comment\">// We call another function to do the rest so we are sure that the stack addresses used</span></span><br><span class=\"line\">  <span class=\"comment\">// from there will be lower than the stack base just computed.</span></span><br><span class=\"line\">  thread_main_inner();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面代码不多做解释了，<code>this-&gt;entry_point()(this, this)</code> 等同于调用函数<code>thread_entry</code>，<code>JavaCalls</code>也是个大块，复杂调用java方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class=\"line\">  assert(JavaThread::current() == <span class=\"keyword\">this</span>, <span class=\"string\">\"sanity check\"</span>);</span><br><span class=\"line\">  assert(<span class=\"keyword\">this</span>-&gt;threadObj() != <span class=\"literal\">NULL</span>, <span class=\"string\">\"just checking\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Execute thread entry point unless this thread has a pending exception</span></span><br><span class=\"line\">  <span class=\"comment\">// or has been stopped before starting.</span></span><br><span class=\"line\">  <span class=\"comment\">// Note: Due to JVM_StopThread we can have pending exceptions already!</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class=\"line\">      !java_lang_Thread::is_stillborn(<span class=\"keyword\">this</span>-&gt;threadObj())) &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"function\">ResourceMark <span class=\"title\">rm</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>-&gt;set_native_thread_name(<span class=\"keyword\">this</span>-&gt;get_thread_name());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">HandleMark <span class=\"title\">hm</span><span class=\"params\">(<span class=\"keyword\">this</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;entry_point()(<span class=\"keyword\">this</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  DTRACE_THREAD_PROBE(<span class=\"built_in\">stop</span>, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Cleanup is handled in post_run()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">thread_entry</span><span class=\"params\">(JavaThread* thread, TRAPS)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">HandleMark <span class=\"title\">hm</span><span class=\"params\">(THREAD)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">Handle <span class=\"title\">obj</span><span class=\"params\">(THREAD, thread-&gt;threadObj())</span></span>;</span><br><span class=\"line\">  <span class=\"function\">JavaValue <span class=\"title\">result</span><span class=\"params\">(T_VOID)</span></span>;</span><br><span class=\"line\">  JavaCalls::call_virtual(&amp;result,</span><br><span class=\"line\">                          obj,</span><br><span class=\"line\">                          SystemDictionary::Thread_klass(),</span><br><span class=\"line\">                          vmSymbols::run_method_name(),</span><br><span class=\"line\">                          vmSymbols::void_method_signature(),</span><br><span class=\"line\">                          THREAD);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总体来说，创建一个线程对于JVM来说还是相对费劲的，不是说性能不好，是需要做太多事。与GC息息相关的两个点就是TLAB与ThreadSafePoint，其他则是对于java程序员透明的栈空间的分配(这里指的是虚拟内存地址)、线程状态管理。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4b9g7re00004ejdcdfdgc22","category_id":"ck4b9g7rn00034ejdg28h5vkp","_id":"ck4b9g7rt000c4ejd6cthdu4x"},{"post_id":"ck4b9g7ro00054ejd2pz68h38","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7rw000h4ejd7kgj8sjc"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","category_id":"ck4b9g7ru000d4ejd3ryg6nzx","_id":"ck4b9g7rz000m4ejd0u025ci5"},{"post_id":"ck4b9g7rq00074ejd9ystar7w","category_id":"ck4b9g7rw000i4ejd0ycy7akl","_id":"ck4b9g7s1000r4ejdg1rsailg"},{"post_id":"ck4b9g7rt000b4ejdepuh7wwk","category_id":"ck4b9g7rz000n4ejddchu9hhw","_id":"ck4b9g7s8000y4ejdc6wtd0q2"},{"post_id":"ck4b9g7ru000f4ejd5jc4aloh","category_id":"ck4b9g7rz000n4ejddchu9hhw","_id":"ck4b9g7sa00124ejd5i4ihbzn"},{"post_id":"ck4b9g7rv000g4ejd84pe0mti","category_id":"ck4b9g7s8000x4ejdawsyaeyy","_id":"ck4b9g7sd00174ejdd0yeaqkd"},{"post_id":"ck4b9g7sb00154ejdfrdpfn7u","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7sf001c4ejd9fhx5ltp"},{"post_id":"ck4b9g7rw000k4ejd4ry6dhbu","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7sg001f4ejdbo1a9yie"},{"post_id":"ck4b9g7sc00164ejdcov89f2a","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7si001i4ejd1o9p9zc4"},{"post_id":"ck4b9g7sd001a4ejde5bd52ls","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7sj001l4ejdhnrxbsfq"},{"post_id":"ck4b9g7rx000l4ejdfgebh8hc","category_id":"ck4b9g7sd00184ejd3t8gcgq9","_id":"ck4b9g7sl001o4ejda0m1h9pu"},{"post_id":"ck4b9g7rz000p4ejdew5odlyl","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7sm001s4ejd8lzl3tka"},{"post_id":"ck4b9g7s0000q4ejdc2q98r3a","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7so001y4ejd7m9ka8bo"},{"post_id":"ck4b9g7s1000s4ejd07p65xrj","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7sq00254ejd2vgscuf7"},{"post_id":"ck4b9g7sn001v4ejdb02m2m7g","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7sr00284ejd0i2cgmlz"},{"post_id":"ck4b9g7so001z4ejddd1sg5xb","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7st002d4ejdetan765d"},{"post_id":"ck4b9g7s5000v4ejd8b9da5ll","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7su002g4ejd4qj515fo"},{"post_id":"ck4b9g7sp00224ejdc09md7ls","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7sv002l4ejd0715gdnm"},{"post_id":"ck4b9g7sq00264ejd241xc1k1","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7sw002o4ejd2u4h1j7p"},{"post_id":"ck4b9g7s7000w4ejdh4chaaz4","category_id":"ck4b9g7s8000x4ejdawsyaeyy","_id":"ck4b9g7t2002t4ejd0yszhftk"},{"post_id":"ck4b9g7sr00294ejd43inc7i3","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7t3002w4ejd8sljadtl"},{"post_id":"ck4b9g7st002e4ejd8ni07dgd","category_id":"ck4b9g7rr00084ejd6k1xa6cn","_id":"ck4b9g7t4002z4ejdgxhea7kp"},{"post_id":"ck4b9g7s900104ejddk2g9vy5","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7t500344ejd52qc9fv0"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","category_id":"ck4b9g7rn00034ejdg28h5vkp","_id":"ck4b9g7t600374ejdh1t6hpm9"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","category_id":"ck4b9g7rn00034ejdg28h5vkp","_id":"ck4b9g7t8003c4ejddpfh78gi"},{"post_id":"ck4b9g7sa00114ejd6osx9dmq","category_id":"ck4b9g7sb00134ejda56j6scr","_id":"ck4b9g7t8003e4ejd2ebp8k30"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","category_id":"ck4b9g7ru000d4ejd3ryg6nzx","_id":"ck4b9g7ta003i4ejdfwsc1zjn"},{"post_id":"ck4b9g7se001b4ejd00vn11h7","category_id":"ck4b9g7t2002s4ejd30bwfm7a","_id":"ck4b9g7ta003k4ejd6sq6474m"},{"post_id":"ck4b9g7sf001e4ejddlnxe9sv","category_id":"ck4b9g7t2002s4ejd30bwfm7a","_id":"ck4b9g7tb003o4ejda40j1z0b"},{"post_id":"ck4b9g7t700384ejdd7180z15","category_id":"ck4b9g7rn00034ejdg28h5vkp","_id":"ck4b9g7tc003q4ejd4zj25ii2"},{"post_id":"ck4b9g7sh001h4ejddiau7c4b","category_id":"ck4b9g7t2002s4ejd30bwfm7a","_id":"ck4b9g7tc003u4ejddqe234f8"},{"post_id":"ck4b9g7sj001k4ejd59qw5m53","category_id":"ck4b9g7t2002s4ejd30bwfm7a","_id":"ck4b9g7td003w4ejd1hju22td"},{"post_id":"ck4b9g7sk001n4ejd8iut9i5u","category_id":"ck4b9g7tb003l4ejd79eseq5z","_id":"ck4b9g7td003z4ejd6hiogvym"},{"post_id":"ck4b9g7sl001r4ejd3vt56rk3","category_id":"ck4b9g7tc003s4ejd72l59sk9","_id":"ck4b9g7te00434ejdessk0nfn"},{"post_id":"ck4b9g7sw002p4ejdfefg0oj8","category_id":"ck4b9g7td003y4ejd0pozaaq5","_id":"ck4b9g7th00484ejdgi4y5tlf"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","category_id":"ck4b9g7te00444ejdblks35ii","_id":"ck4b9g7tj004e4ejd9nr3d4hu"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","category_id":"ck4b9g7te00444ejdblks35ii","_id":"ck4b9g7tj004i4ejd2w6t7mvc"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","category_id":"ck4b9g7ti004d4ejdez0k4uyq","_id":"ck4b9g7tk004m4ejdb6yl5gyw"}],"PostTag":[{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7sl001p4ejd93zfcocq"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7rr00094ejd4gt5fm0d","_id":"ck4b9g7sm001t4ejdhv9o6wb9"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7ru000e4ejd5qprc8t0","_id":"ck4b9g7sn001w4ejd0bis4xcs"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7rw000j4ejdbucz75im","_id":"ck4b9g7so00204ejd6w093ugg"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7rz000o4ejd5prl371a","_id":"ck4b9g7sq00234ejd0pend8t6"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7s4000u4ejd7f3a6ck0","_id":"ck4b9g7sr00274ejd66s116bh"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7s9000z4ejdgs3wh9ch","_id":"ck4b9g7ss002b4ejda8lt2w82"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7sb00144ejdd8wj3cil","_id":"ck4b9g7st002f4ejdeazx8qxf"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7sd00194ejd2qhib5jz","_id":"ck4b9g7su002i4ejdbqml0011"},{"post_id":"ck4b9g7re00004ejdcdfdgc22","tag_id":"ck4b9g7sh001g4ejd5152ep2v","_id":"ck4b9g7sw002n4ejd2zfx5uvw"},{"post_id":"ck4b9g7sq00264ejd241xc1k1","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7t1002q4ejda1c499ma"},{"post_id":"ck4b9g7sq00264ejd241xc1k1","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7t3002v4ejd8ht5428z"},{"post_id":"ck4b9g7sq00264ejd241xc1k1","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7t4002y4ejda1tnaj86"},{"post_id":"ck4b9g7ro00054ejd2pz68h38","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7t500334ejd605meqwo"},{"post_id":"ck4b9g7ro00054ejd2pz68h38","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7t600364ejdewsm16z9"},{"post_id":"ck4b9g7ro00054ejd2pz68h38","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7t7003b4ejdf37w38mw"},{"post_id":"ck4b9g7sr00294ejd43inc7i3","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7t8003d4ejd1wolayt9"},{"post_id":"ck4b9g7sr00294ejd43inc7i3","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7t9003g4ejd011a3gvf"},{"post_id":"ck4b9g7sr00294ejd43inc7i3","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7ta003j4ejdf2yi81lv"},{"post_id":"ck4b9g7st002e4ejd8ni07dgd","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7tb003m4ejdh20qguox"},{"post_id":"ck4b9g7st002e4ejd8ni07dgd","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7tb003p4ejdfh2r4nhk"},{"post_id":"ck4b9g7st002e4ejd8ni07dgd","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7tc003r4ejdenkaa21b"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7td003v4ejd50yvcq3e"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7ss002a4ejdd12tg9af","_id":"ck4b9g7td003x4ejdfpvpfvr4"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7sv002j4ejd6i9ea51t","_id":"ck4b9g7te00414ejdbb9p1gdr"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7t1002r4ejd1a2t2sse","_id":"ck4b9g7te00424ejde8qja9bh"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7t400304ejddlx090tq","_id":"ck4b9g7th00464ejd7h779w1w"},{"post_id":"ck4b9g7rp00064ejd5m314d1q","tag_id":"ck4b9g7t7003a4ejdej8e1drm","_id":"ck4b9g7th00474ejddtjy0uw6"},{"post_id":"ck4b9g7rt000b4ejdepuh7wwk","tag_id":"ck4b9g7t9003h4ejd43nsdq5c","_id":"ck4b9g7ti004b4ejd59ghd4a5"},{"post_id":"ck4b9g7ru000f4ejd5jc4aloh","tag_id":"ck4b9g7t9003h4ejd43nsdq5c","_id":"ck4b9g7ti004c4ejd1d1pg62q"},{"post_id":"ck4b9g7rv000g4ejd84pe0mti","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tj004f4ejd090439a8"},{"post_id":"ck4b9g7rv000g4ejd84pe0mti","tag_id":"ck4b9g7td00404ejd29se1f0f","_id":"ck4b9g7tj004h4ejd87dt7g1i"},{"post_id":"ck4b9g7rw000k4ejd4ry6dhbu","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tj004j4ejddimz59jp"},{"post_id":"ck4b9g7rw000k4ejd4ry6dhbu","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tk004l4ejd0x5uht0y"},{"post_id":"ck4b9g7rz000p4ejdew5odlyl","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tk004o4ejd5yud4b4o"},{"post_id":"ck4b9g7rz000p4ejdew5odlyl","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tl004p4ejdb51q8721"},{"post_id":"ck4b9g7s0000q4ejdc2q98r3a","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tm004s4ejdagf55q9q"},{"post_id":"ck4b9g7s0000q4ejdc2q98r3a","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tm004t4ejdbbeb0gv9"},{"post_id":"ck4b9g7s1000s4ejd07p65xrj","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tn004w4ejd901xa71a"},{"post_id":"ck4b9g7s1000s4ejd07p65xrj","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7to004x4ejd5nwdde1k"},{"post_id":"ck4b9g7s5000v4ejd8b9da5ll","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7to00504ejdesfpess9"},{"post_id":"ck4b9g7s5000v4ejd8b9da5ll","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tp00514ejddeu2dzsk"},{"post_id":"ck4b9g7s7000w4ejdh4chaaz4","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tq00544ejde0nj0q0z"},{"post_id":"ck4b9g7s7000w4ejdh4chaaz4","tag_id":"ck4b9g7td00404ejd29se1f0f","_id":"ck4b9g7tq00554ejdf3lt08f5"},{"post_id":"ck4b9g7s900104ejddk2g9vy5","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tr00584ejddt9k4syq"},{"post_id":"ck4b9g7s900104ejddk2g9vy5","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tr00594ejdgl9r2thd"},{"post_id":"ck4b9g7sa00114ejd6osx9dmq","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7ts005c4ejd7tce93gd"},{"post_id":"ck4b9g7sa00114ejd6osx9dmq","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7ts005d4ejd9pyc8drx"},{"post_id":"ck4b9g7sb00154ejdfrdpfn7u","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tt005g4ejdgj8pcxrr"},{"post_id":"ck4b9g7sb00154ejdfrdpfn7u","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tt005h4ejdea2bdbrf"},{"post_id":"ck4b9g7sc00164ejdcov89f2a","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tt005k4ejd1n50fct2"},{"post_id":"ck4b9g7sc00164ejdcov89f2a","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tu005l4ejdcllw56gs"},{"post_id":"ck4b9g7sd001a4ejde5bd52ls","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tu005o4ejdas6q1mog"},{"post_id":"ck4b9g7sd001a4ejde5bd52ls","tag_id":"ck4b9g7ti004a4ejdbmm8341b","_id":"ck4b9g7tv005p4ejd1z90hl2i"},{"post_id":"ck4b9g7se001b4ejd00vn11h7","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tv005t4ejdbgkq9frq"},{"post_id":"ck4b9g7se001b4ejd00vn11h7","tag_id":"ck4b9g7tv005q4ejdhfupez11","_id":"ck4b9g7tw005u4ejdf8d468el"},{"post_id":"ck4b9g7se001b4ejd00vn11h7","tag_id":"ck4b9g7tv005r4ejd4wl1dxrv","_id":"ck4b9g7tw005w4ejdbvj7df7l"},{"post_id":"ck4b9g7sf001e4ejddlnxe9sv","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tw005y4ejd8qtvb3on"},{"post_id":"ck4b9g7sf001e4ejddlnxe9sv","tag_id":"ck4b9g7tw005v4ejd2ii64kln","_id":"ck4b9g7tw005z4ejd6i9dbxss"},{"post_id":"ck4b9g7sh001h4ejddiau7c4b","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7ty00624ejd1pvpbyd2"},{"post_id":"ck4b9g7sh001h4ejddiau7c4b","tag_id":"ck4b9g7tw00604ejdcnt30rrm","_id":"ck4b9g7ty00634ejdeejabvpu"},{"post_id":"ck4b9g7sj001k4ejd59qw5m53","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7tz00664ejd2hrxdjmj"},{"post_id":"ck4b9g7sj001k4ejd59qw5m53","tag_id":"ck4b9g7ty00644ejdhyte9hbl","_id":"ck4b9g7tz00674ejd6i3r7fl3"},{"post_id":"ck4b9g7sk001n4ejd8iut9i5u","tag_id":"ck4b9g7ty00654ejdgz2mfzdd","_id":"ck4b9g7u0006b4ejdc9p76ezi"},{"post_id":"ck4b9g7sk001n4ejd8iut9i5u","tag_id":"ck4b9g7tz00684ejdd0k2do2p","_id":"ck4b9g7u0006c4ejdd10ae74d"},{"post_id":"ck4b9g7sk001n4ejd8iut9i5u","tag_id":"ck4b9g7tz00694ejdb554el9p","_id":"ck4b9g7u0006e4ejd7n0hhmyi"},{"post_id":"ck4b9g7sl001r4ejd3vt56rk3","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7u1006h4ejd6m2o4l8s"},{"post_id":"ck4b9g7sl001r4ejd3vt56rk3","tag_id":"ck4b9g7u0006d4ejdg6p739n4","_id":"ck4b9g7u1006i4ejd83b85tfx"},{"post_id":"ck4b9g7sl001r4ejd3vt56rk3","tag_id":"ck4b9g7u0006f4ejd7l9sdgb7","_id":"ck4b9g7u1006k4ejdbwds4fmk"},{"post_id":"ck4b9g7sn001v4ejdb02m2m7g","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7u2006l4ejdfvfzdvkp"},{"post_id":"ck4b9g7sn001v4ejdb02m2m7g","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7u2006n4ejde8c42eip"},{"post_id":"ck4b9g7sn001v4ejdb02m2m7g","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7u2006o4ejd9yig3o2y"},{"post_id":"ck4b9g7so001z4ejddd1sg5xb","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7u3006q4ejdf16b5kxn"},{"post_id":"ck4b9g7so001z4ejddd1sg5xb","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7u3006r4ejd5a3x9zek"},{"post_id":"ck4b9g7so001z4ejddd1sg5xb","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7u3006t4ejdcjw5319w"},{"post_id":"ck4b9g7sp00224ejdc09md7ls","tag_id":"ck4b9g7sk001m4ejd9j0ycvih","_id":"ck4b9g7u3006u4ejdha2tacrv"},{"post_id":"ck4b9g7sp00224ejdc09md7ls","tag_id":"ck4b9g7sm001u4ejd6q1n7j4s","_id":"ck4b9g7u4006w4ejdhztzgh4q"},{"post_id":"ck4b9g7sp00224ejdc09md7ls","tag_id":"ck4b9g7sp00214ejd50a6gjrc","_id":"ck4b9g7u4006x4ejd7wh29107"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7u4006z4ejdh42u5od9"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","tag_id":"ck4b9g7rr00094ejd4gt5fm0d","_id":"ck4b9g7u400704ejd2i49gdke"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","tag_id":"ck4b9g7ru000e4ejd5qprc8t0","_id":"ck4b9g7u400714ejd16qf55ok"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","tag_id":"ck4b9g7s9000z4ejdgs3wh9ch","_id":"ck4b9g7u400734ejdg48042r7"},{"post_id":"ck4b9g7su002h4ejd9ngt0fez","tag_id":"ck4b9g7u2006p4ejdfmfx7lga","_id":"ck4b9g7u400744ejdcin127n2"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7u500764ejd8u5t2jrv"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7rr00094ejd4gt5fm0d","_id":"ck4b9g7u500774ejdchfsaaph"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7ru000e4ejd5qprc8t0","_id":"ck4b9g7u500794ejd5m4n25hn"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7rw000j4ejdbucz75im","_id":"ck4b9g7u5007a4ejd1rrba6kf"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7rz000o4ejd5prl371a","_id":"ck4b9g7u6007c4ejdbvxa1p4l"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7s4000u4ejd7f3a6ck0","_id":"ck4b9g7u6007d4ejd6owj1itz"},{"post_id":"ck4b9g7sv002m4ejdfwsmfy6k","tag_id":"ck4b9g7u3006s4ejdccso4mcy","_id":"ck4b9g7u6007e4ejd0ptbfu4d"},{"post_id":"ck4b9g7sw002p4ejdfefg0oj8","tag_id":"ck4b9g7u3006v4ejd48ligys7","_id":"ck4b9g7u6007g4ejdb5m56n2j"},{"post_id":"ck4b9g7sw002p4ejdfefg0oj8","tag_id":"ck4b9g7u4006y4ejd5toaautj","_id":"ck4b9g7u6007h4ejd3m94hif7"},{"post_id":"ck4b9g7sw002p4ejdfefg0oj8","tag_id":"ck4b9g7u400724ejd9unfdql5","_id":"ck4b9g7u7007j4ejd21p23bht"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7u7007k4ejd5kh61t9y"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","tag_id":"ck4b9g7u500754ejdcq6z2vtk","_id":"ck4b9g7u8007m4ejdgdfnhuwm"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","tag_id":"ck4b9g7u500784ejd7ba4hqkp","_id":"ck4b9g7u8007n4ejd5aevgt4v"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","tag_id":"ck4b9g7u6007b4ejdeth3el9h","_id":"ck4b9g7u8007p4ejdcruvgojg"},{"post_id":"ck4b9g7t2002u4ejdb72xf5gx","tag_id":"ck4b9g7u6007f4ejd8hyc4rqj","_id":"ck4b9g7u8007q4ejdh7ue41a3"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7u9007s4ejdhw0n3f1m"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","tag_id":"ck4b9g7ss002a4ejdd12tg9af","_id":"ck4b9g7u9007t4ejdawmsc4dw"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","tag_id":"ck4b9g7sv002j4ejd6i9ea51t","_id":"ck4b9g7u9007v4ejdbegmhebh"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","tag_id":"ck4b9g7t1002r4ejd1a2t2sse","_id":"ck4b9g7u9007w4ejd7wbu52c4"},{"post_id":"ck4b9g7t3002x4ejd17qo3ahx","tag_id":"ck4b9g7t400304ejddlx090tq","_id":"ck4b9g7ua007y4ejdh2d10mdj"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","tag_id":"ck4b9g7ro00044ejd705f1qwy","_id":"ck4b9g7ua007z4ejd8hg6et5v"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","tag_id":"ck4b9g7u500754ejdcq6z2vtk","_id":"ck4b9g7ub00814ejd4kqpa9l1"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","tag_id":"ck4b9g7u8007o4ejd2s5v9w74","_id":"ck4b9g7uc00824ejdd3uj5n9s"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","tag_id":"ck4b9g7u9007r4ejdhs1i1ac2","_id":"ck4b9g7uc00844ejd8lc65icl"},{"post_id":"ck4b9g7t400314ejd5pnhfxw7","tag_id":"ck4b9g7u6007f4ejd8hyc4rqj","_id":"ck4b9g7uc00854ejd15k1ffiz"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7ud00884ejd9dywa072"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","tag_id":"ck4b9g7u400724ejd9unfdql5","_id":"ck4b9g7ud00894ejdgmq08yb6"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","tag_id":"ck4b9g7uc00834ejd55ulagy5","_id":"ck4b9g7ue008b4ejd3uqvcnxe"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","tag_id":"ck4b9g7uc00864ejd9ticb8hk","_id":"ck4b9g7ue008c4ejdcgsw3399"},{"post_id":"ck4b9g7t700384ejdd7180z15","tag_id":"ck4b9g7tc003t4ejd28976pyi","_id":"ck4b9g7ue008f4ejd786rebxz"},{"post_id":"ck4b9g7t700384ejdd7180z15","tag_id":"ck4b9g7ud008a4ejd0ala3thi","_id":"ck4b9g7ue008g4ejd1ewx9za8"},{"post_id":"ck4b9g7t700384ejdd7180z15","tag_id":"ck4b9g7ue008d4ejd830e9dwa","_id":"ck4b9g7ue008h4ejd4xc524sg"},{"post_id":"ck4b9g7t700384ejdd7180z15","tag_id":"ck4b9g7ue008e4ejdethxeyxf","_id":"ck4b9g7uf008i4ejd2nbz3an1"},{"post_id":"ck4b9g7t700384ejdd7180z15","tag_id":"ck4b9g7rr00094ejd4gt5fm0d","_id":"ck4b9g7uf008j4ejddvfa6pis"},{"post_id":"ck4b9g7t500354ejd7q5k4abh","tag_id":"ck4b9g7ud008a4ejd0ala3thi","_id":"ck4c9i6cj00009cfy9rp05pce"}],"Tag":[{"name":"java　","_id":"ck4b9g7ro00044ejd705f1qwy"},{"name":"并发编程","_id":"ck4b9g7rr00094ejd4gt5fm0d"},{"name":"同步","_id":"ck4b9g7ru000e4ejd5qprc8t0"},{"name":"公平锁","_id":"ck4b9g7rw000j4ejdbucz75im"},{"name":"非公平锁","_id":"ck4b9g7rz000o4ejd5prl371a"},{"name":"可重入锁","_id":"ck4b9g7s4000u4ejd7f3a6ck0"},{"name":"读写锁","_id":"ck4b9g7s9000z4ejdgs3wh9ch"},{"name":"共享锁","_id":"ck4b9g7sb00144ejdd8wj3cil"},{"name":"独占锁","_id":"ck4b9g7sd00194ejd2qhib5jz"},{"name":"ReentrantReadWriteLock","_id":"ck4b9g7sh001g4ejd5152ep2v"},{"name":"clojure","_id":"ck4b9g7sk001m4ejd9j0ycvih"},{"name":"教程","_id":"ck4b9g7sm001u4ejd6q1n7j4s"},{"name":"并发编程语言","_id":"ck4b9g7sp00214ejd50a6gjrc"},{"name":"Spring","_id":"ck4b9g7ss002a4ejdd12tg9af"},{"name":"AOP","_id":"ck4b9g7sv002j4ejd6i9ea51t"},{"name":"IOC控制反转","_id":"ck4b9g7t1002r4ejd1a2t2sse"},{"name":"BeanFactory","_id":"ck4b9g7t400304ejddlx090tq"},{"name":"BeanFactory生命周期","_id":"ck4b9g7t7003a4ejdej8e1drm"},{"name":"mysql","_id":"ck4b9g7t9003h4ejd43nsdq5c"},{"name":"java","_id":"ck4b9g7tc003t4ejd28976pyi"},{"name":"spring","_id":"ck4b9g7td00404ejd29se1f0f"},{"name":"设计模式","_id":"ck4b9g7ti004a4ejdbmm8341b"},{"name":"Hashtable","_id":"ck4b9g7tv005q4ejdhfupez11"},{"name":"HashMap","_id":"ck4b9g7tv005r4ejd4wl1dxrv"},{"name":"hashmap","_id":"ck4b9g7tw005v4ejd2ii64kln"},{"name":"LinkedArray","_id":"ck4b9g7tw00604ejdcnt30rrm"},{"name":"LinkedHashMap","_id":"ck4b9g7ty00644ejdhyte9hbl"},{"name":"awk","_id":"ck4b9g7ty00654ejdgz2mfzdd"},{"name":"linux","_id":"ck4b9g7tz00684ejdd0k2do2p"},{"name":"文本处理","_id":"ck4b9g7tz00694ejdb554el9p"},{"name":"异步框架","_id":"ck4b9g7u0006d4ejdg6p739n4"},{"name":"parseq","_id":"ck4b9g7u0006f4ejd7l9sdgb7"},{"name":"线程饥渴","_id":"ck4b9g7u2006p4ejdfmfx7lga"},{"name":"ReentrantLock","_id":"ck4b9g7u3006s4ejdccso4mcy"},{"name":"Netty","_id":"ck4b9g7u3006v4ejd48ligys7"},{"name":"源码分析","_id":"ck4b9g7u4006y4ejd5toaautj"},{"name":"NIO","_id":"ck4b9g7u400724ejd9unfdql5"},{"name":"Dubbo","_id":"ck4b9g7u500754ejdcq6z2vtk"},{"name":"SPI","_id":"ck4b9g7u500784ejd7ba4hqkp"},{"name":"反射","_id":"ck4b9g7u6007b4ejdeth3el9h"},{"name":"rpc","_id":"ck4b9g7u6007f4ejd8hyc4rqj"},{"name":"负载均衡","_id":"ck4b9g7u8007o4ejd2s5v9w74"},{"name":"LoadBalance","_id":"ck4b9g7u9007r4ejdhs1i1ac2"},{"name":"Linux内核","_id":"ck4b9g7uc00834ejd55ulagy5"},{"name":"网络编程","_id":"ck4b9g7uc00864ejd9ticb8hk"},{"name":"C++","_id":"ck4b9g7ud008a4ejd0ala3thi"},{"name":"Thread","_id":"ck4b9g7ue008d4ejd830e9dwa"},{"name":"Linux编程","_id":"ck4b9g7ue008e4ejdethxeyxf"}]}}