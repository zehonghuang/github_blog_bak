---
title: 初学Clojure—定义函数
date: 2017-01-17 21:23:53
categories:
- 函数编程
tags:
- clojure
- 并发编程语言
---

严格来说，Lisp是一种多范式语言，不仅仅是函数式编程，也可面向对象，也可面向过程，但它的特性确实在函数式编程中更为出色些。Clojure作为Lisp家族中的一员，继承祖先的优良传统，也有自己的特色，特别在“函数是第一公民”的原则上。比如匿名函数的递归，在Common Lisp只能自定义宏实现，在Scheme优雅不少，但也好看不到哪去。

---

- ### <font color=#0099ff>定义有名字的函数</font>

定义函数可以`defn`声明有名字的函数，最后一条表达式的结果作为返回值，`defn`后面是函数名，`[]`则是参数。
``` clojure
(defn i_am_fn [x y]
  (* x y))

;clojure的函数重载，只更参数个数有关，与参数类型无关。
(defn i_am_fn [x y z]
  (println x "+" y "+" z "=")
  (* x y z)
  (+ x y z))
```

- ### <font color=#0099ff>定义‘没有’名字的函数—匿名函数</font>

定义匿名函数则用`fn`，同样最后一条表达式的结果作为返回值，`fn`后面也可以有函数名（可选），`[]`里是参数列表。
``` clojure
(fn [x y]
  (println "i don't kown!!!")
  (+ x y))
```

匿名函数也可以重载，这在匿名函数的递归或互相调用十分有用！我们来看看下面使用递归实现阶乘。
``` clojure
;先看给予匿名函数一个函数名，可以重载两个参数长度不一样的函数。
;factorial[x]调用factorial[x y]，而factorial[x y]做尾递归，并返回给factorial[x]
;但这种写法有个缺点，就是同时暴露了[x]和[x y]两个函数，而我们只需要[x]即可
(fn factorial
  ([x]
    (factorial (- x 1) x))
  ([x y]
    (if (< x 1)
      y
      (factorial (- x 1) (* x y)))))

;等价于
;也许我们可以用偏函数？将上面的factorial[x]抽取出来，为factorial[x y]再做一层匿名函数。
;#是函数的字面量
(#((fn factorial [x y]
     (if (< x 1)
       y
       (factorial (- x 1) (* y x)))) % 1) 10)

;等价于
;letfn是一种类似于let本地绑定的局部函数声明，可以声明多个本地函数，离开letfn则失效。
;形式上于第一种方式相似，但又有很大不同。
;1、声明的本地函数不一定是重载函数，你看第一种方式，并不能有两个参数长度相同的函数，而letfn允许，只需要函数名不同即可
;2、在最后的返回值，你可以选择暴露哪个函数，而其他函数则私有化
(letfn [(factorial [x]
          (factorial_2 (- x 1) x))
        (factorial_2 [x y]
          (if (< x 1)
            y
            (factorial_2 (- x 1) (* x y))))]
  #(factorial %))
```
