---
title: 初学Clojure—集合与数据结构
tags:
  - clojure
  - 教程
  - 并发编程语言
categories:
  - 函数编程
date: 2017-01-23 23:51:02
---


这个很重要，不需要多说，clojure提供了vector、list、queue、set、map这几种数据结构，来看看它们的基本操作。

---

- ### <font color=#0099ff>非写入硬盘的数据持久化</font>

这里说的数据持久化，指的是不变量，即值是不能被改变的。值的不可变，使得我们不需要担心值更新所带来的不确定性，在并发场景下不需要花费过多精力维护数据的准确性。
``` clojure
;声明list
(def lst1 (list 1 2 3 4))
;添加新元素，它重新生产一个“新列表”
(def lst2 (conj lst 5));=(5 1 2 3 4)
;lst引用依旧指向(1 2 3 4)
lst1 ;=(1 2 3 4)
```
为达到值的不可变，而创建一个新值，可能会对此认为这实在浪费内存空间，每次改变值都要重新复制一份出来。

其实不是的，用过git的伙伴都知道，即使在文件里加个空格都会生成一个新的版本号，clojure对值的管理与此有一些类似。假如你对`lst1`做任何增删改，所有元素都会存在于它原本的历史版本中，并且每个版本间都共享结构元素。元素5存在于`lst2`这个版本中，`(1 2 3 4)`则`lst1`与`lst2`共享。所有版本会形成一棵数，管理map也是如此，只不过版本树会更加复杂。

- ### <font color=#0099ff>它叫做向量，不叫数组</font>

在clojure我们管它叫vector，不叫array，尽管都以数字作为索引，它是不可变，它的字面量是`[]`。

如何创建向量呢？
``` clojure
;我们可以这样创建一个vector，直接使用字面量
(def vec1 [1 2 3 4 5])
;用vec来引入某个集合的元素，如果是个map，vec2会是个多维向量，至少二维
(def vec2 (vec (range 5)))
;显然，是往一个vector塞另外一个集合
(def vec3 (into vec1 (range 6 10)))
```

可以限制vector为基础数据类型的集合，只要使用`vector-of`函数即可，支持`:int`、`:long`、`:float`、`:double`、`:byte`、`:short`、`:boolean`、`:char`这些基础类型。
``` clojure
(into (vector-of :int) [Math/PI 2 1.4]);=[3 2 1]
(into (vector-of :char) [100 102 104]);=[\d \f \h]
(into (vector-of :boolean) [false true 1 nil]);=[false true true false]
(into (vector-of :long) ["string" "number" 10000])
;=ClassCastException java.lang.String cannot be cast to java.lang.Number
```

有索引，自然可以用下标获取元素，有`nth`、`get`、向量自身作为函数三种方式，每种都有那么一点不同。
``` clojure
(def nil_vec nil)
(def empty_vec [])
(def char_vec [\a \b \c \d \f])

(nth nil_vec 3);=nil
(nth empty_vec 3);=IndexOutOfBoundsException
(nth char_vec 3);=\d
;支持not find参数，找不到元素则返回该实参
(nth char_vec 100 :no!);=:no!

(get nil_vec 3);=nil
(get empty_vec 3);=nil
(get char_vec 3);=\d
;同上
(get char_vec 100 :no!);=:no!

;clojure有个奇妙的特性，就是集合本身可以作为函数，返回自己内部的元素
(nil_vec 3);=NullPointerException
(empty_vec 3);=IndexOutOfBoundsException
(char_vec 3);=\d
;然而，它并不支持上面两种方式支持的not find参数
```
<font color=#f28080>以上三种并没有那个最好，更多时候需要具体到业务场景，又或者依据个人喜好。</font>

那么来看看怎么修改元素。
``` clojure
(def num_vec [1 2 3 4 5])
;直接修改对于下标的元素
(assoc num_vec 2 "string");=[1 2 "string" 4 5]
;这个则是使用一个函数去改变对应下标的元素
(update num_vec 2 * 100);=[1 2 300 4 5]

;遇到多维向量，也提供了get-in、assoc-in、update-in三个函数改变或获取被嵌套的元素
(def num_vec2 [[1 2 3] [4 5 6] [7 8 9]])
(get-in num_vec2 [1 2]);=6
(get-in num_vec2 [1 6]);=nil
;支持not find参数
(get-in num_vec2 [1 6] :no!);=:no!
(assoc-in num_vec2 [1 2] \s);=[[1 2 3] [4 5 \s] [7 8 9]]
;追加到最后一项，如果[1 4]以上则会抛出IndexOutOfBoundsException
(assoc-in num_vec2 [1 3] \s);=[[1 2 3] [4 5 6 \s] [7 8 9]]
(update-in num_vec2 [1 2] * 100);=[[1 2 3] [4 5 600] [7 8 9]]
(update-in num_vec2 [1 3] * 100);=NullPointerException
```

vector提供了三个函数，使其支持栈操作，分别是`peek`返回栈顶、`pop`除去栈顶、`conj`推入栈，由于vector是不可变的，所以并不像以往的pop和push完全一样。
``` clojure
(def my_stack [1 2 3 4 5])
(peek my_stack);=5
(pop my_stack);=[1 2 3 4]
(conj my_stack \s);=[1 2 3 4 5 \s]
```
