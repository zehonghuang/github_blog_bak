---
title: 【Dubbo源码分析】四种负载均衡
date: 2018-09-06 12:26:37
tags:
  - java　
  - Dubbo
  - 负载均衡
  - LoadBalance
  - rpc
categories:
  - rpc框架
---

ccc

---

- AbstractLoadBalance的模版方法

``` java
public abstract class AbstractLoadBalance implements LoadBalance {

  static int calculateWarmupWeight(int uptime, int warmup, int weight) {
    //weight * uptime / warmup
    int ww = (int) ((float) uptime / ((float) warmup / (float) weight));
    return ww < 1 ? 1 : (ww > weight ? weight : ww);
  }

  @Override
  public <T> Invoker<T> select(List<Invoker<T>> invokers, URL url, Invocation invocation) {
    if (invokers == null || invokers.isEmpty())
      return null;
    if (invokers.size() == 1)
      return invokers.get(0);
    return doSelect(invokers, url, invocation);
  }

  protected abstract <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation);

  protected int getWeight(Invoker<?> invoker, Invocation invocation) {
    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);
    if (weight > 0) {
      long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);
      if (timestamp > 0L) {
        int uptime = (int) (System.currentTimeMillis() - timestamp);
        int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);
        if (uptime > 0 && uptime < warmup) {
          weight = calculateWarmupWeight(uptime, warmup, weight);
        }
      }
    }
    return weight;
  }

}
```

- RandomLoadBalance随机访问

``` java
@Override
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
  int length = invokers.size(); // Number of invokers
  int totalWeight = 0; // The sum of weights
  boolean sameWeight = true; // Every invoker has the same weight?
  for (int i = 0; i < length; i++) {
    int weight = getWeight(invokers.get(i), invocation);
    totalWeight += weight; // Sum
    if (sameWeight && i > 0
          && weight != getWeight(invokers.get(i - 1), invocation)) {
      sameWeight = false;
    }
  }
  if (totalWeight > 0 && !sameWeight) {
    // If (not every invoker has the same weight & at least one invoker's weight>0), select randomly based on totalWeight.
    int offset = random.nextInt(totalWeight);
    // Return a invoker based on the random value.
    for (int i = 0; i < length; i++) {
      offset -= getWeight(invokers.get(i), invocation);
      if (offset < 0) {
        return invokers.get(i);
      }
    }
  }
  // If all invokers have the same weight value or totalWeight=0, return evenly.
  return invokers.get(random.nextInt(length));
}
```

- RoundRobinLoadBalance权重比例轮训

``` java
@Override
protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {
  String key = invokers.get(0).getUrl().getServiceKey() + "." + invocation.getMethodName();
  int length = invokers.size(); // Number of invokers
  int maxWeight = 0; // The maximum weight
  int minWeight = Integer.MAX_VALUE; // The minimum weight
  final LinkedHashMap<Invoker<T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap<Invoker<T>, IntegerWrapper>();
  int weightSum = 0;
  for (int i = 0; i < length; i++) {
    int weight = getWeight(invokers.get(i), invocation);
    maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
    minWeight = Math.min(minWeight, weight); // Choose the minimum weight
    if (weight > 0) {
      invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
      weightSum += weight;
    }
  }
  AtomicPositiveInteger sequence = sequences.get(key);
  if (sequence == null) {
    sequences.putIfAbsent(key, new AtomicPositiveInteger());
    sequence = sequences.get(key);
  }
  int currentSequence = sequence.getAndIncrement();
  if (maxWeight > 0 && minWeight < maxWeight) {
    int mod = currentSequence % weightSum;
    for (int i = 0; i < maxWeight; i++) {
      for (Map.Entry<Invoker<T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) {
        final Invoker<T> k = each.getKey();
        final IntegerWrapper v = each.getValue();
        if (mod == 0 && v.getValue() > 0) {
          return k;
        }
        if (v.getValue() > 0) {
          v.decrement();
          mod--;
        }
      }
    }
  }
  return invokers.get(currentSequence % length);
}
```

- LeastActiveLoadBalance最低活跃量

- ConsistentHashLoadBalance一致性哈希
