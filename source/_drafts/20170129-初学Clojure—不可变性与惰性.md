---
title: 初学Clojure—不可变性与惰性
date: 2017-01-29 22:15:15
tags:
  - clojure
  - 教程
  - 并发编程语言
categories:
  - 函数编程
---

在前面有简易说到不可变性是咋回事，这里要稍微理性一些认识不可变性中结构化共享的概念。结构化共享可以使数据结构少占内存，clojure还提供了更节省内存的方法—惰性。

---

- ### <font color=#0099ff>数据也有“版本树”？</font>

Clojure的任何值都是不可变的，引用可以任意赋值。即只有可变引用，没有可变对象。
``` clojure
(def a '(1 2 3 4))
(def a (conj 1 a));=(5 1 2 3 4)
```

数据的不可变性给多线程场景下的数据共享带来不少福利，因为数据是持久永恒不变的，所以线程间不必担心彼此修改了数据而导致程序不确定性。如果对象是可变的，那么就会像java，需要一堆工具和大部分精力去保证数据对每个线程来说都是正确的，极其不便。

数据是不可变的，那我要是需要修改数据，怎么办？之前说了，对不可变数据做任何修改，数据都会重新“拷贝”出一份，赋给新的引用。这里说的“拷贝”不是真的把数据复制一份，而是开头说的结构化共享。

``` clojure
;继续上面的list
;好比a和b共享'(1 2 3 4)部分
(def a '(1 2 3 4))
(def b (conj a 5));=(5 1 2 3 4)
;做一下校验
(identical? a (next b));=true
;在这个简单例子的视图可见，5确实添加在链表，但指向5的指针是b，指针a没有任何偏移。
; b    a
; |    |
;[5]--[1]--[2]--[3]--[4]
```
